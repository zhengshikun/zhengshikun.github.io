<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[es6-变量的解构赋值]]></title>
    <url>%2F2018%2F12%2F15%2Fes6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的变量的解构赋值。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 数组的解构赋值基本用法ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。 1let [a, b, c] = [1, 2, 3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象的解构赋值解构不仅可以用于数组，还可以用于对象。 123let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // undefined 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 对象的解构也可以指定默认值。 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = &apos;Something went wrong&apos; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot; 默认值生效的条件是，对象的属性值严格等于undefined。 12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 1let &#123; log, sin, cos &#125; = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = &apos;hello&apos;;len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值。 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 函数参数的解构也可以使用默认值。 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 不能使用圆括号的情况（1）变量声明语句 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数 函数参数也属于变量声明，因此不能带有圆括号 1234// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; （3）赋值语句的模式 123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将一部分模式放在圆括号之中，导致报错。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多 交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取 JSON 数据解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678910let jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125; = &#123;&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句 遍历 Map 结构任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-let和const命令]]></title>
    <url>%2F2018%2F12%2F14%2Fes6-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的let和const命令章节。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 let命令基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 块级作用域为什么需要块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变,必须立即初始化. 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 下面是另一个例子。 1234const a = [];a.push(&apos;Hello&apos;); // 可执行a.length = 0; // 可执行a = [&apos;Dave&apos;]; // 报错 如果真的想将对象冻结，应该使用Object.freeze方法。 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html语义化]]></title>
    <url>%2F2018%2F12%2F14%2Fhtml%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 为什么要语义化 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 写HTML代码时应注意什么 尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置。 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 HTML5新增了哪些语义标签在HTML5出来之前，我们用div来表示页面章节，但是这些div都没有实际意义。（即使我们用css样式的id和class形容这块内容的意义）。这些标签只是我们提供给浏览器的指令，只是定义一个网页的某些部分。但现在，那些之前没“意义”的标签因为html5的出现消失了，这就是我们平时说的“语义”。 看下图没有用div标签来布局 html5的布局嗯，如上图那个页面结构没有一个div，都是采用html5语义标签（用哪些标签，关键取决于你的设计目标）。 但是也不要因为html5新标签的出现，而随意用之，错误的使用肯定会事与愿违。所以有些地方还是要用div的，就是因为div没有任何意义的元素，他只是一个标签，仅仅是用来构建外观和结构。因此是最适合做容器的标签。 W3C定义了这些语义标签，不可能完全符合我们有时的设计目标，就像制定出来的法律不可能流传100年都不改变，更何况它才制定没多久，不可能这些语义标签对所以设计目标的适应。只是一定程度上的“通用”，我们的目标是让爬虫读懂重要的东西就够了。 结论：不能因为有了HTML5标签就弃用了div，每个事物都有它的独有作用的。 节点元素标签因使用的地方不同，我将他们分为：节元素标签、文本元素标签、分组元素标签分开来讲解HTML5中新增加的语义化标签和使用总结。 header元素header 元素代表“网页”或“section”的页眉。通常包含h1-h6元素或hgroup，作为整个页面或者一个内容块的标题。也可以包裹一节的目录部分，一个搜索框，一个nav，或者任何相关logo。 整个页面没有限制header元素的个数，可以拥有多个，可以为每个内容块增加一个header元素 123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;h1&gt;网站副标题&lt;/h1&gt; &lt;/hgroup&gt;&lt;/header&gt; header使用注意： 可以是“网页”或任意“section”的头部部分； 没有个数限制。 如果hgroup或h1-h6自己就能工作的很好，那就不要用header。 footer元素footer元素代表“网页”或“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。如果footer元素包含了整个节，那么它们就代表附录，索引，提拔，许可协议，标签，类别等一些其他类似信息。 123&lt;footer&gt; COPYRIGHT@zhengshikun&lt;/footer&gt; footer使用注意： 可以是“网页”或任意“section”的底部部分； 没有个数限制，除了包裹的内容不一样，其他跟header类似。 hgroup元素hgroup元素代表“网页”或“section”的标题，当元素有多个层级时，该元素可以将h1到h6元素放在其内，譬如文章的主标题和副标题的组合 1234&lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5语义化标签和更简洁的结构&lt;/h1&gt; &lt;h2&gt;HTML 5&lt;/h2&gt;&lt;/hgroup&gt; hgroup使用注意： 如果只需要一个h1-h6标签就不用hgroup 如果有连续多个h1-h6标签就用hgroup 如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签 nav元素nav元素代表页面的导航链接区域。用于定义页面的主要导航部分。 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;HTML 5&lt;/li&gt; &lt;li&gt;CSS3&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; nav使用注意： 用在整个页面主要导航部分上，不合适就不要用nav元素； aside元素aside元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。（特殊的section） 在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。 1234567&lt;article&gt; &lt;p&gt;内容&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;作者简介&lt;/h1&gt; &lt;p&gt;hello,world&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt; aside使用总结： aside在article内表示主要内容的附属信息， 在article之外则可做侧边栏，没有article与之对应，最好不用。 如果是广告，其他日志链接或者其他分类导航也可以用 section元素section元素代表文档中的“节”或“段”，“段”可以是指一篇文章里按照主题的分段；“节”可以是指一个页面里的分组。 section通常还带标题，虽然html5中section会自动给标题h1-h6降级，但是最好手动给他们降级。如下： 1234567891011&lt;section&gt; &lt;h1&gt;section是啥？&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;关于section&lt;/h1&gt; &lt;p&gt;section的介绍&lt;/p&gt; &lt;section&gt; &lt;h3&gt;关于其他&lt;/h3&gt; &lt;p&gt;关于其他section的介绍&lt;/p&gt; &lt;/section&gt; &lt;/article&gt;&lt;/section&gt; section使用注意： 一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。 表示文档中的节或者段； article、nav、aside可以理解为特殊的section，所以如果可以用article、nav、aside就不要用section，没实际意义的就用div article元素article元素最容易跟section和div容易混淆，其实article代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。（特殊的section） 除了它的内容，article会有一个标题（通常会在header里），会有一个footer页脚。我们举几个例子介绍一下article，好更好区分article、section、div 1234567&lt;article&gt; &lt;h1&gt;一篇文章&lt;/h1&gt; &lt;p&gt;文章内容..&lt;/p&gt; &lt;footer&gt; &lt;p&gt;&lt;small&gt;版权：html5jscss网所属，作者：小北&lt;/small&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt; 上例是最好简单的article标签使用情况，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论，如下： 12345678910111213141516171819202122232425262728293031&lt;article&gt; &lt;header&gt; &lt;h1&gt;一篇文章&lt;/h1&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2012-10-03&quot;&gt;2012/10/03&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;文章内容..&lt;/p&gt; &lt;article&gt; &lt;h2&gt;评论&lt;/h2&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论者: XXX&lt;/h3&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2012-10-03T19:10-08:00&quot;&gt;~1 hour ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;哈哈哈&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论者: XXX&lt;/h3&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2012-10-03T19:10-08:00&quot;&gt;~1 hour ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;哈？哈？哈？&lt;/p&gt; &lt;/article&gt; &lt;/article&gt;&lt;/article&gt; article内部嵌套article，有可能是评论或其他跟文章有关联的内容。那article内部嵌套section一般是什么情况呢。如下： 12345678910111213141516&lt;article&gt; &lt;h1&gt;前端技术&lt;/h1&gt; &lt;p&gt;前端技术有那些&lt;/p&gt; &lt;section&gt; &lt;h2&gt;CSS&lt;/h2&gt; &lt;p&gt;样式..&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;JS&lt;/h2&gt; &lt;p&gt;脚本&lt;/p&gt; &lt;/section&gt;&lt;/article&gt; 因为文章内section部分虽然也是独立的部分，但是它门只能算是组成整体的一部分，从属关系，article是大主体，section是构成这个大主体的一部分。本网站的全部文章都是article嵌套一个个section章节，这样能让浏览器更容易区分各个章节所包括的内容。 那section内部嵌套article又有哪些情况呢，如下 1234567891011121314151617181920&lt;section&gt; &lt;h1&gt;介绍: 网站制作成员配备&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;设计师&lt;/h2&gt; &lt;p&gt;设计网页的...&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;程序员&lt;/h2&gt; &lt;p&gt;后台写程序的..&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;前端工程师&lt;/h2&gt; &lt;p&gt;给楼上两位打杂的..&lt;/p&gt; &lt;/article&gt;&lt;/section&gt; 设计师、程序员、前端工程师都是一个独立的整体，他们组成了网站制作基本配备，当然还有其他成员~。设计师、程序员、前端工程师就像article，是一个个独立的整体，而section将这些自成一体的article包裹，就组成了一个团体。 article和section和例子就例举这么多了，具体情况具体分析，不易深究。漏了div，其实div就是只是想用来把元素组合或者给它们加样式时使用。 article使用注意： 自身独立的情况下：用article 是相关内容：用section 没有语义的：用div HTML5其他结构元素标签HTML5节元素标签包括body article nav aside section header footer hgroup ，还有h1-h6 address。 address代表区块容器，必须是作为联系信息出现，邮编地址、邮件地址等等,一般出现在footer。 h1-h6因为hgroup，section和article的出现，h1-h6定义也发生了变化，允许一张页面出现多个h1。 原文：https://www.cnblogs.com/fliu/articles/5244866.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass基本用法]]></title>
    <url>%2F2018%2F12%2F13%2Fsass%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 使用变量sass使用$符号来标识变量,比如$highlight-color和$sidebar-width。 变量声明sass变量的声明和css属性的声明很像： 12$highlight-color: #F90;$basic-border: 1px solid black; 这时变量还没有生效，除非你引用这个变量 变量引用12345678910111213$nav-color: #F90;nav &#123; $width: 100px; width: $width; color: $nav-color;&#125;//编译后nav &#123; width: 100px; color: #F90;&#125; $width这个变量定义在了nav的{ }规则块内，所以它只能在nav规则块内使用。 变量名用中划线还是下划线分隔sass并不想强迫任何人一定使用中划线或下划线，所以这两种用法相互兼容。用中划线声明的变量可以使用下划线的方式引用，反之亦然。这意味着即使compass选择用中划线的命名方式，这并不影响你在使用compass的样式中用下划线的命名方式进行引用： 12345678910$link-color: blue;a &#123; color: $link_color;&#125;//编译后a &#123; color: blue;&#125; 嵌套CSS 规则1234#content &#123; background-color: #f5f5f5; aside &#123; background-color: #eee &#125;&#125; 123 /* 编译后 */#content &#123; background-color: #f5f5f5 &#125;#content aside &#123; background-color: #eee &#125; 大多数情况下这种简单的嵌套都没问题，但是有些场景下不行，比如你想要在嵌套的选择器 里边立刻应用一个类似于:hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构&amp;。 父选择器的标识符&amp;一般情况下，sass在解开一个嵌套规则时就会把父选择器（#content）通过一个空格连接到子选择器的前边（article和aside）形成（#content article和#content aside）。这种在CSS里边被称为后代选择器，因为它选择ID为content的元素内所有命中选择器article和aside的元素。但在有些情况下你却不会希望sass使用这种后代选择器的方式生成这种连接。 1234article a &#123; color: blue; :hover &#123; color: red &#125;&#125; 上面的无法正常工作，解决之道为使用一个特殊的sass选择器，即父选择器。在使用嵌套规则时，父选择器能对于嵌套规则如何解开提供更好的控制。它就是一个简单的&amp;符号。 1234article a &#123; color: blue; &amp;:hover &#123; color: red &#125;&#125; 当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&amp;被父选择器直接替换： 123/* 编译后 */article a &#123; color: blue &#125;article a:hover &#123; color: red &#125; 群组选择器的嵌套123.container &#123; h1, h2, h3 &#123;margin-bottom: .8em&#125;&#125; 12/* 编译后 */.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125; 123nav, aside &#123; a &#123;color: blue&#125;&#125; 12/* 编译后 */nav a, aside a &#123;color: blue&#125; 有利必有弊，你需要特别注意群组选择器的规则嵌套生成的css。虽然sass让你的样式表看上去很小，但实际生成的css却可能非常大，这会降低网站的速度。 子组合选择器和同层组合选择器：&gt;、+和~可以把它们放在外层选择器后边，或里层选择器前边： 123456789article &#123; ~ article &#123; border-top: 1px dashed #ccc &#125; &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; nav + &amp; &#123; margin-top: 0 &#125;&#125; 123456/* 编译后 */article ~ article &#123; border-top: 1px dashed #ccc &#125;article &gt; footer &#123; background: #eee &#125;article dl &gt; dt &#123; color: #333 &#125;article dl &gt; dd &#123; color: #555 &#125;nav + article &#123; margin-top: 0 &#125; 嵌套属性123456nav &#123; border: 1px solid #ccc &#123; left: 0px; right: 0px; &#125;&#125; 123456/* 编译后 */nav &#123; border: 1px solid #ccc; border-left: 0px; border-right: 0px;&#125; 导入SASS文件使用sass的@import规则并不需要指明被导入文件的全名。你可以省略.sass或.scss文件后缀（见下图）。这样，在不修改样式表的前提下，你完全可以随意修改你或别人写的被导入的sass样式文件语法，在sass和scss语法之间随意切换。举例来说，@import“sidebar”;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。 使用SASS部分文件当通过@import把sass样式分散到多个文件时，你通常只想生成少数几个css文件。那些专门为@import命令而编写的sass文件，并不需要生成对应的独立css文件，这样的sass文件称为局部文件。对此，sass有一个特殊的约定来命名这些文件。 此约定即，sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。当你@import一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。举例来说，你想导入themes/_night-sky.scss这个局部文件里的变量，你只需在样式表中写@import &quot;themes/night-sky&quot;;。 局部文件可以被多个不同的文件引用。当一些样式需要在多个页面甚至多个项目中使用时，这非常有用。在这种情况下，有时需要在你的样式表中对导入的样式稍作修改，sass有一个功能刚好可以解决这个问题，即默认变量值。 默认变量值一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明： 12345$link-color: blue;$link-color: red;a &#123;color: $link-color;&#125; 在上边的例子中，超链接的color会被设置为red。这可能并不是你想要的结果，假如你写了一个可被他人通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值。使用sass的!default标签可以实现这个目的。它很像css属性中!important标签的对立面，不同的是!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。 1234$fancybox-width: 400px !default;.fancybox &#123;width: $fancybox-width;&#125; 嵌套导入跟原生的css不同，sass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方。举例说明，有一个名为_blue-theme.scss的局部文件，内容如下： 1234aside &#123; background: blue; color: white;&#125; 然后把它导入到一个CSS规则内，如下所示： 12345678910.blue-theme &#123;@import &quot;blue-theme&quot;&#125;//生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。.blue-theme &#123; aside &#123; background: blue; color: #fff; &#125;&#125; 被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效。这些变量和混合器不会全局有效，这样我们就可以通过嵌套导入只对站点中某一特定区域运用某种颜色主题或其他通过变量配置的样式。 原生的CSS导入由于sass兼容原生的css，所以它也支持原生的CSS@import。尽管通常在sass中使用@import时，sass会尝试找到对应的sass文件并导入进来，但在下列三种情况下会生成原生的CSS@import，尽管这会造成浏览器解析css时的额外下载： 被导入文件的名字以.css结尾； 被导入文件的名字是一个URL地址 被导入文件的名字是CSS的url()值。 静默注释sass另外提供了一种不同于css标准注释格式/* ... */的注释语法，即静默注释，其内容不会出现在生成的css文件中。静默注释的语法跟JavaScript`Java等类C的语言中单行注释的语法相同，它们以//`开头，注释内容直到行末。 1234body &#123; color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */&#125; 混合器混合器使用@mixin标识符定义。看上去很像其他的CSS @标识符，比如说@media或者@font-face。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段sass代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。 12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 然后就可以在你的样式表中通过@include来使用这个混合器，放在你希望的任何地方。@include调用会把混合器中的所有样式提取出来放在@include被调用的地方。如果像下边这样写： 12345notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125; 12345678//sass最终生成：.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 通过使用参数，你可以使用混合器把你样式中的通用样式抽离出来，然后轻松地在其他地方重用。 何时使用混合器.notice是一个有语义的类名。如果一个html元素有一个notice的类名，就表明了这个html元素的用途：向用户展示提醒信息。rounded-corners混合器是展示性的，它描述了包含它的css规则最终的视觉样式，尤其是边框角的视觉样式。混合器和类配合使用写出整洁的html和css，因为使用语义化的类名亦可以帮你避免重复使用混合器。为了保持你的html和css`的易读性和可维护性，在写样式的过程中一定要铭记二者的区别。 混合器中的CSS规则混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性 12345678@mixin no-bullets &#123; list-style: none; li &#123; list-style-image: none; list-style-type: none; margin-left: 0px; &#125;&#125; 1234ul.plain &#123; color: #444; @include no-bullets;&#125; sass的@include指令会将引入混合器的那行代码替换成混合器里边的内容 12345678910/* 编译后 */ul.plain &#123; color: #444; list-style: none;&#125;ul.plain li &#123; list-style-image: none; list-style-type: none; margin-left: 0px;&#125; 混合器中的规则甚至可以使用sass的父选择器标识符&amp;。使用起来跟不用混合器时一样，sass解开嵌套规则时，用父规则中的选择器替代&amp;。 给混合器传参如果你写过JavaScript，这种方式跟JavaScript的function很像： 12345@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 当混合器被@include时，你可以把它当作一个css函数来传参。 123456789a &#123; @include link-colors(blue, red, green);&#125;//Sass最终生成的是：a &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 当你@include混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，sass允许通过语法$name: value的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可： 1234567a &#123; @include link-colors( $normal: blue, $visited: green, $hover: red );&#125; 默认参数值为了在@include混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用$name: default-value的声明形式，默认值可以是任何有效的css属性值，甚至是其他参数的引用，如下代码： 12345678910@mixin link-colors( $normal, $hover: $normal, $visited: $normal )&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 如果像下边这样调用：@include link-colors(red) $hover和$visited也会被自动赋值为red。 使用选择器继承来精简CSS使用sass的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan面向对象的css的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现，如下代码: 123456789//通过选择器继承继承样式.error &#123; border: 1px solid red; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 何时使用继承 想象一下你正在编写一个页面，给html元素添加类名，你发现你的某个类（比如说.seriousError）另一个类（比如说.error）的细化。你会怎么做？ 你可以为这两个类分别写相同的样式，但是如果有大量的重复怎么办？使用sass时，我们提倡的就是不要做重复的工作。 你可以使用一个选择器组（比如说.error`.seriousError）给这两个选择器写相同的样式。如果.error`的所有样式都在同一个地方，这种做法很好，但是如果是分散在样式表的不同地方呢？再这样做就困难多了。 你可以使用一个混合器为这两个类提供相同的样式，但当.error的样式修饰遍布样式表中各处时，这种做法面临着跟使用选择器组一样的问题。这两个类也不是恰好有相同的 样式。你应该更清晰地表达这种关系。 综上所述你应该使用@extend。让.seriousError从.error继承样式，使两者之间的关系非常清晰。更重要的是无论你在样式表的哪里使用.error`.seriousError`都会继承其中的样式。 继承的高级用法任何css规则都可以继承其他规则，几乎任何css规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个html元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对html元素添加的所有样式都会被继承。 继承的工作细节关于@extend有两个要点你应该知道。 跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。 继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，css层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。 使用继承的最佳实践通常使用继承会让你的css美观、整洁。因为继承只会在生成css时复制选择器，而不会复制大段的css属性。但是如果你不小心，可能会让生成的css中包含大量的选择器复制。 小结本文介绍了sass最基本部分,你可以轻松地使用sass编写清晰、无冗余、语义化的css。对于sass提供的工具你已经有了一个比较深入的了解，同时也掌握了何时使用这些工具的指导原则。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>sass</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端代码规范]]></title>
    <url>%2F2018%2F12%2F12%2Fweb%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[此项目用于记录规范的、高可维护性的前端代码，这是通过分析 Github 众多前端代码库，总结出来的前端代码书写规范。 前端普适性规范黄金定律不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的。 永远遵循同一套编码规范，可以是这里列出的，也可以是你自己总结的。 项目命名项目名全部采用小写方式，以中划线分隔，禁止驼峰式命名。比如：my-project-name 文件命名文件命名参照项目命名规则。比如: error-report.html 有复数结构时，要采用复数命名法，比如： scripts, styles, images, data-models 文件名中只可由小写英文字母 az 、排序数字 09 或间隔符 - 组成，禁止包含特殊符号，比如空格、`$` 等 为了醒目，某些说明文件的文件名，可以使用大写字母，比如: README, LICENSE 为更好的表达语义，文件名使用英文名词命名，或英文简写。 不允许命名带有广告等英文的单词，例如ad,adv,adver,advertising，防止该模块被浏览器当成垃圾广告过滤掉。任何文件的命名均如此。 文件常用命名: index.shtml 引导页&amp;首页 main.shtml 首页 download.shtml 下载页面 act.html 活动列表页面 video.html 视频 cdkey.html CDKEY页面 base.css 基本样式 layout.css 框架布局 module.css 模块样式 global.css 全局样式 font.css 字体样式 index.css 首页样式 link.css 链接样式 print.css 打印样式 HTML 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 嵌套的节点应该缩进（四个空格）。 在属性上，使用双引号，不要使用单引号。 不要在自动闭合标签结尾处使用斜线 / - HTML5 规范 指出他们是可选的。 1&lt;img src=&quot;images/logo.png&quot; alt=&quot;Company&quot;&gt; 不要忽略可选的关闭标签（例如，&lt;/li&gt; 和 &lt;/body&gt;）。 HTML5 doctype在每个 HTML 页面开头使用这个简单地 doctype 来启用标准模式，使其每个浏览器中尽可能一致的展现。 虽然 doctype 不区分大小写，但是按照惯例，doctype 大写 1&lt;!DOCTYPE html&gt; 语言属性123&lt;html lang=&quot;en&quot;&gt;&lt;/html&gt; 字符编码通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。这样 做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与 文档编码一致（一般采用 UTF-8 编码）。 1&lt;meta charset=&quot;UTF-8&quot;&gt; IE 兼容模式IE 支持通过特定的 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈 的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的模 式。 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 响应式1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 引入 CSS 和 JavaScript根据 HTML5 规范, 通常在引入 CSS 和 JavaScript 时不需要指明 type，因为 text/css 和 text/javascript 分别是他们的默认值。 12345678910&lt;!-- External CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;code-guide.css&quot;&gt;&lt;!-- In-document CSS --&gt;&lt;style&gt; /* ... */&lt;/style&gt;&lt;!-- JavaScript --&gt;&lt;script src=&quot;code-guide.js&quot;&gt;&lt;/script&gt; 实用高于完美尽量遵循 HTML 标准和语义，但是不应该以浪费实用性作为代价。任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。 减少标签数量在编写 HTML 代码时，需要尽量避免多余的父节点。很多时候，需要通过迭代和重构来使 HTML 变得更少。 参考下面的示例: 1234567&lt;!-- Not so great --&gt;&lt;span class=&quot;avatar&quot;&gt; &lt;img src=&quot;...&quot;&gt;&lt;/span&gt;&lt;!-- Better --&gt;&lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt; 属性顺序HTML 属性应该按照特定的顺序出现以保证易读性。 class id name data-* src, for, type, href, value , max-length, max, min, pattern placeholder, title, alt aria-*, role required, readonly, disabled class 是为高可复用组件设计的，理论上他们应处在第一位。id 更加具体而且应该尽量少使用（例如, 页内书签），所以他们处在第二位。 Boolean 属性Boolean 属性指不需要声明取值的属性。XHTML 需要每个属性声明取值，但是 HTML5 并不需要。 一个元素中 Boolean 属性的存在表示取值 true，不存在则表示取值 false。 简而言之，不要为 Boolean 属性添加取值。 1&lt;input type=&quot;text&quot; disabled&gt; JavaScript 生成标签在 JavaScript 文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免这种情况的出现。 CSS 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 使用组合选择器时，保持每个独立的选择器占用一行。 为了代码的易读性，在每个声明的左括号前增加一个空格。 声明块的右括号应该另起一行。 每条声明 : 后应该插入一个空格。 每条声明应该只占用一行来保证错误报告更加准确。 所有声明应该以分号结尾。虽然最后一条声明后的分号是可选的，但是如果没有他，你的代码会更容易出错。 逗号分隔的取值，都应该在逗号之后增加一个空格。 不要在颜色值 rgb() rgba() hsl() hsla()和 rect() 中增加空格，并且不要带有取值前面不必要的 0 (比如，使用 .5 替代 0.5)。 所有的十六进制值都应该使用小写字母，例如 #fff。因为小写字母有更多样的外形，在浏览文档时，他们能够更轻松的被区分开来。 尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。 为选择器中的属性取值添加引号，例如 input[type=&quot;text&quot;]。 他们只在某些情况下可有可无，所以都使用引号可以增加一致性。 不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;。 123456789101112131415/* Bad CSS */.selector, .selector-secondary, .selector[type=text] &#123; margin: 0px 0px 15px; background-color: rgba(0, 0, 0, 0.5); box-shadow: 0 1px 2px #CCC, inset 0 1px 0 #FFFFFF&#125;/* Good CSS */.selector,.selector-secondary,.selector[type=&quot;text&quot;] &#123; margin-bottom: 15px; background-color: rgba(0,0,0,.5); box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;&#125; 声明顺序相关的属性声明应该以下面的顺序分组处理： Positioning Box model 盒模型 Typographic 排版 Visual 外观 Positioning 处在第一位，因为他可以使一个元素脱离正常文本流，并且覆盖盒模型相关的样式。盒模型紧跟其后，因为他决定了一个组件的大小和位置。 其他属性只在组件内部起作用或者不会对前面两种情况的结果产生影响，所以他们排在后面。 1234567891011121314151617181920212223242526272829.declaration-order &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box-model */ display: block; float: right; width: 100px; height: 100px; /* Typography */ font: normal 13px &quot;Helvetica Neue&quot;, sans-serif; line-height: 1.5; color: #333; text-align: center; /* Visual */ background-color: #f5f5f5; border: 1px solid #e5e5e5; border-radius: 3px; /* Misc */ opacity: 1;&#125; Don’t use @import与&lt;link&gt;相比，@import较慢，增加额外的页面请求，并可能导致其他不可预见的问题。 1234567&lt;!-- Use link elements --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;core.css&quot;&gt;&lt;!-- Avoid @imports --&gt;&lt;style&gt; @import url(&quot;more.css&quot;);&lt;/style&gt; 媒体查询位置尽量将媒体查询的位置靠近他们相关的规则。不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部。这样做只会让大家以后更容易忘记他们。这里是一个典型的案例。 123456789.element &#123; ... &#125;.element-avatar &#123; ... &#125;.element-selected &#123; ... &#125;@media (min-width: 480px) &#123; .element &#123; ...&#125; .element-avatar &#123; ... &#125; .element-selected &#123; ... &#125;&#125; 前缀属性当使用厂商前缀属性时，通过缩进使取值垂直对齐以便多行编辑。 12345/* Prefixed properties */.selector &#123; -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15); box-shadow: 0 1px 2px rgba(0,0,0,.15);&#125; 单条声明的声明块在一个声明块中只包含一条声明的情况下，为了易读性和快速编辑可以考虑移除其中的换行。所有包含多条声明的声明块应该分为多行。 这样做的关键因素是错误检测 - 例如，一个 CSS 验证程序显示你在 183 行有一个语法错误,如果是一个单条声明的行，那就是他了。在多个声明的情况下，你必须为哪里出错了费下脑子。 123.span1 &#123; width: 60px; &#125;.span2 &#123; width: 140px; &#125;.span3 &#123; width: 220px; &#125; 属性简写尽量不使用属性简写的方式，属性简写需要你必须显式设置所有取值。常见的属性简写滥用包括: padding margin font background -border -border-radius 大多数情况下，我们并不需要设置属性简写中包含的所有值。例如，HTML 头部只设置上下的 margin，所以如果需要，只设置这两个值。过度使用属性简写往往会导致更混乱的代码，其中包含不必要的重写和意想不到的副作用。 12345678910111213141516/* Bad example */.element &#123; margin: 0 0 10px; background: red; background: url(&quot;image.jpg&quot;); border-radius: 3px 3px 0 0;&#125;/* Good example */.element &#123; margin-bottom: 10px; background-color: red; background-image: url(&quot;image.jpg&quot;); border-top-left-radius: 3px; border-top-right-radius: 3px;&#125; Less 和 Sass 中的嵌套避免不必要的嵌套。可以进行嵌套，不意味着你应该这样做。只有在需要给父元素增加样式并且同时存在多个子元素时才需要考虑嵌套。 123456789// Without nesting.table &gt; thead &gt; tr &gt; th &#123; … &#125;.table &gt; thead &gt; tr &gt; td &#123; … &#125;// With nesting.table &gt; thead &gt; tr &#123; &gt; th &#123; … &#125; &gt; td &#123; … &#125;&#125; 代码注释代码是由人来编写和维护的。保证你的代码是描述性的，包含好的注释，并且容易被他人理解。好的代码注释传达上下文和目标。不要简单地重申组件或者 class 名称。 class 命名保持 class 命名为全小写，可以使用短划线（不要使用下划线和 camelCase 命名）。短划线应该作为相关类的自然间断。(例如，.btn 和 .btn-danger)。 避免过度使用简写。.btn 可以很好地描述 button，但是 .s 不能代表任何元素。 class 的命名应该尽量短，也要尽量明确。 使用有意义的名称；使用结构化或者作用目标相关，而不是抽象的名称。 命名时使用最近的父节点或者父 class 作为前缀。 使用 .js-* 来表示行为(相对于样式)，但是不要在 CSS 中包含这些 class。 选择器使用 class 而不是通用元素标签来优化渲染性能。 避免在经常出现的组件中使用一些属性选择器 (例如，[class^=&quot;...&quot;])。浏览器性能会受到这些情况的影响。 减少选择器的长度，每个组合选择器选择器的条目应该尽量控制在 3 个以内。 只在必要的情况下使用后代选择器 (例如，没有使用带前缀 classes 的情况). 代码组织以组件为单位组织代码。 制定一个一致的注释层级结构。 使用一致的空白来分割代码块，这样做在查看大的文档时更有优势。 当使用多个 CSS 文件时，通过组件而不是页面来区分他们。页面会被重新排列，而组件移动就可以了。 编辑器配置根据以下的设置来配置你的编辑器，将这些设置应用到项目的 .editorconfig 文件，来避免常见的代码不一致和丑陋的 diffs。 使用四个空格的缩进。 在保存时删除尾部的空白字符。 设置文件编码为 UTF-8。 在文件结尾添加一个空白行。 JS 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 声明之后一律以分号结束， 不可以省略 完全避免 == != 的使用， 用严格比较条件 === !== eval 非特殊情况， 禁用！！！ with 非特殊情况， 禁用！！！ 单行长度，理论上不要超过80列，不过如果编辑器开启”自动换行”的话可以不考虑单行长度 接上一条，如果需要换行，存在操作符的情况，一定在操作符后换行，然后换的行缩进4个空格 这里要注意，如果是多次换行的话就没有必要继续缩进了，比如说下面这种就是最佳格式。 1234567if (typeof qqfind === &quot;undefined&quot; || typeof qqfind.cdnrejected === &quot;undefined&quot; || qqfind.cdnrejected !== true) &#123; url = &quot;http://pub.idqqimg.com/qqfind/js/location4.js&quot;;&#125; else &#123; url = &quot;http://find.qq.com/js/location4.js&quot;;&#125; 空行方法之间加 单行或多行注释前加 逻辑块之间加空行增加可读性 变量命名标准变量采用驼峰标识 使用的ID的地方一定全大写 使用的URL的地方一定全大写, 比如说 reportURL 涉及Android的，一律大写第一个字母 涉及iOS的，一律小写第一个，大写后两个字母 常量采用大写字母，下划线连接的方式 构造函数，大写第一个字母 12345678910111213var thisIsMyName;var goodID;var AndroidVersion;var iOSVersion;var MAX_COUNT = 10;function Person(name) &#123; this.name = name&#125; 字符常量一般情况下统一使用单引号 null的使用场景初始化可能以后分配对象值的变量 与一个可能或可能没有对象值的初始化变量进行比较 传入一个预期对象的函数 从预期对象的函数返回 不适合null的使用场景不要使用null来测试是否提供参数 不要测试值为null的未初始化变量 undefined使用场景永远不要直接使用undefined进行变量判断 使用字符串 &quot;undefined&quot; 对变量进行判断 123456// Badvar person;console.log(person === undefined); //true// Goodconsole.log(typeof person); // &quot;undefined&quot; 对象字面量12345678910// Badvar team = new Team();team.title = &quot;AlloyTeam&quot;;team.count = 25;// Goodvar team = &#123; title: &quot;AlloyTeam&quot;, count: 25&#125;; 数组声明12345678// Badvar colors = new Array(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;);var numbers = new Array(1, 2, 3, 4);// Goodvar colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];var numbers = [ 1, 2, 3, 4 ]; 单行注释双斜线后，必须跟注释内容保留一个空格 与下一行代码缩进保持一致 可位于一个代码行的末尾，双斜线距离分号四个空格 1234567// Goodif (condition) &#123; // if you made it here, then all security checks passed allowed();&#125;var zhangsan = &quot;zhangsan&quot;; // 双斜线距离分号四个空格，双斜线后始终保留一个空格 多行注释格式最少三行 前边留空一行 123/** * 注释内容与星标前保留一个空格 */ 何时使用多行注释格式难于理解的代码段 可能存在错误的代码段 浏览器特殊的HACK代码 业务逻辑强相关的代码 想吐槽的产品逻辑, 合作同事 文档注释各类标签 @param @method 等 参考 http://usejsdoc.org/ 用于：方法、构造函数、对象 123456/** * here boy, look here , here is girl * @method lookGril * @param &#123;Object&#125; balabalabala * @return &#123;Object&#125; balabalabala */ 括号对齐标准示例 括号前后有空格，花括号起始不另换行，结尾新起一行 花括号必须要，即使内容只有一行 涉及 if for while do...while try...catch...finally 的地方都必须使用花括号，即使内容只有一行 if else 前后留有空格12345if (condition) &#123; doSomething();&#125; else &#123; doSomethingElse();&#125; switchswitch和括号之间有空格，case需要缩进，break之后跟下一个case中间留一个空白行 花括号必须要， 即使内容只有一行。 switch 的 falling through 一定要有注释特别说明，no default 的情况也需要注释特别说明况 123456789101112switch (condition) &#123; case &quot;first&quot;: // code break; case &quot;second&quot;: // code break; default: // code&#125; for普通for循环, 分号后留有一个空格， 判断条件等内的操作符两边不留空格 前置条件如果有多个，逗号后留一个空格 for-in 一定要有 hasOwnProperty 的判断， 否则 JSLint 或者 JSHint 都会有一个 warn 1234567891011121314for (i=0, len=values.length; i&lt;len; i++) &#123; process(values[i]);&#125;var prop;for (prop in object) &#123; // 注意这里一定要有 hasOwnProperty 的判断， 否则 JSLint 或者 JSHint 都会有一个 warn ！ if (object.hasOwnProperty(prop)) &#123; console.log(&quot;Property name is &quot; + prop); console.log(&quot;Property value is &quot; + object[prop]); &#125;&#125; 变量声明所有函数内变量声明放在函数内头部，只使用一个 var(多了JSLint报错)， 一个变量一行， 在行末跟注释， 注释啊，注释啊，亲 函数声明一定先声明再使用， 不要利用 JavaScript engine的变量提升特性, 违反了这个规则 JSLint 和 JSHint都会报 warn function declaration 和 function expression 的不同，function expression 的（）前后必须有空格，而function declaration 在有函数名的时候不需要空格，没有函数名的时候需要空格。 函数调用括号前后不需要空格 立即执行函数的写法, 最外层必须包一层括号 &quot;use strict&quot; 决不允许全局使用， 必须放在函数的第一行， 可以用自执行函数包含大的代码段, 如果 &quot;use strict&quot; 在函数外使用， JSLint 和 JSHint 均会报错 1234567891011121314151617181920212223function doSomething(item) &#123; // do something&#125;var doSomething = function (item) &#123; // do something&#125;// GooddoSomething(item);// Bad: Looks like a block statementdoSomething (item);// Good(function() &#123; &quot;use strict&quot;; function doSomething() &#123; // code &#125;&#125;)(); 结尾规范当然不是我写的啦，哈哈哈哈~ 原文是：https://github.com/bxm0927/web-code-standards]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>代码</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode快捷键]]></title>
    <url>%2F2018%2F12%2F12%2Fvscode%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[如标题所说的，vscode的快捷键。中英文对照。 常用 General 按 Press 功能 Function Ctrl + Shift + P，F1 显示命令面板 Show Command Palette Ctrl + P 快速打开 Quick Open Ctrl + Shift + N 新窗口/实例 New window/instance Ctrl + Shift + W 关闭窗口/实例 Close window/instance 基础编辑 Basic editing 按 Press 功能 Function Ctrl+X 剪切行（空选定） Cut line (empty selection) Ctrl+C 复制行（空选定）Copy line (empty selection) Alt+ ↑ / ↓ 向上/向下移动行 Move line up/down Shift+Alt + ↓ / ↑ 向上/向下复制行 Copy line up/down Ctrl+Shift+K 删除行 Delete line Ctrl+Enter 在下面插入行 Insert line below Ctrl+Shift+Enter 在上面插入行 Insert line above Ctrl+Shift+\ 跳到匹配的括号 Jump to matching bracket Ctrl+] / [ 缩进/缩进行 Indent/outdent line Home 转到行首 Go to beginning of line End 转到行尾 Go to end of line Ctrl+Home 转到文件开头 Go to beginning of file Ctrl+End 转到文件末尾 Go to end of file Ctrl+↑ / ↓ 向上/向下滚动行 Scroll line up/down Alt+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Shift+[ 折叠（折叠）区域 Fold (collapse) region Ctrl+Shift+] 展开（未折叠）区域 Unfold (uncollapse) region Ctrl+K Ctrl+[ 折叠（未折叠）所有子区域 Fold (collapse) all subregions Ctrl+K Ctrl+] 展开（未折叠）所有子区域 Unfold (uncollapse) all subregions Ctrl+K Ctrl+0 折叠（折叠）所有区域 Fold (collapse) all regions Ctrl+K Ctrl+J 展开（未折叠）所有区域 Unfold (uncollapse) all regions Ctrl+K Ctrl+C 添加行注释 Add line comment Ctrl+K Ctrl+U 删除行注释 Remove line comment Ctrl+/ 切换行注释 Toggle line comment Shift+Alt+A 切换块注释 Toggle block comment Alt+Z 切换换行 Toggle word wrap 导航 Navigation 按 Press 功能 Function Ctrl + T 显示所有符号 Show all Symbols Ctrl + G 转到行… Go to Line… Ctrl + P 转到文件… Go to File… Ctrl + Shift + O 转到符号… Go to Symbol… Ctrl + Shift + M 显示问题面板 Show Problems panel F8 转到下一个错误或警告 Go to next error or warning Shift + F8 转到上一个错误或警告 Go to previous error or warning Ctrl + Shift + Tab 导航编辑器组历史记录 Navigate editor group history Alt + ←/→ 返回/前进 Go back / forward Ctrl + M 切换选项卡移动焦点 Toggle Tab moves focus 搜索和替换 Search and replace 按 Press 功能 Function Ctrl + F 查找 Find Ctrl + H 替换 Replace F3 / Shift + F3 查找下一个/上一个 Find next/previous Alt + Enter 选择查找匹配的所有出现 Select all occurences of Find match Ctrl + D 将选择添加到下一个查找匹配 Add selection to next Find match Ctrl + K Ctrl + D 将最后一个选择移至下一个查找匹配项 Move last selection to next Find match Alt + C / R / W 切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word 多光标和选择 Multi-cursor and selection 按 Press 功能 Function Alt +单击 插入光标 Insert cursor Ctrl + Alt +↑/↓ 在上/下插入光标 Insert cursor above / below Ctrl + U 撤消上一个光标操作 Undo last cursor operation Shift + Alt + I 在选定的每一行的末尾插入光标 Insert cursor at end of each line selected Ctrl + I 选择当前行 Select current line Ctrl + Shift + L 选择当前选择的所有出现 Select all occurrences of current selection Ctrl + F2 选择当前字的所有出现 Select all occurrences of current word Shift + Alt + → 展开选择 Expand selection Shift + Alt + ← 缩小选择 Shrink selection Shift + Alt + （拖动鼠标） 列（框）选择 Column (box) selection Ctrl + Shift + Alt +（箭头键） 列（框）选择 Column (box) selection Ctrl + Shift + Alt + PgUp / PgDown 列（框）选择页上/下 Column (box) selection page up/down 丰富的语言编辑 Rich languages editing 按 Press 功能 Function Ctrl + 空格 触发建议 Trigger suggestion Ctrl + Shift + Space 触发器参数提示 Trigger parameter hints Tab Emmet展开缩写 Emmet expand abbreviation Shift + Alt + F 格式化文档 Format document Ctrl + K Ctrl + F 格式选定区域 Format selection F12 转到定义 Go to Definition Alt + F12 Peek定义 Peek Definition Ctrl + K F12 打开定义到边 Open Definition to the side Ctrl + . 快速解决 Quick Fix Shift + F12 显示引用 Show References F2 重命名符号 Rename Symbol Ctrl + K Ctrl + X 修剪尾随空格 Trim trailing whitespace Ctrl + K M 更改文件语言 Change file language 编辑器管理 Editor management 按 Press 功能 Function Ctrl+F4, Ctrl+W 关闭编辑器 Close editor Ctrl+K F 关闭文件夹 Close folder Ctrl+\ 拆分编辑器 Split editor Ctrl+ 1 / 2 / 3 聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group Ctrl+K Ctrl+ ←/→ 聚焦到上一个/下一个编辑器组 Focus into previous/next editor group Ctrl+Shift+PgUp / PgDown 向左/向右移动编辑器 Move editor left/right Ctrl+K ← / → 移动活动编辑器组 Move active editor group 文件管理 File management 按 Press 功能 Function Ctrl+N 新文件 New File Ctrl+O 打开文件… Open File… Ctrl+S 保存 Save Ctrl+Shift+S 另存为… Save As… Ctrl+K S 全部保存 Save All Ctrl+F4 关闭 Close Ctrl+K Ctrl+W 关闭所有 Close All Ctrl+Shift+T 重新打开关闭的编辑器 Reopen closed editor Ctrl+K 输入保持打开 Enter Keep Open Ctrl+Tab 打开下一个 Open next Ctrl+Shift+Tab 打开上一个 Open previous Ctrl+K P 复制活动文件的路径 Copy path of active file Ctrl+K R 显示资源管理器中的活动文件 Reveal active file in Explorer Ctrl+K O 显示新窗口/实例中的活动文件 Show active file in new window/instance 显示 Display 按 Press 功能 Function F11 切换全屏 Toggle full screen Shift+Alt+1 切换编辑器布局 Toggle editor layout Ctrl+ = / - 放大/缩小 Zoom in/out Ctrl+B 切换侧栏可见性 Toggle Sidebar visibility Ctrl+Shift+E 显示浏览器/切换焦点 Show Explorer / Toggle focus Ctrl+Shift+F 显示搜索 Show Search Ctrl+Shift+G 显示Git Show Git Ctrl+Shift+D 显示调试 Show Debug Ctrl+Shift+X 显示扩展 Show Extensions Ctrl+Shift+H 替换文件 Replace in files Ctrl+Shift+J 切换搜索详细信息 Toggle Search details Ctrl+Shift+C 打开新命令提示符/终端 Open new command prompt/terminal Ctrl+Shift+U 显示输出面板 Show Output panel Ctrl+Shift+V 切换Markdown预览 Toggle Markdown preview Ctrl+K V 从旁边打开Markdown预览 Open Markdown preview to the side 调试 Debug 按 Press 功能 Function F9 切换断点 Toggle breakpoint F5 开始/继续 Start/Continue Shift+F5 停止 Stop F11 / Shift+F11 下一步/上一步 Step into/out F10 跳过 Step over Ctrl+K Ctrl+I 显示悬停 Show hover 集成终端 Integrated terminal 按 Press 功能 Function Ctrl+` 显示集成终端 Show integrated terminal Ctrl+Shift+` 创建新终端 Create new terminal Ctrl+Shift+C 复制选定 Copy selection Ctrl+Shift+V 粘贴到活动端子 Paste into active terminal Ctrl+↑ / ↓ 向上/向下滚动 Scroll up/down Shift+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Home / End 滚动到顶部/底部 Scroll to top/bottom 结尾原文是：https://segmentfault.com/a/1190000007688656]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode插件]]></title>
    <url>%2F2018%2F12%2F11%2Fvscode%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Visual Studio Code（以下简称vscode）是一个轻量且强大的代码编辑器，支持Windows，OS X和Linux。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。 插件推荐 插件 说明 ComputerAuto Close Tag 自动添加HTML / XML关闭标签 Auto Rename Tag 自动重命名配对的HTML / XML标签 Beautify 格式化代码 Bracket Pair Colorizer 颜色识别匹配括号 Code Runner 能够运行多种语言的代码片段或代码文件 Chinese (Simplified) Language Pack for Visual Studio Code 中文简体包 Color Info 为你提供你在 CSS 中使用颜色的相关信息。 CSS Peek 可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码 Debugger for Chrome 前端调试, 查看使用方法 ESLint EsLint可以帮助我们检查Javascript编程时的语法错误。 filesize 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间 Git History 以图表的形式查看 git 日志 GitLens — Git supercharged 显示文件最近的 commit 和作者，显示当前行 commit 信息 HTML Boilerplate 通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构 HTMLHint HTML 代码格式检测 HTML Snippets 代码自动填充 htmltagwrap 在选中HTML标签中外面套一层标签”Alt + W” (“Option + W” for Mac) Image Preview 鼠标移到路径里显示图像预览 Indenticator 突出目前的缩进深度 intelliSense for CSS class names in HTML 把项目中 css 文件里的名称智能提示在 html 中 JavaScript (ES6) code snippets es6代码片段 Live Server 浏览器实时刷新 Node.js Modules Intellisense 可以在导入语句中自动完成JavaScript / TypeScript模块 npm Intellisense require 时的包提示 Path Intellisense 路径自动补全 Quokka.js Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈使用方法: ctrl+shift+p 输入quokka选择 new javascript 就可以了 Regex Previewer 这是一个用于实时测试正则表达式的实用工具。它可以将正则表达式模式应用在任何打开的文件上，并高亮所有的匹配项 SVG Viewer 此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项 Vetur Vue 语法高亮显示, 语法错误检查, 代码自动补全(配合 ESLint 插件效果更佳) vscode-fileheader 顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间快捷键: Ctrl+Alt+i(默认信息可在 文件→首选项→设置 中修改) 结尾写这篇文章主要是想偷个懒，以后安装插件不用去查，之后会继续更新新的插件当作仓库。 原文是：https://blog.csdn.net/shenxianhui1995/article/details/81604818]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生的Ajax]]></title>
    <url>%2F2018%2F12%2F11%2F%E5%8E%9F%E7%94%9F%E7%9A%84ajax%2F</url>
    <content type="text"><![CDATA[Ajax = 异步JavaScript和xml。Ajax是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必需重载整个网页面。 创建XMLHttpRequest对象XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 1let xhr = new XMLHttpRequest(); 向服务器发送请求请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： 12xhr.open(method,url,async) xhr.send(string) method: string，请求的类型；GET 或 POSTurl: string,文件在服务器上的位置async: Boolean，true（异步）或 false（同步)string: string,仅用于 POST 请求,将请求发送到服务器。 服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 12responseText // 获得字符串形式的响应数据responseXML // 获得 XML 形式的响应数据 onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件readyState 属性存有 XMLHttpRequest 的状态信息。 onreadystatechange: 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState: 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status: 200: “OK”,404: 未找到页面 实例 123456xhr.onreadystatechange=function()&#123; if (xhr.readyState==4 &amp;&amp; xhr.status==200) &#123; document.getElementById(&quot;div&quot;).innerHTML=xhr.responseText; &#125;&#125; 完整版使用回调函数回调函数是一种以参数形式传递给另一个函数的函数。 如果您的网站上存在多个 Ajax 任务，那么您应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 Ajax 任务调用该函数。 该函数调用应该包含 URL 以及发生 onreadystatechange 事件时执行的任务（每次调用可能不尽相同): 12345678910111213function loadXMLDoc (url, cfunc) &#123; let xhr = new XMLHttpRequest(); xhr.onreadystatechange = cfunc; xhr.open(&quot;GET&quot;,url,true); xhr.send();&#125;function myFunction () &#123; loadXMLDoc(&quot;ajax.txt&quot;, function () &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; document.getElementById(&quot;div&quot;).innerHTML = xhr.responseText; &#125; )&#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的常用命令]]></title>
    <url>%2F2018%2F12%2F11%2Fgit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 工作流程 克隆 Git 资源作为工作目录。在克隆的资源上添加或修改文件。如果其他人修改了，你可以更新资源。在提交前查看修改。提交修改。在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 创建仓库git initgit init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 git clonegit clone 从现有 Git 仓库中拷贝项目 1git clone &lt;repo&gt; &lt;directory&gt; repo: Git仓库directory: 本地目录。 基本操作git add将想要快照的内容写入缓存区 使用 git add . 命令来添加当前项目的所有文件。 git status以查看在你上次提交之后是否有修改。 加 -s 参数，以获得简短的结果输出。 git diff查看执行 git status 的结果的详细信息。 尚未缓存的改动：git diff查看已缓存的改动： git diff --cached查看已缓存的与未缓存的所有改动：git diff HEAD显示摘要而非整个 diff：git diff --stat git commit将缓存区内容添加到仓库中。 如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。 1git commit -a git reset HEAD用于取消已缓存的内容。 git rm从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。 1git rm &lt;file&gt; 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f 1git rm -f &lt;file&gt; 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除， 1git rm --cached &lt;file&gt; git mvgit mv 命令用于移动或重命名一个文件、目录、软连接。 git分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 创建分支命令： 1git branch (branchname) 切换分支命令: 1git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 合并分支命令: 1git merge 列出分支基本命令： 1git branch 删除分支命令： 1git branch -d (branchname) Git 查看提交历史使用 git log 命令查看 用 --oneline 选项来查看历史记录的简洁的版本。 1git log --oneline 用 --graph 选项，查看历史中什么时候出现了分支、合并。 1git log --oneline --graph 用 --reverse参数来逆向显示所有日志。 1git log --reverse --oneline 如果只想查找指定用户的提交日志可以使用命令：git log --author 1git log --author=Linus --oneline -5 Git 标签如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 1git tag -a v1.0 Git 远程仓库(Github)添加远程库12git remote add [shortname] [url]git remote add origin https:// 查看当前的远程库12git remotegit remote -v 提取远程仓库从远程仓库下载新分支与数据： 1git fetch 从远端仓库提取数据并尝试合并到当前分支： 1git merge 推送到远程仓库12git push [alias] [branch]git push -u origin master -u: 第一次提交时用，之后不需要origin: 远程仓库 删除远程仓库1git remote rm [别名]]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next主题优化]]></title>
    <url>%2F2018%2F12%2F10%2Fhexo-next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[hexo官方提供的主题实在是不怎么美观，所以开发人员就制作了第三方主题，当然主题有很多，而今天我说的next主题。关于hexo的搭建可以去官方文档，很全面，按步骤走一遍基本就会用了。 next主题的配置设置主题风格打开 themes/next/_config.yml 文件，搜索 Schemes 关键字，将你需用启用的 scheme 前面注释 # 去除即可。 12345# Schemes# scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 设置菜单项的显示文本和图标设置菜单项的显示中文文本打开 themes/next/languages/zh-Hans.yml 文件,搜索 menu 关键字，修改对应中文或者新增。 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于我 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 设定菜单项的文件目录和对应图标打开 themes/next/_config.yml 文件，搜索 menu_icons 关键字，修改对应图标名称或者新增对应 menu 的图标。 12345678910111213menu: 首页: / || home 标签: /tags/ || tags 分类: /categories/ || th 归档: /archives/ || archive 关于我: /about/ || user # schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap # commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 除了 home， archives , /后面都需要手动创建这个页面 创建菜单项对应文件目录,以分类为例使用 hexo new page 新建一个页面(不知道hexo命令可以去官方文档看)，命名为 categories ： 1$ hexo new page categories 编辑刚新建的页面,设置分类 12345---title: 分类date: 2018-12-10 14:05:23type: &quot;categories&quot;--- 头像设置添加头像打开 themes/next/_config.yml 文件，搜索 Sidebar Avatar 关键字，去掉 avatar 前面的#,把图片放入 themes/next/source/images 下,修改 avatar： 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /uploads/avatar.png 设置头像边框为圆形框打开位于 themes/next/source/css/_common/components/sidebar/sidebar-author.syl 文件,修改如下: 123456789101112.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; // 修改头像边框 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%;&#125; 特效：鼠标放置头像上旋转123456789101112131415161718192021.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; // 修改头像边框 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; // 设置旋转 transition: 1.4s all;&#125;// 可旋转的圆形头像,`hover`动作.site-author-image:hover &#123; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125; 浏览页面的时候显示当前浏览进度打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true。 12# Scroll percent label in b2t button.scrollpercent: true 侧边栏设置设置侧边栏社交链接打开 themes/next/_config.yml 文件,搜索关键字 social ,然后添加社交站点名称与地址即可。 123456789101112social: GitHub: https://github.com/zhengshikun || github E-Mail: mailto:646537311@qq.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 微博: https://weibo.com/u/3922341463?topnav=1&amp;wvr=6&amp;topsug=1 || weibo RSS在你 Hexo 站点目录下： 1$ npm install hexo-generator-feed --save 打开 Hexo 站点下的 _config.yml ,添加如下配置： 12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml limit: 20 hub: content: 友情链接打开 themes/next/_config.yml 文件,搜索关键字 Blog rolls： 12345678# Blog rollslinks_icon: linklinks_title: 友情连接#links_layout: blocklinks_layout: inlinelinks: #Title: http://example.com/ 百度: https://baidu.com/ 底部建站时间和图标修改打开 themes/next/_config.yml 文件,搜索关键字footer: 12345678910111213141516171819footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2018 # Icon between year and copyright info. icon: snowflake-o # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). # version: true 把用户的图标从小人user改成了雪花snowflake-o copyright留空，显示成页面author即我的名字 powered: false把hexo的授权图片取消了 theme: enable:false 把主题的内容也取消了 主页文章添加边框阴影效果打开 themes/next/source/css/_custom/custom.styl ,向里面加代码: 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 开启版权声明主题配置文件下,搜索关键字 post_copyright , enable 改为 true： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 本地搜索在你站点的根目录下 1$ npm install hexo-generator-searchdb --save 打开 Hexo 站点的 _config.yml,添加配置 12345search: path: search.xml field: post format: html limit: 10000 打开 themes/next/_config.yml ,搜索关键字 local_search ,设置为 true： 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 统计功能,显示文章字数统计,阅读时长,总字数1$ npm i --save hexo-wordcount 打开 themes/next/_config.yml ，搜索关键字 post_wordcount： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 修改文章内文本连接样式打开 themes/next/source/css/_custom/custom.styl,添加代码： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #999; border-bottom: none; border-bottom: 1px solid #999; &amp;:hover &#123; color: #666; border-bottom: none; border-bottom: 1px solid #666; &#125;&#125; 本地站点推送到GitHub上在站点更目录下： 1$ npm install hexo-deployer-git --save 在 Hexo 站点的 _config.yml 中配置 deploy： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; #your github.io.git branch: master 1$ hexo clean 1$ hexo d --g 详情参考官方文档 添加网易云音乐在网易云音乐（网页版）中搜索我们想要插入的音乐，然后点击生成外链播放器,然后根据你得设置生成相应的html代码，将获得的html代码插入到你想要插入的位置。 我放在了侧边栏，在 themes/next/layout/_custom/sidebar.swig 文件中增加生成的HTML代码： 123&lt;div id=&quot;music163player&quot;&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=27583241&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 结尾放我npm安装的一些插件 1234567891011121314151617&quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.7.0&quot;, &quot;hexo-asset-image&quot;: &quot;0.0.3&quot;, &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-cname&quot;: &quot;^0.3.0&quot;, &quot;hexo-generator-feed&quot;: &quot;^1.2.2&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-server&quot;: &quot;^0.3.1&quot;, &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的第一篇文章 - markdown语法]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[你好哇！这是我的第一篇文章，当你看到这里的时候就代表我成功运行啦！庆祝~关于第一篇也没啥说的，我下面就测试markdown常用的语法吧 Markdown简介Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯和亚伦·斯沃茨。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档”。 ——维基百科 Markdown语法标题123456# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt;## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt;#### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt;##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt;###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt; 这是四级标题 内容强调加粗、斜体123字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示 字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示 删除线1这样来 ~~删除一段文本~~ 删除一段文本 高亮12使用&lt;code&gt;\`&lt;/code&gt;来强调字符 // 想打出 ` (反引号)需要转义的比如`突出背景色`来显示强调效果 使用`来强调字符比如突出背景色来显示强调效果 引用显示1234&gt; 每行开始都使用 &apos;&gt;&apos;；&gt; 引用**开始**；&gt; 引用**换行**；&gt; 引用**结束**。 每行开始都使用 ‘&gt;’；引用开始；引用换行；引用结束。 表格12345列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 可以使用冒号来定义对齐方式： 1234| 左对齐 | 右对齐 | 居中 || :-------- | -------:| :--: || Computer | 5000 元 | 1台 || Phone | 1999 元 | 1部 | 左对齐 右对齐 居中 Computer 5000 元 1台 Phone 1999 元 1部 代码块代码块语法遵循标准 markdown 代码，使用三个`开始,三个`结束 123``` 这里是内容``` 链接插入12[首页](https://zhengshikun.site)[关于我](/about/) 首页关于我 图片插入1![我的头像](/博客的第一篇文章/avatar.png) 列表无序列表123* 列表展示+ 列表展示- 列表展示 列表展示 列表展示 列表展示 有序列表121. **我是一级序列** 1. *我是二级序列* 我是一级序列 我是二级序列 链接自动检测12首页:https://zhengshikun.site我的信息:https://zhengshikun.site/about/ 首页:https://zhengshikun.site我的信息:https://zhengshikun.site/about/]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
