<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue-可复用性and组合]]></title>
    <url>%2F2019%2F01%2F13%2Fvue-%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7and%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 混入基础混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。 123456789101112131415161718// 定义一个混入对象var myMixin = &#123; created: function () &#123; this.hello() &#125;, methods: &#123; hello: function () &#123; console.log(&apos;hello from mixin!&apos;) &#125; &#125;&#125;// 定义一个使用混入对象的组件var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() // =&gt; &quot;hello from mixin!&quot; 选项合并数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。 12345678910111213141516171819202122var mixin = &#123; data: function () &#123; return &#123; message: &apos;hello&apos;, foo: &apos;abc&apos; &#125; &#125;&#125;new Vue(&#123; mixins: [mixin], data: function () &#123; return &#123; message: &apos;goodbye&apos;, bar: &apos;def&apos; &#125; &#125;, created: function () &#123; console.log(this.$data) // =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125; &#125;&#125;) 全局混入一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。 1234567891011121314// 为自定义的选项 &apos;myOption&apos; 注入一个处理器。Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: &apos;hello!&apos;&#125;)// =&gt; &quot;hello!&quot; 自定义选项合并策略自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 Vue.config.optionMergeStrategies 添加一个函数： 123Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) &#123; // return mergedVal&#125; 自定义指令简介除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 12345678// 注册一个全局自定义指令 `v-focus`Vue.directive(&apos;focus&apos;, &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 如果想注册局部指令，组件中也接受一个 directives 的选项： 12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 然后你可以在模板中任何元素上使用新的 v-focus 属性，如下： 1&lt;input v-focus&gt; 钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数参数 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 函数简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写: 123Vue.directive(&apos;color-swatch&apos;, function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。 1&lt;div v-demo=&quot;&#123; color: &apos;white&apos;, text: &apos;hello!&apos; &#125;&quot;&gt;&lt;/div&gt; 1234Vue.directive(&apos;demo&apos;, function (el, binding) &#123; console.log(binding.value.color) // =&gt; &quot;white&quot; console.log(binding.value.text) // =&gt; &quot;hello!&quot;&#125;) 渲染函数 &amp; JSX基础Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这时你可以用 render 函数，它比 template 更接近编译器。 12345&lt;h1&gt; &lt;a name=&quot;hello-world&quot; href=&quot;#hello-world&quot;&gt; Hello world! &lt;/a&gt;&lt;/h1&gt; 节点、树以及虚拟 DOM1&lt;h1&gt;&#123;&#123; blogTitle &#125;&#125;&lt;/h1&gt; 123render: function (createElement) &#123; return createElement(&apos;h1&apos;, this.blogTitle)&#125; 在这两种情况下，Vue 都会自动保持页面的更新，即便 blogTitle 发生了改变。 createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为“虚拟节点 (Virtual Node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。 createElement 参数接下来你需要熟悉的是如何在 createElement 函数中生成模板。这里是 createElement 接受的参数： 123456789101112131415161718192021222324252627// @returns &#123;VNode&#125;createElement( // &#123;String | Object | Function&#125; // 一个 HTML 标签字符串，组件选项对象，或者 // 解析上述任何一种的一个 async 异步函数。必需参数。 &apos;div&apos;, // &#123;Object&#125; // 一个包含模板相关属性的数据对象 // 你可以在 template 中使用这些特性。可选参数。 &#123; // (详情见下一节) &#125;, // &#123;String | Array&#125; // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [ &apos;先写一些文字&apos;, createElement(&apos;h1&apos;, &apos;一则头条&apos;), createElement(MyComponent, &#123; props: &#123; someProp: &apos;foobar&apos; &#125; &#125;) ]) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123; // 和`v-bind:class`一样的 API // 接收一个字符串、对象或字符串和对象组成的数组 &apos;class&apos;: &#123; foo: true, bar: false &#125;, // 和`v-bind:style`一样的 API // 接收一个字符串、对象或对象组成的数组 style: &#123; color: &apos;red&apos;, fontSize: &apos;14px&apos; &#125;, // 普通的 HTML 特性 attrs: &#123; id: &apos;foo&apos; &#125;, // 组件 props props: &#123; myProp: &apos;bar&apos; &#125;, // DOM 属性 domProps: &#123; innerHTML: &apos;baz&apos; &#125;, // 事件监听器基于 `on` // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ &#123; name: &apos;my-custom-directive&apos;, value: &apos;2&apos;, expression: &apos;1 + 1&apos;, arg: &apos;foo&apos;, modifiers: &#123; bar: true &#125; &#125; ], // 作用域插槽格式 // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement(&apos;span&apos;, props.text) &#125;, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: &apos;name-of-slot&apos;, // 其他特殊顶层属性 key: &apos;myKey&apos;, ref: &apos;myRef&apos;, // 如果你在渲染函数中向多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true&#125; 有了这些知识，我们现在可以完成我们最开始想实现的组件： 1234567891011121314151617181920212223242526272829303132333435var getChildrenTextContent = function (children) &#123; return children.map(function (node) &#123; return node.children ? getChildrenTextContent(node.children) : node.text &#125;).join(&apos;&apos;)&#125;Vue.component(&apos;anchored-heading&apos;, &#123; render: function (createElement) &#123; // 创建 kebab-case 风格的ID var headingId = getChildrenTextContent(this.$slots.default) .toLowerCase() .replace(/\W+/g, &apos;-&apos;) .replace(/(^\-|\-$)/g, &apos;&apos;) return createElement( &apos;h&apos; + this.level, [ createElement(&apos;a&apos;, &#123; attrs: &#123; name: headingId, href: &apos;#&apos; + headingId &#125; &#125;, this.$slots.default) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 使用 JavaScript 代替模板功能1234&lt;ul v-if=&quot;items.length&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No items found.&lt;/p&gt; 这些都会在 render 函数中被 JavaScript 的 if/else 和 map 重写： 12345678910props: [&apos;items&apos;],render: function (createElement) &#123; if (this.items.length) &#123; return createElement(&apos;ul&apos;, this.items.map(function (item) &#123; return createElement(&apos;li&apos;, item.name) &#125;)) &#125; else &#123; return createElement(&apos;p&apos;, &apos;No items found.&apos;) &#125;&#125; 插件使用插件通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成： 123456// 调用 `MyPlugin.install(Vue)`Vue.use(MyPlugin)new Vue(&#123; //... options&#125;) 也可以传入一个选项对象： 1Vue.use(MyPlugin, &#123; someOption: true &#125;) Vue.use 会自动阻止多次注册相同插件，届时只会注册一次该插件。 Vue.js 官方提供的一些插件 (例如 vue-router) 在检测到 Vue 是可访问的全局变量时会自动调用 Vue.use()。然而在例如 CommonJS 的模块环境中，你应该始终显式地调用 Vue.use()： 123456// 用 Browserify 或 webpack 提供的 CommonJS 模块环境时var Vue = require(&apos;vue&apos;)var VueRouter = require(&apos;vue-router&apos;)// 不要忘了调用此方法Vue.use(VueRouter) 开发插件Vue.js 的插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive(&apos;my-directive&apos;, &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; 过滤器Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式) (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示： 12345&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 你可以在一个组件的选项中定义本地的过滤器： 1234567filters: &#123; capitalize: function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125; 1234567891011Vue.filter(&apos;capitalize&apos;, function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;)或者在创建 Vue 实例之前全局定义过滤器：new Vue(&#123; // ...&#125;) 过滤器可以串联： 1&#123;&#123; message | filterA | filterB &#125;&#125; 过滤器是 JavaScript 函数，因此可以接收参数： 1&#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-过渡and动画]]></title>
    <url>%2F2019%2F01%2F12%2Fvue-%E8%BF%87%E6%B8%A1and%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 进入/离开 &amp; 列表过渡单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 12345678&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: &apos;#demo&apos;, data: &#123; show: true &#125;&#125;) 123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0;&#125; 过渡的类名在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 CSS 过渡12345678&lt;div id=&quot;example-1&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;slide-fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; show: true &#125;&#125;) 12345678910111213/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to/* .slide-fade-leave-active for below version 2.1.8 */ &#123; transform: translateX(10px); opacity: 0;&#125; 自定义过渡的类名我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。 1234567891011121314&lt;link href=&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; show: true &#125;&#125;) JavaScript 钩子可以在属性中声明 JavaScript 钩子 12345678910111213&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 状态过渡Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，比如： 数字和运算 颜色的显示 SVG 节点的位置 元素的大小和其他的属性 所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。 状态动画与侦听器123456script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.3/TweenMax.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;animated-number-demo&quot;&gt; &lt;input v-model.number=&quot;number&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; &lt;p&gt;&#123;&#123; animatedNumber &#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011121314151617new Vue(&#123; el: &apos;#animated-number-demo&apos;, data: &#123; number: 0, tweenedNumber: 0 &#125;, computed: &#123; animatedNumber: function() &#123; return this.tweenedNumber.toFixed(0); &#125; &#125;, watch: &#123; number: function(newValue) &#123; TweenLite.to(this.$data, 0.5, &#123; tweenedNumber: newValue &#125;); &#125; &#125;&#125;) 动态状态过渡就像 Vue 的过渡组件一样，数据背后状态过渡会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可实现很多难以想象的效果。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-深入了解组件]]></title>
    <url>%2F2019%2F01%2F10%2Fvue-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 组件注册组件名在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了： 1Vue.component(&apos;my-component-name&apos;, &#123; /* ... */ &#125;) 全局注册12345Vue.component(&apos;component-a&apos;, &#123; /* ... */ &#125;)Vue.component(&apos;component-b&apos;, &#123; /* ... */ &#125;)Vue.component(&apos;component-c&apos;, &#123; /* ... */ &#125;)new Vue(&#123; el: &apos;#app&apos; &#125;) 12345&lt;div id=&quot;app&quot;&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;component-b&gt;&lt;/component-b&gt; &lt;component-c&gt;&lt;/component-c&gt;&lt;/div&gt; 局部注册通过一个普通的 JavaScript 对象来定义组件： 123var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123; /* ... */ &#125;var ComponentC = &#123; /* ... */ &#125; 然后在 components 选项中定义你想要使用的组件： 1234567new Vue(&#123; el: &apos;#app&apos;, components: &#123; &apos;component-a&apos;: ComponentA, &apos;component-b&apos;: ComponentB &#125;&#125;) 模块系统如果你还在阅读，说明你使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。在一个假设的 ComponentB.js 或 ComponentB.vue 文件中： 12345678910import ComponentA from &apos;./ComponentA&apos;import ComponentC from &apos;./ComponentC&apos;export default &#123; components: &#123; ComponentA, ComponentC &#125;, // ...&#125; PropProp 的大小写 (camelCase vs kebab-case)HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名： 12345Vue.component(&apos;blog-post&apos;, &#123; // 在 JavaScript 中是 camelCase 的 props: [&apos;postTitle&apos;], template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;&#125;) 12&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt; Prop 类型我们只看到了以字符串数组形式列出的 prop： 1props: [&apos;title&apos;, &apos;likes&apos;, &apos;isPublished&apos;, &apos;commentIds&apos;, &apos;author&apos;] 通常你希望每个 prop 都有指定的值类型。 1234567props: &#123; title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object&#125; 传递静态或动态 Prop像这样给 prop 传入一个静态的值： 1&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt; 可以通过 v-bind 动态赋值，例如： 12345&lt;!-- 动态赋予一个变量的值 --&gt;&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;&lt;!-- 动态赋予一个复杂表达式的值 --&gt;&lt;blog-post v-bind:title=&quot;post.title + &apos; by &apos; + post.author.name&quot;&gt;&lt;/blog-post&gt; 单向数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 Prop 验证为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如： 123456789101112131415161718192021222324252627282930313233Vue.component(&apos;my-component&apos;, &#123; props: &#123; // 基础的类型检查 (`null` 匹配任何类型) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: &apos;hello&apos; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) 自定义事件事件名不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。因此，我们推荐你始终使用 kebab-case 的事件名。 自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突： 12345678910111213141516Vue.component(&apos;base-checkbox&apos;, &#123; model: &#123; prop: &apos;checked&apos;, event: &apos;change&apos; &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&apos;change&apos;, $event.target.checked)&quot; &gt; `&#125;) 现在在这个组件上使用 v-model 的时候： 1&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt; 将原生事件绑定到组件Vue 提供了一个 $listeners 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如： 1234&#123; focus: function (event) &#123; /* ... */ &#125; input: function (value) &#123; /* ... */ &#125;,&#125; 有了这个 $listeners 属性，你就可以配合 v-on=&quot;$listeners&quot; 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 &lt;input&gt; 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的： 1234567891011121314151617181920212223242526272829303132Vue.component(&apos;base-input&apos;, &#123; inheritAttrs: false, props: [&apos;label&apos;, &apos;value&apos;], computed: &#123; inputListeners: function () &#123; var vm = this // `Object.assign` 将所有的对象合并为一个新对象 return Object.assign(&#123;&#125;, // 我们从父级添加所有的监听器 this.$listeners, // 然后我们添加自定义监听器， // 或覆写一些监听器的行为 &#123; // 这里确保组件配合 `v-model` 的工作 input: function (event) &#123; vm.$emit(&apos;input&apos;, event.target.value) &#125; &#125; ) &#125; &#125;, template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=&quot;$attrs&quot; v-bind:value=&quot;value&quot; v-on=&quot;inputListeners&quot; &gt; &lt;/label&gt; `&#125;) 插槽插槽内容它允许你像这样合成组件： 123&lt;navigation-link url=&quot;/profile&quot;&gt; Your Profile&lt;/navigation-link&gt; 然后你在 &lt;navigation-link&gt; 的模板中可能会写为： 123456&lt;a v-bind:href=&quot;url&quot; class=&quot;nav-link&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/a&gt; 当组件渲染的时候，这个 &lt;slot&gt; 元素将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML： 12345&lt;navigation-link url=&quot;/profile&quot;&gt; &lt;!-- 添加一个 Font Awesome 图标 --&gt; &lt;span class=&quot;fa fa-user&quot;&gt;&lt;/span&gt; Your Profile&lt;/navigation-link&gt; 具名插槽有些时候我们需要多个插槽。例如，一个假设的 &lt;base-layout&gt; 组件的模板如下： 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;!-- 我们希望把页头放这里 --&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 我们希望把主要内容放这里 --&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 我们希望把页脚放这里 --&gt; &lt;/footer&gt;&lt;/div&gt; 对于这样的情况，&lt;slot&gt; 元素有一个特殊的特性：name。这个特性可以用来定义额外的插槽： 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 在向具名插槽提供内容的时候，我们可以在一个父组件的 &lt;template&gt; 元素上使用 slot 特性： 123456789101112&lt;base-layout&gt; &lt;template slot=&quot;header&quot;&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template slot=&quot;footer&quot;&gt; &lt;p&gt;Here&apos;s some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 另一种 slot 特性的用法是直接用在一个普通的元素上： 12345678&lt;base-layout&gt; &lt;h1 slot=&quot;header&quot;&gt;Here might be a page title&lt;/h1&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;p slot=&quot;footer&quot;&gt;Here&apos;s some contact info&lt;/p&gt;&lt;/base-layout&gt; 我们还是可以保留一个未命名插槽，这个插槽是默认插槽，也就是说它会作为所有未匹配到插槽的内容的统一出口。上述两个示例渲染出来的 HTML 都将会是： 123456789101112&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;Here&apos;s some contact info&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 插槽的默认内容你可以在组件模板里的 &lt;slot&gt; 标签内部指定默认的内容来做到这一点。 123&lt;button type=&quot;submit&quot;&gt; &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt; 如果父组件为这个插槽提供了内容，则默认的内容会被替换掉。 编译作用域父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。 作用域插槽12345678910111213&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot; v-bind:key=&quot;todo.id&quot; &gt; &lt;!-- 我们为每个 todo 准备了一个插槽，--&gt; &lt;!-- 将 `todo` 对象作为一个插槽的 prop 传入。--&gt; &lt;slot v-bind:todo=&quot;todo&quot;&gt; &lt;!-- 回退的内容 --&gt; &#123;&#123; todo.text &#125;&#125; &lt;/slot&gt; &lt;/li&gt;&lt;/ul&gt; 现在当我们使用 &lt;todo-list&gt; 组件的时候，我们可以选择为待办项定义一个不一样的 &lt;template&gt; 作为替代方案，并且可以通过 slot-scope 特性从子组件获取数据： 123456789&lt;todo-list v-bind:todos=&quot;todos&quot;&gt; &lt;!-- 将 `slotProps` 定义为插槽作用域的名字 --&gt; &lt;template slot-scope=&quot;slotProps&quot;&gt; &lt;!-- 为待办项自定义一个模板，--&gt; &lt;!-- 通过 `slotProps` 定制每个待办项。--&gt; &lt;span v-if=&quot;slotProps.todo.isComplete&quot;&gt;✓&lt;/span&gt; &#123;&#123; slotProps.todo.text &#125;&#125; &lt;/template&gt;&lt;/todo-list&gt; 动态组件 &amp; 异步组件在动态组件上使用 keep-alive能够被在它们第一次被创建的时候缓存下来。&lt;keep-alive&gt; 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部/全局注册。 异步组件12345Vue.component( &apos;async-webpack-example&apos;, // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import(&apos;./my-async-component&apos;)) 当使用局部注册的时候，你也可以直接提供一个返回 Promise 的函数： 123456new Vue(&#123; // ... components: &#123; &apos;my-component&apos;: () =&gt; import(&apos;./my-async-component&apos;) &#125;&#125;)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-基础知识]]></title>
    <url>%2F2019%2F01%2F05%2Fvue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 模板语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。 在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。 插值文本数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定： 1&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 原始 HTML双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令： 12&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; 特性Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令： 1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 在布尔特性的情况下，它们的存在即暗示为 true，v-bind 工作起来略有不同，在这个例子中： 1&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; 如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的 &lt;button&gt; 元素中。 使用 JavaScript 表达式迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt; 指令指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 1&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt; 这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 &lt;p&gt; 元素。 参数一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML 特性： 1&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt; 另一个例子是 v-on 指令，它用于监听 DOM 事件： 1&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt; 修饰符修饰符 (Modifiers) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; 缩写v-bind 缩写12345&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt; v-on 缩写12345!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt; 计算属性和侦听器计算属性1234&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 侦听器虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 1234567&lt;div id=&quot;watch-example&quot;&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=&quot;question&quot;&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: &apos;#watch-example&apos;, data: &#123; question: &apos;&apos;, answer: &apos;I cannot give you an answer until you ask a question!&apos; &#125;, watch: &#123; // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) &#123; this.answer = &apos;Waiting for you to stop typing...&apos; this.debouncedGetAnswer() &#125; &#125;, created: function () &#123; // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于 // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识， // 请参考：https://lodash.com/docs#debounce this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) &#125;, methods: &#123; getAnswer: function () &#123; if (this.question.indexOf(&apos;?&apos;) === -1) &#123; this.answer = &apos;Questions usually contain a question mark. ;-)&apos; return &#125; this.answer = &apos;Thinking...&apos; var vm = this axios.get(&apos;https://yesno.wtf/api&apos;) .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = &apos;Error! Could not reach the API. &apos; + error &#125;) &#125; &#125;&#125;)&lt;/script&gt; Class 与 Style 绑定绑定 HTML Class对象语法我们可以传给 v-bind:class 一个对象，以动态地切换 class： 1&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt; 绑定的数据对象不必内联定义在模板里： 1&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; 123456data: &#123; classObject: &#123; active: true, &apos;text-danger&apos;: false &#125;&#125; 我们也可以在这里绑定一个返回对象的计算属性。这是一个常用且强大的模式： 1&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; 123456789101112data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos; &#125; &#125;&#125; 数组语法我们可以把一个数组传给 v-bind:class，以应用一个 class 列表： 1&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt; 1234data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; 渲染为： 1&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 如果你也想根据条件切换列表中的 class，可以用三元表达式： 1&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt; 用在组件上例如，如果你声明了这个组件： 123Vue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&apos;&#125;) 绑定内联样式对象语法v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： 1&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125; 数组语法v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 自动添加前缀当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 多重值从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如： 1&lt;div :style=&quot;&#123; display: [&apos;-webkit-box&apos;, &apos;-ms-flexbox&apos;, &apos;flex&apos;] &#125;&quot;&gt;&lt;/div&gt; 条件渲染v-if在 &lt;template&gt; 元素上使用 v-if 条件渲染分组12345&lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else123456&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don&apos;t&lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-else-ifv-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 用 key 管理可复用的元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可： 12345678&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt; v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： 1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 v-if vs v-show一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 列表渲染用 v-for 把一个数组对应为一组元素我们用 v-for 指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名。 12345&lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125;&#125;) 一个对象的 v-for你也可以用 v-for 通过一个对象的属性来迭代。 12345&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt; &lt;li v-for=&quot;value in object&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910new Vue(&#123; el: &apos;#v-for-object&apos;, data: &#123; object: &#123; firstName: &apos;John&apos;, lastName: &apos;Doe&apos;, age: 30 &#125; &#125;&#125;) 你也可以提供第二个的参数为键名： 123&lt;div v-for=&quot;(value, key) in object&quot;&gt; &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 第三个参数为索引： 123&lt;div v-for=&quot;(value, key, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; key123&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 事件处理监听事件可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。 1234&lt;div id=&quot;example-1&quot;&gt; &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt; &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;&lt;/div&gt; 123456var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; counter: 0 &#125;&#125;) 事件处理方法然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。 1234&lt;div id=&quot;example-2&quot;&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617181920var example2 = new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; name: &apos;Vue.js&apos; &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function (event) &#123; // `this` 在方法里指向当前 Vue 实例 alert(&apos;Hello &apos; + this.name + &apos;!&apos;) // `event` 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)// 也可以用 JavaScript 直接调用方法example2.greet() // =&gt; &apos;Hello Vue.js!&apos; 内联处理器中的方法除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法： 1234&lt;div id=&quot;example-3&quot;&gt; &lt;button v-on:click=&quot;say(&apos;hi&apos;)&quot;&gt;Say hi&lt;/button&gt; &lt;button v-on:click=&quot;say(&apos;what&apos;)&quot;&gt;Say what&lt;/button&gt;&lt;/div&gt; 12345678new Vue(&#123; el: &apos;#example-3&apos;, methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;) 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive 12345678910111213141516171819&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 按键修饰符在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13=&quot;submit&quot;&gt; 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： 12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 系统修饰键12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=&quot;clear&quot;&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; 表单输入绑定基础用法文本12&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 多行文本1234&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt; 复选框12345678910&lt;div id=&apos;example-3&apos;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; checkedNames: [] &#125;&#125;) 单选按钮123456789&lt;div id=&quot;example-4&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: &apos;#example-4&apos;, data: &#123; picked: &apos;&apos; &#125;&#125;) 选择框123456789&lt;div id=&quot;example-5&quot;&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: &apos;...&apos;, data: &#123; selected: &apos;&apos; &#125;&#125;) 值绑定对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)： 12345678910&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt;&lt;!-- `toggle` 为 true 或 false --&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt;&lt;!-- 当选中第一个选项时，`selected` 为字符串 &quot;abc&quot; --&gt;&lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt;&lt;/select&gt; 修饰符.lazy在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步： 12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt; .number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符： 1&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; .trim如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符： 1&lt;input v-model.trim=&quot;msg&quot;&gt; 组件基础基本示例这里有一个 Vue 组件的示例： 123456789// 定义一个名为 button-counter 的新组件Vue.component(&apos;button-counter&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: &apos;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&apos;&#125;) 123&lt;div id=&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 组件的复用12345&lt;div id=&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 组件的组织例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。 为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。至此，我们的组件都只是通过 Vue.component 全局注册的： 123Vue.component(&apos;my-component-name&apos;, &#123; // ... options ...&#125;) 通过 Prop 向子组件传递数据1234Vue.component(&apos;blog-post&apos;, &#123; props: [&apos;title&apos;], template: &apos;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&apos;&#125;) 123&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;&lt;blog-post title=&quot;Why Vue is so fun&quot;&gt;&lt;/blog-post&gt; 然而在一个典型的应用中，你可能在 data 里有一个博文的数组： 12345678910new Vue(&#123; el: &apos;#blog-post-demo&apos;, data: &#123; posts: [ &#123; id: 1, title: &apos;My journey with Vue&apos; &#125;, &#123; id: 2, title: &apos;Blogging with Vue&apos; &#125;, &#123; id: 3, title: &apos;Why Vue is so fun&apos; &#125; ] &#125;&#125;) 并想要为每篇博文渲染一个组件： 12345&lt;blog-post v-for=&quot;post in posts&quot; v-bind:key=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt; 单个根元素是时候重构一下这个 &lt;blog-post&gt; 组件了，让它变成接受一个单独的 post prop： 12345&lt;blog-post v-for=&quot;post in posts&quot; v-bind:key=&quot;post.id&quot; v-bind:post=&quot;post&quot;&gt;&lt;/blog-post&gt; 123456789Vue.component(&apos;blog-post&apos;, &#123; props: [&apos;post&apos;], template: ` &lt;div class=&quot;blog-post&quot;&gt; &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt; &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt; &lt;/div&gt; `&#125;) 通过事件向父级组件发送消息我们可以用 v-on 在博文组件上监听这个事件，就像监听一个原生 DOM 事件一样： 1234&lt;blog-post ... v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&gt;&lt;/blog-post&gt; 通过插槽分发内容12345678Vue.component(&apos;alert-box&apos;, &#123; template: ` &lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;) 动态组件12&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>框架</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-编程风格]]></title>
    <url>%2F2019%2F01%2F03%2Fes6-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的编程风格。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 块级作用域let 取代 varES6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 123456789&apos;use strict&apos;;if (true) &#123; let x = &apos;hello&apos;;&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; var命令存在变量提升效用，let命令没有这个问题 123456&apos;use strict&apos;;if (true) &#123; console.log(x); // ReferenceError let x = &apos;hello&apos;;&#125; 全局常量和线程安全在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 12345678910// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 12345678910// badconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// acceptableconst c = `foobar`;// goodconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`; 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 1234567891011121314// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 12345678910111213// badconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;, [getKey(&apos;enabled&apos;)]: true,&#125;; 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 1234567891011121314151617181920212223var ref = &apos;some value&apos;;// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组使用扩展运算符（…）拷贝数组。 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用 Array.from 方法，将类似数组的对象转为数组。 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 函数立即执行函数可以写成箭头函数的形式。 123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。 123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。 1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。 123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map 结构注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。 12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; Class总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。 123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 模块首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。 1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 使用export取代module.exports。 123456789101112131415161718192021// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 12345// badimport * as myObject from &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。 1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。 123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; ESLint 的使用ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装 ESLint。 1$ npm i -g eslint 然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。 12$ npm i -g eslint-config-airbnb$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react 最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。 123&#123; &quot;extends&quot;: &quot;eslint-config-airbnb&quot;&#125; 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下。 12345678var unusued = &apos;I have no purpose!&apos;;function greet() &#123; var message = &apos;Hello, World!&apos;; alert(message);&#125;greet(); 使用 ESLint 检查这个文件，就会报出错误。 123456789$ eslint index.jsindex.js 1:1 error Unexpected var, use let or const instead no-var 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 4:5 error Unexpected var, use let or const instead no-var 5:5 error Expected indentation of 2 characters but found 4 indent✖ 5 problems (5 errors, 0 warnings) 上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Module的语法]]></title>
    <url>%2F2019%2F01%2F01%2Fes6-Module%E7%9A%84%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Module的语法。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 概述在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);// 等同于let _fs = require(&apos;fs&apos;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 12// ES6模块import &#123; stat, exists, readFile &#125; from &apos;fs&apos;; 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 export 命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。 123456// profile.jsvar firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;export &#123;firstName, lastName, year&#125;; export命令除了输出变量，还可以输出函数或类（class）。 123export function multiply(x, y) &#123; return x * y;&#125;; 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 12345678function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; import 命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 123456// main.jsimport &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;;function setName(element) &#123; element.textContent = firstName + &apos; &apos; + lastName;&#125; 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 1import &#123; lastName as surname &#125; from &apos;./profile.js&apos;; import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。 123import &#123;a&#125; from &apos;./xxx.js&apos;a = &#123;&#125;; // Syntax Error : &apos;a&apos; is read-only; 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 下面是一个circle.js文件，它输出两个方法area和circumference。 123456789// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125; 现在，加载这个模块。 123456// main.jsimport &#123; area, circumference &#125; from &apos;./circle&apos;;console.log(&apos;圆面积：&apos; + area(4));console.log(&apos;圆周长：&apos; + circumference(14)); 上面写法是逐一指定要加载的方法，整体加载的写法如下。 1234import * as circle from &apos;./circle&apos;;console.log(&apos;圆面积：&apos; + circle.area(4));console.log(&apos;圆周长：&apos; + circle.circumference(14)); 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。 12345import * as circle from &apos;./circle&apos;;// 下面两行都是不允许的circle.foo = &apos;hello&apos;;circle.area = function () &#123;&#125;; export default 命令从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 1234// export-default.jsexport default function () &#123; console.log(&apos;foo&apos;);&#125; 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 123// import-default.jsimport customName from &apos;./export-default&apos;;customName(); // &apos;foo&apos; 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。 export default命令用在非匿名函数前，也是可以的。加载的时候，视同匿名函数加载。 有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。 1import _ from &apos;lodash&apos;; 如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。 1import _, &#123; each, forEach &#125; from &apos;lodash&apos;; 对应上面代码的export语句如下。 123456789export default function (obj) &#123; // ···&#125;export function each(obj, iterator, context) &#123; // ···&#125;export &#123; each as forEach &#125;; export default也可以用来输出类。 123456// MyClass.jsexport default class &#123; ... &#125;// main.jsimport MyClass from &apos;MyClass&apos;;let o = new MyClass(); export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 12345export &#123; foo, bar &#125; from &apos;my_module&apos;;// 可以简单理解为import &#123; foo, bar &#125; from &apos;my_module&apos;;export &#123; foo, bar &#125;; 模块的接口改名和整体输出，也可以采用这种写法。 12345// 接口改名export &#123; foo as myFoo &#125; from &apos;my_module&apos;;// 整体输出export * from &apos;my_module&apos;; 模块的继承模块之间也可以继承。 假设有一个circleplus模块，继承了circle模块。 1234567// circleplus.jsexport * from &apos;circle&apos;;export var e = 2.71828182846;export default function(x) &#123; return Math.exp(x);&#125; 上面代码中的export ，表示再输出circle模块的所有属性和方法。注意，export 命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。 这时，也可以将circle的属性或方法，改名后再输出。 123// circleplus.jsexport &#123; area as circleArea &#125; from &apos;circle&apos;; 上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。 加载上面模块的写法如下。 12345// main.jsimport * as math from &apos;circleplus&apos;;import exp from &apos;circleplus&apos;;console.log(exp(math.e)); 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。 跨模块常量本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。 1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from &apos;./constants&apos;;console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from &apos;./constants&apos;;console.log(A); // 1console.log(B); // 3 123456789// constants/db.jsexport const db = &#123; url: &apos;http://my.couchdbserver.local:5984&apos;, admin_username: &apos;admin&apos;, admin_password: &apos;admin password&apos;&#125;;// constants/user.jsexport const users = [&apos;root&apos;, &apos;admin&apos;, &apos;staff&apos;, &apos;ceo&apos;, &apos;chief&apos;, &apos;moderator&apos;]; 123// constants/index.jsexport &#123;db&#125; from &apos;./db&apos;;export &#123;users&#125; from &apos;./users&apos;; 12// script.jsimport &#123;db, users&#125; from &apos;./constants/index&apos;; import()简介前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。 1234// 报错if (x === 2) &#123; import MyModual from &apos;./myModual&apos;;&#125; 因此，有一个提案，建议引入import()函数，完成动态加载。 1import(specifier) 适用场合按需加载import()可以在需要的时候，再加载某个模块。 123456789button.addEventListener(&apos;click&apos;, event =&gt; &#123; import(&apos;./dialogBox.js&apos;) .then(dialogBox =&gt; &#123; dialogBox.open(); &#125;) .catch(error =&gt; &#123; /* Error handling */ &#125;)&#125;); 条件加载import()可以放在if代码块，根据不同的情况，加载不同的模块。 12345if (condition) &#123; import(&apos;moduleA&apos;).then(...);&#125; else &#123; import(&apos;moduleB&apos;).then(...);&#125; 动态的模块路径import()允许模块路径动态生成。 12import(f()).then(...); 注意点import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。 1234import(&apos;./myModule.js&apos;).then((&#123;export1, export2&#125;) =&gt; &#123; // ...·&#125;);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-修饰器]]></title>
    <url>%2F2018%2F12%2F30%2Fes6-%E4%BF%AE%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的修饰器。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 类的修饰许多面向对象的语言都有修饰器（Decorator）函数，用来修改类的行为。目前，有一个提案将这项功能，引入了 ECMAScript。 12345678910@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; target.isTestable = true;&#125;MyTestableClass.isTestable // true 基本上，修饰器的行为就是下面这样。 1234567@decoratorclass A &#123;&#125;// 等同于class A &#123;&#125;A = decorator(A) || A; 方法的修饰修饰器不仅可以修饰类，还可以修饰类的属性。 1234class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125; 修饰器函数readonly一共可以接受三个参数。 123456789101112131415function readonly(target, name, descriptor)&#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, &apos;name&apos;, descriptor);// 类似于Object.defineProperty(Person.prototype, &apos;name&apos;, descriptor); 为什么修饰器不能用于函数？修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。 123456789var counter = 0;var add = function () &#123; counter++;&#125;;@addfunction foo() &#123;&#125; 上面的代码，意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样。 123456789101112@addfunction foo() &#123;&#125;var counter;var add;counter = 0;add = function () &#123; counter++;&#125;; core-decorators.jscore-decorators.js是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。 @autobindautobind修饰器使得方法中的this对象，绑定原始对象。 1234567891011121314import &#123; autobind &#125; from &apos;core-decorators&apos;;class Person &#123; @autobind getPerson() &#123; return this; &#125;&#125;let person = new Person();let getPerson = person.getPerson;getPerson() === person;// true @readonlyreadonly修饰器使得属性或方法不可写。 12345678910import &#123; readonly &#125; from &apos;core-decorators&apos;;class Meal &#123; @readonly entree = &apos;steak&apos;;&#125;var dinner = new Meal();dinner.entree = &apos;salmon&apos;;// Cannot assign to read only property &apos;entree&apos; of [object Object] @overrideoverride修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。 123456789101112131415161718192021import &#123; override &#125; from &apos;core-decorators&apos;;class Parent &#123; speak(first, second) &#123;&#125;&#125;class Child extends Parent &#123; @override speak() &#123;&#125; // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)&#125;// orclass Child extends Parent &#123; @override speaks() &#123;&#125; // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain. // // Did you mean &quot;speak&quot;?&#125; @deprecate (别名@deprecated)deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。 1234567891011121314151617181920212223242526import &#123; deprecate &#125; from &apos;core-decorators&apos;;class Person &#123; @deprecate facepalm() &#123;&#125; @deprecate(&apos;We stopped facepalming&apos;) facepalmHard() &#123;&#125; @deprecate(&apos;We stopped facepalming&apos;, &#123; url: &apos;http://knowyourmeme.com/memes/facepalm&apos; &#125;) facepalmHarder() &#123;&#125;&#125;let person = new Person();person.facepalm();// DEPRECATION Person#facepalm: This function will be removed in future versions.person.facepalmHard();// DEPRECATION Person#facepalmHard: We stopped facepalmingperson.facepalmHarder();// DEPRECATION Person#facepalmHarder: We stopped facepalming//// See http://knowyourmeme.com/memes/facepalm for more details.// @suppressWarningssuppressWarnings修饰器抑制deprecated修饰器导致的console.warn()调用。但是，异步代码发出的调用除外。 12345678910111213141516import &#123; suppressWarnings &#125; from &apos;core-decorators&apos;;class Person &#123; @deprecated facepalm() &#123;&#125; @suppressWarnings facepalmWithoutWarning() &#123; this.facepalm(); &#125;&#125;let person = new Person();person.facepalmWithoutWarning();// no warning is logged 使用修饰器实现自动发布事件我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。 1234567891011121314151617181920const postal = require(&quot;postal/lib/postal.lodash&quot;);export default function publish(topic, channel) &#123; const channelName = channel || &apos;/&apos;; const msgChannel = postal.channel(channelName); msgChannel.subscribe(topic, v =&gt; &#123; console.log(&apos;频道: &apos;, channelName); console.log(&apos;事件: &apos;, topic); console.log(&apos;数据: &apos;, v); &#125;); return function(target, name, descriptor) &#123; const fn = descriptor.value; descriptor.value = function() &#123; let value = fn.apply(this, arguments); msgChannel.publish(topic, value); &#125;; &#125;;&#125; 它的用法如下。 123456789101112131415161718// index.jsimport publish from &apos;./publish&apos;;class FooComponent &#123; @publish(&apos;foo.some.message&apos;, &apos;component&apos;) someMethod() &#123; return &#123; my: &apos;data&apos; &#125;; &#125; @publish(&apos;foo.some.other&apos;) anotherMethod() &#123; // ... &#125;&#125;let foo = new FooComponent();foo.someMethod();foo.anotherMethod(); 以后，只要调用someMethod或者anotherMethod，就会自动发出一个事件。 12345678$ bash-node index.js频道: component事件: foo.some.message数据: &#123; my: &apos;data&apos; &#125;频道: /事件: foo.some.other数据: undefined Mixin在修饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。 12345678910const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;class MyClass &#123;&#125;Object.assign(MyClass.prototype, Foo);let obj = new MyClass();obj.foo() // &apos;foo&apos; TraitTrait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。 下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。 12345678910111213141516import &#123; traits &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;&#125;;@traits(TFoo, TBar)class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // fooobj.bar() // bar Babel 转码器的支持目前，Babel 转码器已经支持 Decorator。 首先，安装babel-core和babel-plugin-transform-decorators。由于后者包括在babel-preset-stage-0之中，所以改为安装babel-preset-stage-0亦可。 1$ npm install babel-core babel-plugin-transform-decorators 然后，设置配置文件.babelrc。 123&#123; &quot;plugins&quot;: [&quot;transform-decorators&quot;]&#125; 脚本中打开的命令如下。 1babel.transform(&quot;code&quot;, &#123;plugins: [&quot;transform-decorators&quot;]&#125;)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Class的继承]]></title>
    <url>%2F2018%2F12%2F27%2Fes6-Class%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Class的继承。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 简介Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 12345class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + &apos; &apos; + super.toString(); // 调用父类的toString() &#125;&#125; Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。 12Object.getPrototypeOf(ColorPoint) === Point// true super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B(); 类的 prototype 属性和__proto__属性大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 子类的__proto__属性，表示构造函数的继承，总是指向父类。 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 实例的 __proto__ 属性子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。 12345var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, &apos;red&apos;);p2.__proto__ === p1.__proto__ // falsep2.__proto__.__proto__ === p1.__proto__ // true 上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。 12345p2.__proto__.__proto__.printName = function () &#123; console.log(&apos;Ha&apos;);&#125;;p1.printName() // &quot;Ha&quot; 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() Mixin 模式的实现Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。 1234567const a = &#123; a: &apos;a&apos;&#125;;const b = &#123; b: &apos;b&apos;&#125;;const c = &#123;...a, ...b&#125;; // &#123;a: &apos;a&apos;, b: &apos;b&apos;&#125; 上面代码中，c对象是a对象和b对象的合成，具有两者的接口。 下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。 12345678910111213141516171819202122function mix(...mixins) &#123; class Mix &#123;&#125; for (let mixin of mixins) &#123; copyProperties(Mix.prototype, mixin); // 拷贝实例属性 copyProperties(Mix.prototype, Reflect.getPrototypeOf(mixin)); // 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot; ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 123class DistributedEdit extends mix(Loggable, Serializable) &#123; // ...&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Class的基本语法]]></title>
    <url>%2F2018%2F12%2F27%2Fes6-Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Class的基本语法。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 简介类的由来JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;&#125;;var p = new Point(1, 2); ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125; 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 12345678class Bar &#123; doStuff() &#123; console.log(&apos;stuff&apos;); &#125;&#125;var b = new Bar();b.doStuff() // &quot;stuff&quot; 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 123456789101112131415161718192021class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; constructor 方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 类的实例生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。 123456789class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &apos;getter&apos;; &#125; set prop(value) &#123; console.log(&apos;setter: &apos;+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// &apos;getter&apos; 属性表达式类的属性名，可以采用表达式。 1234567891011let methodName = &apos;getArea&apos;;class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; Class 表达式与函数一样，类也可以使用表达式的形式定义。 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 1const MyClass = class &#123; /* ... */ &#125;; 采用 Class 表达式，可以写出立即执行的 Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;(&apos;张三&apos;);person.sayName(); // &quot;张三&quot; 注意点严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 不存在提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; name 属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 12class Point &#123;&#125;Point.name // &quot;Point&quot; Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123; console.log(x);&#125;// hello// world this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 12345678910111213class Logger &#123; printName(name = &apos;there&apos;) &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property &apos;print&apos; of undefined 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。 123456789class Logger &#123; constructor() &#123; this.printName = (name = &apos;there&apos;) =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;Foo.classMethod() // &apos;hello&apos;var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 实例属性的新写法实例属性除了在constructor()方法里面定义，也可以直接写在类的最顶层。 123456789101112class IncreasingCounter &#123; constructor() &#123; this._count = 0; &#125; get value() &#123; console.log(&apos;Getting the current value!&apos;); return this._count; &#125; increment() &#123; this._count++; &#125;&#125; 静态属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性法的前面，加上static关键字。 1234567class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myStaticProp); // 42 &#125;&#125; 私有方法和私有属性现有的解决方案私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 1234567891011121314151617const bar = Symbol(&apos;bar&apos;);const snaf = Symbol(&apos;snaf&apos;);export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; 私有属性的提案目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。 1234567891011121314class Foo &#123; #a; #b; constructor(a, b) &#123; this.#a = a; this.#b = b; &#125; #sum() &#123; return #a + #b; &#125; printSum() &#123; console.log(this.#sum()); &#125;&#125; new.target 属性new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;var person = new Person(&apos;张三&apos;); // 正确var notAPerson = Person.call(person, &apos;张三&apos;); // 报错]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-async函数]]></title>
    <url>%2F2018%2F12%2F26%2Fes6-async%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的async函数。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 含义ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 async 函数是什么？一句话，它就是 Generator 函数的语法糖。 前文有一个 Generator 函数，依次读取两个文件。 1234567891011121314151617const fs = require(&apos;fs&apos;);const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile(&apos;/etc/fstab&apos;); const f2 = yield readFile(&apos;/etc/shells&apos;); console.log(f1.toString()); console.log(f2.toString());&#125;; async函数对 Generator 函数的改进，体现在以下四点。 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 1asyncReadFile(); 更好的语义。 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 更广的适用性。 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 返回值是 Promise。 async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 下面是一个例子。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName(&apos;goog&apos;).then(function (result) &#123; console.log(result);&#125;); 语法async函数的语法规则总体上比较简单，难点是错误处理机制。 返回 Promise 对象async函数返回一个 Promise 对象。 async函数内部return语句返回的值，会成为then方法回调函数的参数。 123456async function f() &#123; return &apos;hello world&apos;;&#125;f().then(v =&gt; console.log(v))// &quot;hello world&quot; async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。 123456789async function f() &#123; throw new Error(&apos;出错了&apos;);&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 Promise 对象的状态变化async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 下面是一个例子。 1234567async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];&#125;getTitle(&apos;https://tc39.github.io/ecma262/&apos;).then(console.log)// &quot;ECMAScript 2017 Language Specification&quot; await 命令正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。 12345678async function f() &#123; // 等同于 // return 123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 错误处理如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。 12345678910async function f() &#123; await new Promise(function (resolve, reject) &#123; throw new Error(&apos;出错了&apos;); &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了 防止出错的方法，也是将其放在try...catch代码块之中。 123456789async function f() &#123; try &#123; await new Promise(function (resolve, reject) &#123; throw new Error(&apos;出错了&apos;); &#125;); &#125; catch(e) &#123; &#125; return await(&apos;hello world&apos;);&#125; 如果有多个await命令，可以统一放在try...catch结构中。 123456789101112async function main() &#123; try &#123; const val1 = await firstStep(); const val2 = await secondStep(val1); const val3 = await thirdStep(val1, val2); console.log(&apos;Final: &apos;, val3); &#125; catch (err) &#123; console.error(err); &#125;&#125; 下面的例子使用try...catch结构，实现多次重复尝试。 123456789101112131415const superagent = require(&apos;superagent&apos;);const NUM_RETRIES = 3;async function test() &#123; let i; for (i = 0; i &lt; NUM_RETRIES; ++i) &#123; try &#123; await superagent.get(&apos;http://google.com/this-throws-an-error&apos;); break; &#125; catch(err) &#123;&#125; &#125; console.log(i); // 3&#125;test(); 使用注意点第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。 12345678910111213141516async function myFunction() &#123; try &#123; await somethingThatReturnsAPromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 另一种写法async function myFunction() &#123; await somethingThatReturnsAPromise() .catch(function (err) &#123; console.log(err); &#125;);&#125; 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12let foo = await getFoo();let bar = await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。 12345678// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。 1234567async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; for (let doc of docs) &#123; await db.post(doc); &#125;&#125; 如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。 1234567891011121314151617181920async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results);&#125;// 或者使用下面的写法async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) &#123; results.push(await promise); &#125; console.log(results);&#125; 第四点，async 函数可以保留运行堆栈。 1234const a = async () =&gt; &#123; await b(); c();&#125;; async 函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。 1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; // ... &#125;);&#125; 与其他异步处理方法的比较我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。 假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 首先是 Promise 的写法。 123456789101112131415161718192021222324function chainAnimationsPromise(elem, animations) &#123; // 变量ret用来保存上一个动画的返回值 let ret = null; // 新建一个空的Promise let p = Promise.resolve(); // 使用then方法，添加所有动画 for(let anim of animations) &#123; p = p.then(function(val) &#123; ret = val; return anim(elem); &#125;); &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;);&#125; 接着是 Generator 函数的写法。 123456789101112131415function chainAnimationsGenerator(elem, animations) &#123; return spawn(function*() &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = yield anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret; &#125;);&#125; 最后是 async 函数的写法。 1234567891011async function chainAnimationsAsync(elem, animations) &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; 实例：按顺序完成异步操作实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。 Promise 的写法如下。 123456789101112function logInOrder(urls) &#123; // 远程读取所有URL const textPromises = urls.map(url =&gt; &#123; return fetch(url).then(response =&gt; response.text()); &#125;); // 按次序输出 textPromises.reduce((chain, textPromise) =&gt; &#123; return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); &#125;, Promise.resolve());&#125; 这种写法不太直观，可读性比较差。下面是 async 函数实现。 123456async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; 上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。 123456789101112async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 异步遍历器异步遍历的接口异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 Promise 对象。 12345asyncIterator .next() .then( (&#123; value, done &#125;) =&gt; /* ... */ ); 下面是一个异步遍历器的例子。 12345678910111213141516const asyncIterable = createAsyncIterable([&apos;a&apos;, &apos;b&apos;]);const asyncIterator = asyncIterable[Symbol.asyncIterator]();asyncIterator.next().then(iterResult1 =&gt; &#123; console.log(iterResult1); // &#123; value: &apos;a&apos;, done: false &#125; return asyncIterator.next();&#125;).then(iterResult2 =&gt; &#123; console.log(iterResult2); // &#123; value: &apos;b&apos;, done: false &#125; return asyncIterator.next();&#125;).then(iterResult3 =&gt; &#123; console.log(iterResult3); // &#123; value: undefined, done: true &#125;&#125;); 另一种用法是一次性调用所有的next方法，然后await最后一步操作。 12345678async function runner() &#123; const writer = openFile(&apos;someFile.txt&apos;); writer.next(&apos;hello&apos;); writer.next(&apos;world&apos;); await writer.return();&#125;runner(); for await…of前面介绍过，for...of循环用于遍历同步的 Iterator 接口。新引入的for await...of循环，则是用于遍历异步的 Iterator 接口。 1234567async function f() &#123; for await (const x of createAsyncIterable([&apos;a&apos;, &apos;b&apos;])) &#123; console.log(x); &#125;&#125;// a// b for await...of循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。 1234567let body = &apos;&apos;;async function f() &#123; for await(const data of req) body += data; const parsed = JSON.parse(body); console.log(&apos;got&apos;, parsed);&#125; 异步 Generator 函数在语法上，异步 Generator 函数就是async函数与 Generator 函数的结合。 123456async function* gen() &#123; yield &apos;hello&apos;;&#125;const genObj = gen();genObj.next().then(x =&gt; console.log(x));// &#123; value: &apos;hello&apos;, done: false &#125; 下面是另一个异步 Generator 函数的例子。 1234567891011async function* readLines(path) &#123; let file = await fileOpen(path); try &#123; while (!file.EOF) &#123; yield await file.readLine(); &#125; &#125; finally &#123; await file.close(); &#125;&#125; yield* 语句yield*语句也可以跟一个异步遍历器。 12345678910async function* gen1() &#123; yield &apos;a&apos;; yield &apos;b&apos;; return 2;&#125;async function* gen2() &#123; // result 最终会等于 2 const result = yield* gen1();&#125; 与同步 Generator 函数一样，for await...of循环会展开yield*。 1234567(async function () &#123; for await (const x of gen2()) &#123; console.log(x); &#125;&#125;)();// a// b]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Generator函数的异步应用]]></title>
    <url>%2F2018%2F12%2F26%2Fes6-Generator%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Generator函数的异步应用。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 传统方法ES6 诞生以前，异步编程的方法，大概有下面四种。 回调函数 事件监听 发布/订阅 Promise 对象 Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。 基本概念异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 回调函数JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是”重新调用”。 读取文件进行处理，是这样写的。 1234fs.readFile(&apos;/etc/passwd&apos;, &apos;utf-8&apos;, function (err, data) &#123; if (err) throw err; console.log(data);&#125;); Promise回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。 12345fs.readFile(fileA, &apos;utf-8&apos;, function (err, data) &#123; fs.readFile(fileB, &apos;utf-8&apos;, function (err, data) &#123; // ... &#125;);&#125;); Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。 123456789101112131415var readFile = require(&apos;fs-readfile-promise&apos;);readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); Generator 函数协程传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 举例来说，读取文件的协程写法如下。 12345function* asyncJob() &#123; // ...其他代码 var f = yield readFile(fileA); // ...其他代码&#125; 协程的 Generator 函数实现Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator 函数的执行方法如下。 12345678function* gen(x) &#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; Generator 函数的数据交换和错误处理Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。 next返回值的 value 属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。 12345678function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 12345678910111213function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw(&apos;出错了&apos;);// 出错了 异步任务的封装下面看看如何使用 Generator 函数，执行一个真实的异步任务。 1234567var fetch = require(&apos;node-fetch&apos;);function* gen()&#123; var url = &apos;https://api.github.com/users/github&apos;; var result = yield fetch(url); console.log(result.bio);&#125; 执行这段代码的方法如下。 12345678var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Generator函数的语法]]></title>
    <url>%2F2018%2F12%2F25%2Fes6-Generator%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Generator函数的语法。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 简介基本概念Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123; yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;;&#125;var hw = helloWorldGenerator(); Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()// &#123; value: &apos;hello&apos;, done: false &#125;hw.next()// &#123; value: &apos;world&apos;, done: false &#125;hw.next()// &#123; value: &apos;ending&apos;, done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。 123456789function* f() &#123; console.log(&apos;执行了！&apos;)&#125;var generator = f();setTimeout(function () &#123; generator.next()&#125;, 2000); 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。 与 Iterator 接口的关系由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] next 方法的参数yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; for…of 循环for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。 12345678910111213function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 下面是一个利用 Generator 函数和for...of循环，实现斐波那契数列的例子。 123456789101112function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; yield curr; [prev, curr] = [curr, prev + curr]; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(&apos;内部捕获&apos;, e); &#125;&#125;;var i = g();i.next();try &#123; i.throw(&apos;a&apos;); i.throw(&apos;b&apos;);&#125; catch (e) &#123; console.log(&apos;外部捕获&apos;, e);&#125;// 内部捕获 a// 外部捕获 b Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;g.next() // &#123; value: undefined, done: true &#125; next()、throw()、return() 的共同点next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。 next()是将yield表达式替换成一个值。 1234567891011const g = function* (x, y) &#123; let result = yield x + y; return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123;value: 3, done: false&#125;gen.next(1); // Object &#123;value: 1, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = 1; throw()是将yield表达式替换成一个throw语句。 123gen.throw(new Error(&apos;出错了&apos;)); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error(&apos;出错了&apos;)); return()是将yield表达式替换成一个return语句。 123gen.return(2); // Object &#123;value: 2, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = return 2; yield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。 12345678910111213141516function* foo() &#123; yield &apos;a&apos;; yield &apos;b&apos;;&#125;function* bar() &#123; yield &apos;x&apos;; foo(); yield &apos;y&apos;;&#125;for (let v of bar())&#123; console.log(v);&#125;// &quot;x&quot;// &quot;y&quot; 这个就需要用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。 123456789101112131415161718192021222324252627282930function* bar() &#123; yield &apos;x&apos;; yield* foo(); yield &apos;y&apos;;&#125;// 等同于function* bar() &#123; yield &apos;x&apos;; yield &apos;a&apos;; yield &apos;b&apos;; yield &apos;y&apos;;&#125;// 等同于function* bar() &#123; yield &apos;x&apos;; for (let v of foo()) &#123; yield v; &#125; yield &apos;y&apos;;&#125;for (let v of bar())&#123; console.log(v);&#125;// &quot;x&quot;// &quot;a&quot;// &quot;b&quot;// &quot;y&quot; 从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。 作为对象属性的 Generator 函数如果一个对象的属性是 Generator 函数，可以简写成下面的形式。 12345let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; 上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。 它的完整形式如下，与上面的写法是等价的。 12345let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;; Generator 函数的thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello = function () &#123; return &apos;hi!&apos;;&#125;;let obj = g();obj instanceof g // trueobj.hello() // &apos;hi!&apos; 上面代码表明，Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。 12345678910111213141516171819function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Iterator和for...of循环]]></title>
    <url>%2F2018%2F12%2F25%2FIterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Iterator和for…of循环。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 Iterator（遍历器）的概念遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。 Iterator 的遍历过程是这样的。 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 下面是一个模拟next方法返回值的例子。 12345678910111213141516var it = makeIterator([&apos;a&apos;, &apos;b&apos;]);it.next() // &#123; value: &quot;a&quot;, done: false &#125;it.next() // &#123; value: &quot;b&quot;, done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。 对于遍历器对象来说，done: false和value: undefined属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式。 12345678910function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++]&#125; : &#123;done: true&#125;; &#125; &#125;;&#125; 默认 Iterator 接口Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环（详见下文）。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。 123456789101112const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;; 原生具备 Iterator 接口的数据结构如下。 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 下面的例子是数组的Symbol.iterator属性。 1234567let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: &apos;a&apos;, done: false &#125;iter.next() // &#123; value: &apos;b&apos;, done: false &#125;iter.next() // &#123; value: &apos;c&apos;, done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 调用 Iterator 接口的场合有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合。 解构赋值对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 1234567let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;);let [x,y] = set;// x=&apos;a&apos;; y=&apos;b&apos;let [first, ...rest] = set;// first=&apos;a&apos;; rest=[&apos;b&apos;,&apos;c&apos;]; 扩展运算符扩展运算符（...）也会调用默认的 Iterator 接口。 12345678// 例一var str = &apos;hello&apos;;[...str] // [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]// 例二let arr = [&apos;b&apos;, &apos;c&apos;];[&apos;a&apos;, ...arr, &apos;d&apos;]// [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] yield*yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 1234567891011121314let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 其他场合由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race() 字符串的 Iterator 接口字符串是一个类似数组的对象，也原生具有 Iterator 接口。 123456789var someString = &quot;hi&quot;;typeof someString[Symbol.iterator]// &quot;function&quot;var iterator = someString[Symbol.iterator]();iterator.next() // &#123; value: &quot;h&quot;, done: false &#125;iterator.next() // &#123; value: &quot;i&quot;, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; Iterator 接口与 Generator 函数Symbol.iterator方法的最简单实现，还是使用下一章要介绍的 Generator 函数。 1234567891011121314151617181920212223let myIterable = &#123; [Symbol.iterator]: function* () &#123; yield 1; yield 2; yield 3; &#125;&#125;[...myIterable] // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; * [Symbol.iterator]() &#123; yield &apos;hello&apos;; yield &apos;world&apos;; &#125;&#125;;for (let x of obj) &#123; console.log(x);&#125;// &quot;hello&quot;// &quot;world&quot; 遍历器对象的 return()，throw()遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。 return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。 123456789101112131415function readLinesSync(file) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; next() &#123; return &#123; done: false &#125;; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125; &#125;; &#125;, &#125;;&#125; 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。下面的两种情况，都会触发执行return方法。 1234567891011// 情况一for (let line of readLinesSync(fileName)) &#123; console.log(line); break;&#125;// 情况二for (let line of readLinesSync(fileName)) &#123; console.log(line); throw new Error();&#125; for…of 循环一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。 for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。 数组数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for...of循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。 123456789101112const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];for(let v of arr) &#123; console.log(v); // red green blue&#125;const obj = &#123;&#125;;obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);for(let v of obj) &#123; console.log(v); // red green blue&#125; for...of循环可以代替数组实例的forEach方法。 123456const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];arr.forEach(function (element, index) &#123; console.log(element); // red green blue console.log(index); // 0 1 2&#125;); JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。 123456789var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];for (let a in arr) &#123; console.log(a); // 0 1 2 3&#125;for (let a of arr) &#123; console.log(a); // a b c d&#125; for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。 12345678910let arr = [3, 5, 7];arr.foo = &apos;hello&apos;;for (let i in arr) &#123; console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;&#125;for (let i of arr) &#123; console.log(i); // &quot;3&quot;, &quot;5&quot;, &quot;7&quot;&#125; Set 和 Map 结构Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环。 123456789101112131415161718var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkitvar es6 = new Map();es6.set(&quot;edition&quot;, 6);es6.set(&quot;committee&quot;, &quot;TC39&quot;);es6.set(&quot;standard&quot;, &quot;ECMA-262&quot;);for (var [name, value] of es6) &#123; console.log(name + &quot;: &quot; + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。 keys() 返回一个遍历器对象，用来遍历所有的键名。 values() 返回一个遍历器对象，用来遍历所有的键值。 这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。 1234567let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, &apos;a&apos;]// [1, &apos;b&apos;]// [2, &apos;c&apos;] 类似数组的对象类似数组的对象包括好几类。下面是for...of循环用于字符串、DOM NodeList 对象、arguments对象的例子。 1234567891011121314151617181920212223// 字符串let str = &quot;hello&quot;;for (let s of str) &#123; console.log(s); // h e l l o&#125;// DOM NodeList对象let paras = document.querySelectorAll(&quot;p&quot;);for (let p of paras) &#123; p.classList.add(&quot;test&quot;);&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs(&apos;a&apos;, &apos;b&apos;);// &apos;a&apos;// &apos;b&apos; 对象对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。 1234567891011121314151617let es6 = &#123; edition: 6, committee: &quot;TC39&quot;, standard: &quot;ECMA-262&quot;&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// TypeError: es6[Symbol.iterator] is not a function 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 123for (var key of Object.keys(someObject)) &#123; console.log(key + &apos;: &apos; + someObject[key]);&#125; 另一个方法是使用 Generator 函数将对象重新包装一下。 123456789101112function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, &apos;-&gt;&apos;, value);&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 与其他遍历语法的比较以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环。 123for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125; 这种写法比较麻烦，因此数组提供内置的forEach方法。 123myArray.forEach(function (value) &#123; console.log(value);&#125;); for...in循环可以遍历数组的键名。 123for (var index in myArray) &#123; console.log(myArray[index]);&#125; for...in循环有几个缺点。 数组的键名是数字，但是for...in循环是以字符串作为键名“0”、“1”、“2”等等。 for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for...in循环会以任意顺序遍历键名。 for...of循环相比上面几种做法，有一些显著的优点。 123for (let value of myArray) &#123; console.log(value);&#125; 有着同for...in一样的简洁语法，但是没有for...in那些缺点。 不同于forEach方法，它可以与break、continue和return配合使用。 提供了遍历所有数据结构的统一操作接口。 下面是一个使用 break 语句，跳出for...of循环的例子。 12345for (var n of fibonacci) &#123; if (n &gt; 1000) break; console.log(n);&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Promise对象]]></title>
    <url>%2F2018%2F12%2F23%2Fes6-Promise%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Promise对象。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 Promise 的含义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 下面是一个Promise对象的简单例子。 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, &apos;done&apos;); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); Promise 新建后就会立即执行。 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log(&apos;Promise&apos;); resolve();&#125;);promise.then(function() &#123; console.log(&apos;resolved.&apos;);&#125;);console.log(&apos;Hi!&apos;);// Promise// Hi!// resolved 下面是异步加载图片的例子。 123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error(&apos;Could not load image at &apos; + url)); &#125;; image.src = url; &#125;);&#125; 下面是一个用Promise对象实现的 Ajax 操作的例子。 1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(&quot;GET&quot;, url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); client.send(); &#125;); return promise;&#125;;getJSON(&quot;/posts.json&quot;).then(function(json) &#123; console.log(&apos;Contents: &apos; + json);&#125;, function(error) &#123; console.error(&apos;出错了&apos;, error);&#125;); Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(&quot;/posts.json&quot;).then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 123456getJSON(&quot;/post/1.json&quot;).then( post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log(&quot;resolved: &quot;, comments), err =&gt; console.log(&quot;rejected: &quot;, err)); Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON(&apos;/posts.json&apos;).then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&apos;发生错误！&apos;, error);&#125;); 下面是一个例子。 1234567const promise = new Promise(function(resolve, reject) &#123; throw new Error(&apos;test&apos;);&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test 上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 12345678910111213141516171819// 写法一const promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error(&apos;test&apos;); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二const promise = new Promise(function(resolve, reject) &#123; reject(new Error(&apos;test&apos;));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); Promise.prototype.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); 下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。 12345server.listen(port) .then(function () &#123; // ... &#125;) .finally(server.stop); Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。 12345678910// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); Promise.race()Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。 12345678910const p = Promise.race([ fetch(&apos;/resource-that-may-take-a-while&apos;), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000) &#125;)]);p.then(console.log).catch(console.error); Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。 1const jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;)); 上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve等价于下面的写法。 123Promise.resolve(&apos;foo&apos;)// 等价于new Promise(resolve =&gt; resolve(&apos;foo&apos;)) Promise.resolve方法的参数分成四种情况。 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 123456const p = Promise.resolve(&apos;Hello&apos;);p.then(function (s)&#123; console.log(s)&#125;);// Hello 不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法。 12345const p = Promise.resolve();p.then(function () &#123; // ...&#125;); 需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 12345678910111213setTimeout(function () &#123; console.log(&apos;three&apos;);&#125;, 0);Promise.resolve().then(function () &#123; console.log(&apos;two&apos;);&#125;);console.log(&apos;one&apos;);// one// two// three Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678const p = Promise.reject(&apos;出错了&apos;);// 等同于const p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 1234567891011const thenable = &#123; then(resolve, reject) &#123; reject(&apos;出错了&apos;); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable)&#125;)// true 应用加载图片我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; Generator 函数与 Promise 的结合使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 1234567891011121314151617181920212223242526272829303132function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve(&apos;foo&apos;); &#125;);&#125;const g = function* () &#123; try &#123; const foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function run (generator) &#123; const it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g); Promise.try()实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。 12345const f = () =&gt; console.log(&apos;now&apos;);(async () =&gt; f())();console.log(&apos;next&apos;);// now// next 第二种写法是使用new Promise()。 123456789const f = () =&gt; console.log(&apos;now&apos;);( () =&gt; new Promise( resolve =&gt; resolve(f()) ))();console.log(&apos;next&apos;);// now// next 鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。 12345const f = () =&gt; console.log(&apos;now&apos;);Promise.try(f);console.log(&apos;next&apos;);// now// next 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。 123Promise.try(database.users.get(&#123;id: userId&#125;)) .then(...) .catch(...)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Reflect]]></title>
    <url>%2F2018%2F12%2F22%2Fes6-Reflect%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Reflect。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 概述Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。 修改某些Object方法的返回结果，让其变得更合理。 让Object操作都变成函数行为。 Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。 静态方法Reflect对象一共有 13 个静态方法。 Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) 上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。 Reflect.get(target, name, receiver)Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 1234567891011var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;Reflect.get(myObject, &apos;foo&apos;) // 1Reflect.get(myObject, &apos;bar&apos;) // 2Reflect.get(myObject, &apos;baz&apos;) // 3 如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。 1234567891011121314var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;;var myReceiverObject = &#123; foo: 4, bar: 4,&#125;;Reflect.get(myObject, &apos;baz&apos;, myReceiverObject) // 8 Reflect.set(target, name, value, receiver)Reflect.set方法设置target对象的name属性等于value。 1234567891011121314var myObject = &#123; foo: 1, set bar(value) &#123; return this.foo = value; &#125;,&#125;myObject.foo // 1Reflect.set(myObject, &apos;foo&apos;, 2);myObject.foo // 2Reflect.set(myObject, &apos;bar&apos;, 3)myObject.foo // 3 如果name属性设置了赋值函数，则赋值函数的this绑定receiver。 1234567891011121314var myObject = &#123; foo: 4, set bar(value) &#123; return this.foo = value; &#125;,&#125;;var myReceiverObject = &#123; foo: 0,&#125;;Reflect.set(myObject, &apos;bar&apos;, 1, myReceiverObject);myObject.foo // 4myReceiverObject.foo // 1 Reflect.has(obj, name)Reflect.has方法对应name in obj里面的in运算符。 123456789var myObject = &#123; foo: 1,&#125;;// 旧写法&apos;foo&apos; in myObject // true// 新写法Reflect.has(myObject, &apos;foo&apos;) // true Reflect.deleteProperty(obj, name)Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。 1234567const myObj = &#123; foo: &apos;bar&apos; &#125;;// 旧写法delete myObj.foo;// 新写法Reflect.deleteProperty(myObj, &apos;foo&apos;); 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。 Reflect.construct(target, args)Reflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。 123456789function Greeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting(&apos;张三&apos;);// Reflect.construct 的写法const instance = Reflect.construct(Greeting, [&apos;张三&apos;]); Reflect.getPrototypeOf(obj)Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。 1234567const myObj = new FancyThing();// 旧写法Object.getPrototypeOf(myObj) === FancyThing.prototype;// 新写法Reflect.getPrototypeOf(myObj) === FancyThing.prototype; Reflect.setPrototypeOf(obj, newProto)Reflect.setPrototypeOf方法用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。 123456789const myObj = &#123;&#125;;// 旧写法Object.setPrototypeOf(myObj, Array.prototype);// 新写法Reflect.setPrototypeOf(myObj, Array.prototype);myObj.length // 0 Reflect.apply(func, thisArg, args)Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。 一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。 1234567891011const ages = [11, 33, 12, 54, 18, 96];// 旧写法const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// 新写法const youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); Reflect.defineProperty(target, propertyKey, attributes)Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。 12345678910111213function MyDate() &#123; /*…*/&#125;// 旧写法Object.defineProperty(MyDate, &apos;now&apos;, &#123; value: () =&gt; Date.now()&#125;);// 新写法Reflect.defineProperty(MyDate, &apos;now&apos;, &#123; value: () =&gt; Date.now()&#125;); Reflect.getOwnPropertyDescriptor(target, propertyKey)Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。 1234567891011var myObject = &#123;&#125;;Object.defineProperty(myObject, &apos;hidden&apos;, &#123; value: true, enumerable: false,&#125;);// 旧写法var theDescriptor = Object.getOwnPropertyDescriptor(myObject, &apos;hidden&apos;);// 新写法var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, &apos;hidden&apos;); Reflect.isExtensible (target)Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。 1234567const myObject = &#123;&#125;;// 旧写法Object.isExtensible(myObject) // true// 新写法Reflect.isExtensible(myObject) // true Reflect.preventExtensions(target)Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。 1234567var myObject = &#123;&#125;;// 旧写法Object.preventExtensions(myObject) // Object &#123;&#125;// 新写法Reflect.preventExtensions(myObject) // true Reflect.ownKeys (target)Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 1234567891011121314151617var myObject = &#123; foo: 1, bar: 2, [Symbol.for(&apos;baz&apos;)]: 3, [Symbol.for(&apos;bing&apos;)]: 4,&#125;;// 旧写法Object.getOwnPropertyNames(myObject)// [&apos;foo&apos;, &apos;bar&apos;]Object.getOwnPropertySymbols(myObject)//[Symbol(baz), Symbol(bing)]// 新写法Reflect.ownKeys(myObject)// [&apos;foo&apos;, &apos;bar&apos;, Symbol(baz), Symbol(bing)] 实例：使用 Proxy 实现观察者模式观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。 12345678910111213const person = observable(&#123; name: &apos;张三&apos;, age: 20&#125;);function print() &#123; console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)&#125;observe(print);person.name = &apos;李四&apos;;// 输出// 李四, 20 上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。 下面，使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。 12345678910const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;&#125; 上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Proxy]]></title>
    <url>%2F2018%2F12%2F21%2Fes6-Proxy%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Proxy。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 下面是另一个拦截读取属性行为的例子。 123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 12345var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = &apos;b&apos;;target.a // &quot;b&quot; 一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。 1var object = &#123; proxy: new Proxy(target, handler) &#125;; Proxy 实例也可以作为其他对象的原型对象。 12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35 上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。 下面是 Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[&#39;foo&#39;]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[&#39;foo&#39;] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 Proxy 实例的方法下面是上面这些拦截方法的详细介绍。 get()get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。 get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。 12345678910111213141516var person = &#123; name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;); &#125; &#125;&#125;);proxy.name // &quot;张三&quot;proxy.age // 抛出一个错误 set()set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。 1234567891011121314151617181920212223let validator = &#123; set: function(obj, prop, value) &#123; if (prop === &apos;age&apos;) &#123; if (!Number.isInteger(value)) &#123; throw new TypeError(&apos;The age is not an integer&apos;); &#125; if (value &gt; 200) &#123; throw new RangeError(&apos;The age seems invalid&apos;); &#125; &#125; // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = &apos;young&apos; // 报错person.age = 300 // 报错 apply()apply方法拦截函数的调用、call和apply操作。 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 12345var handler = &#123; apply (target, ctx, args) &#123; return Reflect.apply(...arguments); &#125;&#125;; 下面是一个例子。 1234567891011var target = function () &#123; return &apos;I am the target&apos;; &#125;;var handler = &#123; apply: function () &#123; return &apos;I am the proxy&apos;; &#125;&#125;;var p = new Proxy(target, handler);p()// &quot;I am the proxy&quot; has()has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。 has方法可以接受两个参数，分别是目标对象、需查询的属性名。 下面的例子使用has方法隐藏某些属性，不被in运算符发现。 1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === &apos;_&apos;) &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: &apos;foo&apos;, prop: &apos;foo&apos; &#125;;var proxy = new Proxy(target, handler);&apos;_prop&apos; in proxy // false construct()construct方法用于拦截new命令，下面是拦截对象的写法。 12345var handler = &#123; construct (target, args, newTarget) &#123; return new target(...args); &#125;&#125;; construct方法可以接受两个参数。 target：目标对象 args：构造函数的参数对象 newTarget：创造实例对象时，new命令作用的构造函数（下面例子的p） 12345678910var p = new Proxy(function () &#123;&#125;, &#123; construct: function(target, args) &#123; console.log(&apos;called: &apos; + args.join(&apos;, &apos;)); return &#123; value: args[0] * 10 &#125;; &#125;&#125;);(new p(1)).value// &quot;called: 1&quot;// 10 deleteProperty()deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。 1234567891011121314151617var handler = &#123; deleteProperty (target, key) &#123; invariant(key, &apos;delete&apos;); delete target[key]; return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === &apos;_&apos;) &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`); &#125;&#125;var target = &#123; _prop: &apos;foo&apos; &#125;;var proxy = new Proxy(target, handler);delete proxy._prop// Error: Invalid attempt to delete private &quot;_prop&quot; property defineProperty()defineProperty方法拦截了Object.defineProperty操作。 12345678var handler = &#123; defineProperty (target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = &apos;bar&apos; // 不会生效 注意，如果目标对象不可扩展（non-extensible），则defineProperty不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty方法不得改变这两个设置。 getOwnPropertyDescriptor()getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。 12345678910111213141516var handler = &#123; getOwnPropertyDescriptor (target, key) &#123; if (key[0] === &apos;_&apos;) &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: &apos;bar&apos;, baz: &apos;tar&apos; &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, &apos;wat&apos;)// undefinedObject.getOwnPropertyDescriptor(proxy, &apos;_foo&apos;)// undefinedObject.getOwnPropertyDescriptor(proxy, &apos;baz&apos;)// &#123; value: &apos;tar&apos;, writable: true, enumerable: true, configurable: true &#125; getPrototypeOf()getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 下面是一个例子。 1234567var proto = &#123;&#125;;var p = new Proxy(&#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125;&#125;);Object.getPrototypeOf(p) === proto // true isExtensible()isExtensible方法拦截Object.isExtensible操作。 12345678910var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; console.log(&quot;called&quot;); return true; &#125;&#125;);Object.isExtensible(p)// &quot;called&quot;// true ownKeys()ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() for…in循环 下面是拦截Object.keys()的例子。 12345678910111213141516let target = &#123; a: 1, b: 2, c: 3&#125;;let handler = &#123; ownKeys(target) &#123; return [&apos;a&apos;]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy)// [ &apos;a&apos; ] 注意，使用Object.keys方法时，有三类属性会被ownKeys方法自动过滤，不会返回。 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（enumerable）的属性 preventExtensions()preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。 这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。 12345678var proxy = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125;&#125;);Object.preventExtensions(proxy)// Uncaught TypeError: &apos;preventExtensions&apos; on proxy: trap returned truish but the proxy target is extensible setPrototypeOf()setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。 下面是一个例子。 12345678910var handler = &#123; setPrototypeOf (target, proto) &#123; throw new Error(&apos;Changing the prototype is forbidden&apos;); &#125;&#125;;var proto = &#123;&#125;;var target = function () &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto);// Error: Changing the prototype is forbidden Proxy.revocable()Proxy.revocable方法返回一个可取消的 Proxy 实例。 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 1234567891011const target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true 下面是一个例子，由于this指向的变化，导致 Proxy 无法代理目标对象。 12345678910111213141516const _name = new WeakMap();class Person &#123; constructor(name) &#123; _name.set(this, name); &#125; get name() &#123; return _name.get(this); &#125;&#125;const jane = new Person(&apos;Jane&apos;);jane.name // &apos;Jane&apos;const proxy = new Proxy(jane, &#123;&#125;);proxy.name // undefined 实例：Web 服务的客户端Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。 123456const service = createWebService(&apos;http://example.com/data&apos;);service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;); 上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。 1234567function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+&apos;/&apos; + propKey); &#125; &#125;);&#125; 同理，Proxy 也可以用来实现数据库的 ORM 层。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Set和Map数据结构]]></title>
    <url>%2F2018%2F12%2F20%2Fes6-Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Set和Map数据结构。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 Set基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 12345678910111213141516171819// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll(&apos;div&apos;));set.size // 56// 类似于const set = new Set();document .querySelectorAll(&apos;div&apos;) .forEach(div =&gt; set.add(div));set.size // 56 上面代码也展示了一种去除数组重复成员的方法。 12// 去除数组的重复成员[...new Set(array)] Set 实例的属性和方法Set 结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 上面这些属性和方法的实例如下。 1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false Array.from方法可以将 Set 结构转为数组。 12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。 12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作Set 结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。 keys()，values()，entries()keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 12345678910111213141516171819202122let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;] forEach()Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 12345let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value))// 1 : 1// 4 : 4// 9 : 9 遍历的应用扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。 123let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);let arr = [...set];// [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;] 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。 123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 而且，数组的map和filter方法也可以间接用于 Set 了。 1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; 因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; WeakSet含义WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。 12345const ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 语法WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。 1const ws = new WeakSet(); 作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。 123const a = [[1, 2], [3, 4]];const ws = new WeakSet(a);// WeakSet &#123;[1, 2], [3, 4]&#125; WeakSet 结构有以下三个方法。 WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。 WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 下面是一个例子。 123456789101112const ws = new WeakSet();const obj = &#123;&#125;;const foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 Map含义和基本用法JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 12345const data = &#123;&#125;;const element = document.getElementById(&apos;myDiv&apos;);data[element] = &apos;metadata&apos;;data[&apos;[object HTMLDivElement]&apos;] // &quot;metadata&quot; 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 123456789const m = new Map();const o = &#123;p: &apos;Hello World&apos;&#125;;m.set(o, &apos;content&apos;)m.get(o) // &quot;content&quot;m.has(o) // truem.delete(o) // truem.has(o) // false 上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 12345678910const map = new Map([ [&apos;name&apos;, &apos;张三&apos;], [&apos;title&apos;, &apos;Author&apos;]]);map.size // 2map.has(&apos;name&apos;) // truemap.get(&apos;name&apos;) // &quot;张三&quot;map.has(&apos;title&apos;) // truemap.get(&apos;title&apos;) // &quot;Author&quot; 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。 12345678910const set = new Set([ [&apos;foo&apos;, 1], [&apos;bar&apos;, 2]]);const m1 = new Map(set);m1.get(&apos;foo&apos;) // 1const m2 = new Map([[&apos;baz&apos;, 3]]);const m3 = new Map(m2);m3.get(&apos;baz&apos;) // 3 实例的属性和操作方法Map 结构的实例有以下属性和操作方法。 size 属性size属性返回 Map 结构的成员总数。 12345const map = new Map();map.set(&apos;foo&apos;, true);map.set(&apos;bar&apos;, false);map.size // 2 set(key, value)set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。 12345const m = new Map();m.set(&apos;edition&apos;, 6) // 键是字符串m.set(262, &apos;standard&apos;) // 键是数值m.set(undefined, &apos;nah&apos;) // 键是 undefined set方法返回的是当前的Map对象，因此可以采用链式写法。 1234let map = new Map() .set(1, &apos;a&apos;) .set(2, &apos;b&apos;) .set(3, &apos;c&apos;); get(key)get方法读取key对应的键值，如果找不到key，返回undefined。 123456const m = new Map();const hello = function() &#123;console.log(&apos;hello&apos;);&#125;;m.set(hello, &apos;Hello ES6!&apos;) // 键是函数m.get(hello) // Hello ES6! has(key)has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 12345678910const m = new Map();m.set(&apos;edition&apos;, 6);m.set(262, &apos;standard&apos;);m.set(undefined, &apos;nah&apos;);m.has(&apos;edition&apos;) // truem.has(&apos;years&apos;) // falsem.has(262) // truem.has(undefined) // true delete(key)delete方法删除某个键，返回true。如果删除失败，返回false。 123456const m = new Map();m.set(undefined, &apos;nah&apos;);m.has(undefined) // truem.delete(undefined)m.has(undefined) // false clear()clear方法清除所有成员，没有返回值。 1234567let map = new Map();map.set(&apos;foo&apos;, true);map.set(&apos;bar&apos;, false);map.size // 2map.clear()map.size // 0 遍历方法Map 结构原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。 需要特别注意的是，Map 的遍历顺序就是插入顺序。 123456789101112131415161718192021222324252627282930313233343536const map = new Map([ [&apos;F&apos;, &apos;no&apos;], [&apos;T&apos;, &apos;yes&apos;],]);for (let key of map.keys()) &#123; console.log(key);&#125;// &quot;F&quot;// &quot;T&quot;for (let value of map.values()) &#123; console.log(value);&#125;// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot; 上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。 与其他数据结构的互相转换Map 转为数组前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（...）。 12345const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, [&apos;abc&apos;]);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ] 数组 转为 Map将数组传入 Map 构造函数，就可以转为 Map。 12345678new Map([ [true, 7], [&#123;foo: 3&#125;, [&apos;abc&apos;]]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]// &#125; Map 转为对象如果所有 Map 的键都是字符串，它可以无损地转为对象。 12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set(&apos;yes&apos;, true) .set(&apos;no&apos;, false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; 对象转为 Map12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125; Map 转为 JSONMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);strMapToJson(myMap)// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos; 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);mapToArrayJson(myMap)// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos; JSON 转为 MapJSON 转为 Map，正常情况下，所有键名都是字符串。 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)// Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125; WeakMap含义WeakMap结构与Map结构类似，也是用于生成键值对的集合。 123456789101112// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = &#123;foo: 1&#125;;wm1.set(key, 2);wm1.get(key) // 2// WeakMap 也可以接受一个数组，// 作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, &apos;foo&apos;], [k2, &apos;bar&apos;]]);wm2.get(k2) // &quot;bar&quot; WeakMap与Map的区别有两点。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 1234567const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key WeakMap 的语法123456const wm = new WeakMap();// size、forEach、clear 方法都不存在wm.size // undefinedwm.forEach // undefinedwm.clear // undefined]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Symbol]]></title>
    <url>%2F2018%2F12%2F20%2Fes6-Symbol%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的Symbol。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 1234let s = Symbol();typeof s// &quot;symbol&quot; 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12345678let s1 = Symbol(&apos;foo&apos;);let s2 = Symbol(&apos;bar&apos;);s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // &quot;Symbol(foo)&quot;s2.toString() // &quot;Symbol(bar)&quot; 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。 1234567const obj = &#123; toString() &#123; return &apos;abc&apos;; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 1234567891011// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol(&apos;foo&apos;);let s2 = Symbol(&apos;foo&apos;);s1 === s2 // false 作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = &apos;Hello!&apos;;// 第二种写法let a = &#123; [mySymbol]: &apos;Hello!&apos;&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot; 注意，Symbol 值作为对象属性名时，不能用点运算符。 123456const mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = &apos;Hello!&apos;;a[mySymbol] // undefineda[&apos;mySymbol&apos;] // &quot;Hello!&quot; 上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。 同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 1234567let s = Symbol();let obj = &#123; [s]: function (arg) &#123; ... &#125;&#125;;obj[s](123); 采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。 123let obj = &#123; [s](arg) &#123; ... &#125;&#125;; 实例：消除魔术字符串魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。 1234567891011121314function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case &apos;Triangle&apos;: // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ &#125; return area;&#125;getArea(&apos;Triangle&apos;, &#123; width: 100, height: 100 &#125;); // 魔术字符串 常用的消除魔术字符串的方法，就是把它写成一个变量。 123456789101112131415const shapeType = &#123; triangle: &apos;Triangle&apos;&#125;;function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); 如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。 123const shapeType = &#123; triangle: Symbol()&#125;; 上面代码中，除了将shapeType.triangle的值设为一个 Symbol，其他地方都不用修改。 属性名的遍历Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 1234567891011const obj = &#123;&#125;;let a = Symbol(&apos;a&apos;);let b = Symbol(&apos;b&apos;);obj[a] = &apos;Hello&apos;;obj[b] = &apos;World&apos;;const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] 下面是另一个例子，Object.getOwnPropertySymbols方法与for...in循环、Object.getOwnPropertyNames方法进行对比的例子。 1234567891011121314151617const obj = &#123;&#125;;let foo = Symbol(&quot;foo&quot;);Object.defineProperty(obj, foo, &#123; value: &quot;foobar&quot;,&#125;);for (let i in obj) &#123; console.log(i); // 无输出&#125;Object.getOwnPropertyNames(obj)// []Object.getOwnPropertySymbols(obj)// [Symbol(foo)] 另一个新的 API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol(&apos;my_key&apos;)]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)] Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 1234let s1 = Symbol.for(&apos;foo&apos;);let s2 = Symbol.for(&apos;foo&apos;);s1 === s2 // true Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(&quot;cat&quot;)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(&quot;cat&quot;)30 次，会返回 30 个不同的 Symbol 值。 12345Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;)// trueSymbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;)// false Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345let s1 = Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) // &quot;foo&quot;let s2 = Symbol(&quot;foo&quot;);Symbol.keyFor(s2) // undefined 上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。 内置的 Symbol 值除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。 Symbol.hasInstance对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。 1234567class MyClass &#123; [Symbol.hasInstance](foo) &#123; return foo instanceof Array; &#125;&#125;[1, 2, 3] instanceof new MyClass() // true Symbol.isConcatSpreadable对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 1234567let arr1 = [&apos;c&apos;, &apos;d&apos;];[&apos;a&apos;, &apos;b&apos;].concat(arr1, &apos;e&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]arr1[Symbol.isConcatSpreadable] // undefinedlet arr2 = [&apos;c&apos;, &apos;d&apos;];arr2[Symbol.isConcatSpreadable] = false;[&apos;a&apos;, &apos;b&apos;].concat(arr2, &apos;e&apos;) // [&apos;a&apos;, &apos;b&apos;, [&apos;c&apos;,&apos;d&apos;], &apos;e&apos;] 上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。 类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。 12345let obj = &#123;length: 2, 0: &apos;c&apos;, 1: &apos;d&apos;&#125;;[&apos;a&apos;, &apos;b&apos;].concat(obj, &apos;e&apos;) // [&apos;a&apos;, &apos;b&apos;, obj, &apos;e&apos;]obj[Symbol.isConcatSpreadable] = true;[&apos;a&apos;, &apos;b&apos;].concat(obj, &apos;e&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] Symbol.species对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。 123456789class MyArray extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125;&#125;const a = new MyArray();const b = a.map(x =&gt; x);b instanceof MyArray // falseb instanceof Array // true Symbol.match对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。 1234567891011String.prototype.match(regexp)// 等同于regexp[Symbol.match](this)class MyMatcher &#123; [Symbol.match](string) &#123; return &apos;hello world&apos;.indexOf(string); &#125;&#125;&apos;e&apos;.match(new MyMatcher()) // 1 Symbol.replace对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。 123String.prototype.replace(searchValue, replaceValue)// 等同于searchValue[Symbol.replace](this, replaceValue) 下面是一个例子。 1234const x = &#123;&#125;;x[Symbol.replace] = (...s) =&gt; console.log(s);&apos;Hello&apos;.replace(x, &apos;World&apos;) // [&quot;Hello&quot;, &quot;World&quot;] Symbol.search对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。 12345678910111213String.prototype.search(regexp)// 等同于regexp[Symbol.search](this)class MySearch &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.search](string) &#123; return string.indexOf(this.value); &#125;&#125;&apos;foobar&apos;.search(new MySearch(&apos;foo&apos;)) // 0 Symbol.split对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。 123String.prototype.split(separator, limit)// 等同于separator[Symbol.split](this, limit) Symbol.iterator对象的Symbol.iterator属性，指向该对象的默认遍历器方法。 12345678const myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] Symbol.toPrimitive对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。 Number：该场合需要转成数值 String：该场合需要转成字符串 Default：该场合可以转成数值，也可以转成字符串 12345678910111213141516171819let obj = &#123; [Symbol.toPrimitive](hint) &#123; switch (hint) &#123; case &apos;number&apos;: return 123; case &apos;string&apos;: return &apos;str&apos;; case &apos;default&apos;: return &apos;default&apos;; default: throw new Error(); &#125; &#125;&#125;;2 * obj // 2463 + obj // &apos;3default&apos;obj == &apos;default&apos; // trueString(obj) // &apos;str&apos; Symbol.toStringTag对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。 123456789101112// 例一(&#123;[Symbol.toStringTag]: &apos;Foo&apos;&#125;.toString())// &quot;[object Foo]&quot;// 例二class Collection &#123; get [Symbol.toStringTag]() &#123; return &apos;xxx&apos;; &#125;&#125;let x = new Collection();Object.prototype.toString.call(x) // &quot;[object xxx]&quot; Symbol.unscopables对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。 12345678910111213Array.prototype[Symbol.unscopables]// &#123;// copyWithin: true,// entries: true,// fill: true,// find: true,// findIndex: true,// includes: true,// keys: true// &#125;Object.keys(Array.prototype[Symbol.unscopables])// [&apos;copyWithin&apos;, &apos;entries&apos;, &apos;fill&apos;, &apos;find&apos;, &apos;findIndex&apos;, &apos;includes&apos;, &apos;keys&apos;]]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-对象的新增方法]]></title>
    <url>%2F2018%2F12%2F19%2Fes6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的对象的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 Object.is()ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 1234Object.is(&apos;foo&apos;, &apos;foo&apos;)// trueObject.is(&#123;&#125;, &#123;&#125;)// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign()基本用法Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意点浅拷贝Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 12345const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 同名属性的替换对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 1234const target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;const source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125; 数组的处理Object.assign可以用来处理数组，但是会把数组视为对象。 12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 取值函数的处理Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。 1234567onst source = &#123; get foo() &#123; return 1 &#125;&#125;;const target = &#123;&#125;;Object.assign(target, source)// &#123; foo: 1 &#125; 常见用途为对象添加属性12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 为对象添加方法12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; ···&#125;; 克隆对象123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。 1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 合并多个对象12const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。 12const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 为属性指定默认值12345678910const DEFAULTS = &#123; logLevel: 0, outputFormat: &apos;html&apos;&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // ...&#125; Object.getOwnPropertyDescriptors()ES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。 12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return &apos;abc&apos; &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。 proto属性proto属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。 123456789// es5 的写法const obj = &#123; method: function() &#123; ... &#125;&#125;;obj.__proto__ = someOtherObj;// es6 的写法var obj = Object.create(someOtherObj);obj.method = function() &#123; ... &#125;; Object.setPrototypeOf()Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。 12345// 格式Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf(&#123;&#125;, null); 该方法等同于下面的函数。 1234function setPrototypeOf(obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 下面是一个例子。 12345678910let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 Object.getPrototypeOf()该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。 1Object.getPrototypeOf(obj); 下面是一个例子。 123456789101112function Rectangle() &#123; // ...&#125;const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false Object.keys()，Object.values()，Object.entries()Object.keys()ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。 1234567891011121314let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]&#125; Object.values()Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 123const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;Object.values(obj)// [&quot;bar&quot;, 42] 返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。 123const obj = &#123; 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; &#125;;Object.values(obj)// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] Object.entries()Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 123const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;Object.entries(obj)// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ] Object.entries的基本用途是遍历对象的属性。 12345678let obj = &#123; one: 1, two: 2 &#125;;for (let [k, v] of Object.entries(obj)) &#123; console.log( `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;` );&#125;// &quot;one&quot;: 1// &quot;two&quot;: 2 Object.entries方法的另一个用处是，将对象转为真正的Map结构。 123const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;const map = new Map(Object.entries(obj));map // Map &#123; foo: &quot;bar&quot;, baz: 42 &#125; Object.fromEntries()Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。 12345Object.fromEntries([ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42]])// &#123; foo: &quot;bar&quot;, baz: 42 &#125; 该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。 12345678910111213// 例一const entries = new Map([ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42]]);Object.fromEntries(entries)// &#123; foo: &quot;bar&quot;, baz: 42 &#125;// 例二const map = new Map().set(&apos;foo&apos;, true).set(&apos;bar&apos;, false);Object.fromEntries(map)// &#123; foo: true, bar: false &#125; 该方法的一个用处是配合URLSearchParams对象，将查询字符串转为对象。 12Object.fromEntries(new URLSearchParams(&apos;foo=bar&amp;baz=qux&apos;))// &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-对象的扩展]]></title>
    <url>%2F2018%2F12%2F19%2Fes6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的对象的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 下面是一个实际的例子。 12345678910111213let birth = &apos;2000/01/01&apos;;const Person = &#123; name: &apos;张三&apos;, //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log(&apos;我的名字是&apos;, this.name); &#125;&#125;; 这种写法用于函数的返回值，将会非常方便。 12345678function getPoint() &#123; const x = 1; const y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; CommonJS 模块输出一组变量，就非常合适使用简洁写法。 123456789101112131415161718192021let ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性名表达式JavaScript 定义对象的属性，有两种方法。 12345// 方法一obj.foo = true;// 方法二obj[&apos;a&apos; + &apos;bc&apos;] = 123; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 123456let propKey = &apos;foo&apos;;let obj = &#123; [propKey]: true, [&apos;a&apos; + &apos;bc&apos;]: 123&#125;; 方法的 name 属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 1234567const person = &#123; sayName() &#123; console.log(&apos;hello!&apos;); &#125;,&#125;;person.sayName.name // &quot;sayName&quot; 上面代码中，方法的name属性返回函数名（即方法名）。 属性的可枚举性和遍历可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; 描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。 目前，有四个操作会忽略enumerable为false的属性。 for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。 12345Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;).enumerable// falseObject.getOwnPropertyDescriptor([], &apos;length&apos;).enumerable// false 上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。 另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。 12Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, &apos;foo&apos;).enumerable// false 属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 for…infor...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj)Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols(obj)Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// [&apos;2&apos;, &apos;10&apos;, &apos;b&apos;, &apos;a&apos;, Symbol()] super 关键字我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。 12345678910111213const proto = &#123; foo: &apos;hello&apos;&#125;;const obj = &#123; foo: &apos;world&apos;, find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // &quot;hello&quot; 上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。 对象的扩展运算符《数组的扩展》一章中，已经介绍过扩展运算符（…）。 123const [a, ...b] = [1, 2, 3];a // 1b // [2, 3] 解构赋值对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 扩展运算符对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。 123let foo = &#123; ...[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &#125;;foo// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125; 对象的扩展运算符等同于使用Object.assign()方法。 123let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4-简单配置]]></title>
    <url>%2F2018%2F12%2F18%2Fwebpack4-%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 概念入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 每个依赖项随即被处理，最后输出到称之为 bundles 的文件中，我们将在下一章节详细讨论这个过程。 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。 接下来我们看一个 entry 配置的最简单例子： webpack.config.js 123module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125;; 出口(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： webpack.config.js 123456789const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;&#125;; 在上面的示例中，我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 Node.js 核心模块，用于操作文件路径。 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在更高层面，在 webpack 的配置中 loader 有两个目标： test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，表示进行转换时，应该使用哪个 loader。 webpack.config.js 1234567891011121314const path = require(&apos;path&apos;);const config = &#123; output: &#123; filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;&#125;;module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 &#39;.txt&#39; 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。” 插件(plugins)oader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 webpack.config.js 123456789101112131415const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装const webpack = require(&apos;webpack&apos;); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;) ]&#125;;module.exports = config; 模式通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 123module.exports = &#123; mode: &apos;production&apos;&#125;; 配置基本安装首先我们创建一个目录，初始化 npm，然后 在本地安装 webpack，接着安装 webpack-cli（此工具用于在命令行中运行 webpack）： 123mkdir webpack-demo &amp;&amp; cd webpack-demonpm init -ynpm install webpack webpack-cli --save-dev 现在我们将创建以下目录结构、文件和内容： 目录project 1234567webpack-demo |- package.json |- /src |- index.js |- webpack.common.js |- webpack.dev.js |- webpack.prod.js npm配置文件package.json 12345678910111213141516171819202122232425262728293031&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;sideEffects&quot;: false, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;clean-webpack-plugin&quot;: &quot;^1.0.0&quot;, &quot;css-loader&quot;: &quot;^2.0.1&quot;, &quot;csv-loader&quot;: &quot;^3.0.2&quot;, &quot;express&quot;: &quot;^4.16.4&quot;, &quot;file-loader&quot;: &quot;^2.0.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;style-loader&quot;: &quot;^0.23.1&quot;, &quot;uglifyjs-webpack-plugin&quot;: &quot;^2.0.1&quot;, &quot;webpack&quot;: &quot;^4.27.1&quot;, &quot;webpack-cli&quot;: &quot;^3.1.2&quot;, &quot;webpack-dev-middleware&quot;: &quot;^3.4.0&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.10&quot;, &quot;webpack-merge&quot;: &quot;^4.1.5&quot;, &quot;xml-loader&quot;: &quot;^1.2.1&quot; &#125;&#125; 请npm安装所有依赖 入口js文件src/index.js 1234567891011function component() &#123; var element = document.createElement(&apos;pre&apos;); element.innerHTML=[ &apos;Hello webpack!&apos; ] return element;&#125;document.body.appendChild(component()); webpack公用配置文件webpack.common.js 123456789101112131415161718192021222324252627282930313233343536373839404142const path = require(&apos;path&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: &#123; app: &apos;./src/index.js&apos; &#125;, module:&#123; rules: [&#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;, &#123; test: /\.(png|svg|jpg|gif)$/, use: [ &apos;file-loader&apos; ] &#125;, &#123; test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ &apos;file-loader&apos; ] &#125;, ] &#125;, plugins: [ new CleanWebpackPlugin([&apos;dist&apos;]), new HtmlWebpackPlugin(&#123; title: &apos;Production&apos; &#125;), ], output: &#123; filename: &apos;[name].bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;&#125; webpack开发环境配置文件webpack.dev.js 1234567891011121314const merge = require(&apos;webpack-merge&apos;);const common = require(&apos;./webpack.common.js&apos;);const webpack = require(&apos;webpack&apos;);module.exports = merge(common,&#123; devtool: &apos;inline-source-map&apos;, devServer: &#123; contentBase: &apos;./dist&apos; &#125;, plugins: [ new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin() ]&#125;); webpack生产环境配置文件webpack.prod.js 1234567891011121314const webpack = require(&apos;webpack&apos;);const merge = require(&apos;webpack-merge&apos;);const UglifyJSPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);const common = require(&apos;./webpack.common.js&apos;);module.exports = merge(common, &#123; devtool: &apos;source-map&apos;, plugins: [ new UglifyJSPlugin(&#123; sourceMap: true &#125;), new webpack.DefinePlugin() ]&#125;); 结尾没有安装vue react等前端框架，这里就大致的配置了下webpack。]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>webpack</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-数组的扩展]]></title>
    <url>%2F2018%2F12%2F18%2Fes6-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的数组的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 扩展运算符含义扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll(&apos;div&apos;)]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 该运算符主要用于函数调用。 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 扩展运算符与正常的函数参数可以结合使用，非常灵活。 123function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); 扩展运算符后面还可以放置表达式。 1234const arr = [ ...(x &gt; 0 ? [&apos;a&apos;] : []), &apos;b&apos;,]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 12[...[], 1]// [1] 替代函数的 apply 方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 12345678910111213// ES5 的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;let args = [0, 1, 2];f(...args); 下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。 12345678// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。 123456789// ES5的 写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6 的写法let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];arr1.push(...arr2); 下面是另外一个例子。 1234// ES5new (Date.bind.apply(Date, [null, 2015, 1, 1]))// ES6new Date(...[2015, 1, 1]); 扩展运算符的应用复制数组数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 合并数组扩展运算符提供了数组合并的新写法。 1234567891011const arr1 = [&apos;a&apos;, &apos;b&apos;];const arr2 = [&apos;c&apos;];const arr3 = [&apos;d&apos;, &apos;e&apos;];// ES5 的合并数组arr1.concat(arr2, arr3);// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ] 与解构赋值结合扩展运算符可以与解构赋值结合起来，用于生成数组。且只能放在参数的最后一位。 1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 字符串扩展运算符还可以将字符串转为真正的数组。 12[...&apos;hello&apos;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 实现了 Iterator 接口的对象任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 12let nodeList = document.querySelectorAll(&apos;div&apos;);let array = [...nodeList]; Map 和 Set 结构，Generator 函数扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 1234567let map = new Map([ [1, &apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;],]);let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567const go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]// ES6的写法let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll(&apos;p&apos;);Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。 12345Array.from(&apos;hello&apos;)// [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]let namesSet = new Set([&apos;a&apos;, &apos;b&apos;])Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;] 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。 1234567// arguments对象function foo() &#123; const args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll(&apos;div&apos;)] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.of()Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 数组实例的 copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 这三个参数都应该是数值，如果不是，会自动转为数值。 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的 find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 12345function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: &apos;John&apos;, age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 数组实例的 fill()fill方法使用给定值，填充一个数组。 12345[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)// [&apos;a&apos;, 7, &apos;c&apos;] 数组实例的 entries()，keys() 和 values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 数组实例的 flat()，flatMap()数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 12[1, 2, [3, 4]].flat()// [1, 2, 3, 4] flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。 12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 12[1, [2, [3]]].flat(Infinity)// [1, 2, 3] flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。 123// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8] 数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [, , ,] 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false ES6 则是明确将空位转为undefined。 12345678910111213141516Array.from([&apos;a&apos;,,&apos;b&apos;])// [ &quot;a&quot;, undefined, &quot;b&quot; ][...[&apos;a&apos;,,&apos;b&apos;]]// [ &quot;a&quot;, undefined, &quot;b&quot; ][,&apos;a&apos;,&apos;b&apos;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]new Array(3).fill(&apos;a&apos;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 1234567891011121314// entries()[...[,&apos;a&apos;].entries()] // [[0,undefined], [1,&quot;a&quot;]]// keys()[...[,&apos;a&apos;].keys()] // [0,1]// values()[...[,&apos;a&apos;].values()] // [undefined,&quot;a&quot;]// find()[,&apos;a&apos;].find(x =&gt; true) // undefined// findIndex()[,&apos;a&apos;].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-函数的扩展]]></title>
    <url>%2F2018%2F12%2F18%2Fes6-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的函数的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 函数参数的默认值基本用法ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || &apos;World&apos;; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello World ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y = &apos;World&apos;) &#123; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;const p = new Point();p // &#123; x: 0, y: 0 &#125; 与解构赋值默认值结合使用12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property &apos;x&apos; of undefined 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。 12345function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 123456function foo(x = 5, y = 6) &#123; console.log(x, y);&#125;foo(undefined, null)// 5 null 函数的 length 属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。 1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 2 再看下面的例子。 12345678let x = 1;function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // 1 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。 12345678let foo = &apos;outer&apos;;function bar(func = () =&gt; foo) &#123; let foo = &apos;inner&apos;; console.log(func());&#125;bar(); // outer 应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 12345678910function throwIfMissing() &#123; throw new Error(&apos;Missing parameter&apos;);&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。 1function foo(optional = undefined) &#123; ··· &#125; rest 参数ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 下面是一个 rest 参数代替arguments变量的例子。 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。 123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 函数的length属性，不包括 rest 参数。 严格模式从 ES5 开始，函数内部可以设定为严格模式。 1234function doSomething(a, b) &#123; &apos;use strict&apos;; // code&#125; ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) &#123; &apos;use strict&apos;; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; &apos;use strict&apos;; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; &apos;use strict&apos;; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; &apos;use strict&apos;; // code &#125;&#125;; 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 12345&apos;use strict&apos;;function doSomething(a, b = a) &#123; // code&#125; 第二种是把函数包在一个无参数的立即执行函数里面。 123456const doSomething = (function () &#123; &apos;use strict&apos;; return function(value = 42) &#123; return value; &#125;;&#125;()); name 属性函数的name属性，返回该函数的函数名。 12function foo() &#123;&#125;foo.name // &quot;foo&quot; 箭头函数基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 1let fn = () =&gt; void doesNotReturn(); 箭头函数可以与变量解构结合使用。 123456const full = (&#123; first, last &#125;) =&gt; first + &apos; &apos; + last;// 等同于function full(person) &#123; return person.first + &apos; &apos; + person.last;&#125; 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 另一个例子是 1234567// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 下面是 rest 参数与箭头函数结合的例子 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);// s1: 3// s2: 0 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。 123456789101112var handler = &#123; id: &apos;123456&apos;, init: function() &#123; document.addEventListener(&apos;click&apos;, event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log(&apos;Handling &apos; + type + &apos; for &apos; + this.id); &#125;&#125;; 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;args:&apos;, arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)() ];&#125;).call(&#123; x: &apos;outer&apos; &#125;);// [&apos;outer&apos;] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 不适用场合由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。 第一个场合是定义函数的方法，且该方法内部包括this。 123456const cat = &#123; lives: 9, jumps: () =&gt; &#123; this.lives--; &#125;&#125; 第二个场合是需要动态this的时候，也不应使用箭头函数。 1234var button = document.getElementById(&apos;press&apos;);button.addEventListener(&apos;click&apos;, () =&gt; &#123; this.classList.toggle(&apos;on&apos;);&#125;); 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。 嵌套的箭头函数下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。 123456789const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;const addThenMult = pipeline(plus1, mult2);addThenMult(5)// 12 如果觉得上面的写法可读性比较差，也可以采用下面的写法。 12345const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;mult2(plus1(5))// 12 双冒号运算符箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。 123456import &#123; map, takeWhile, forEach &#125; from &quot;iterlib&quot;;getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x)); 尾调用优化什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x)&#123; return g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 尾调用优化函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。 非尾递归的 Fibonacci 数列实现如下。 123456789function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 堆栈溢出Fibonacci(500) // 堆栈溢出 尾递归优化过的 Fibonacci 数列实现如下。 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。 此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 123456789function clownsEverywhere( param1, param2,) &#123; /* ... */ &#125;clownsEverywhere( &apos;foo&apos;, &apos;bar&apos;,); 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-数值的扩展]]></title>
    <url>%2F2018%2F12%2F17%2Fes6-%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的数值的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 二进制和八进制表示法ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 120b111110111 === 503 // true0o767 === 503 // true 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 12Number(&apos;0b111&apos;) // 7Number(&apos;0o10&apos;) // 8 Number.isFinite(), Number.isNaN()ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 12345678Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite(&apos;foo&apos;); // falseNumber.isFinite(&apos;15&apos;); // falseNumber.isFinite(true); // false Number.isNaN()用来检查一个值是否为NaN。 1234567Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN(&apos;15&apos;) // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN(&apos;true&apos; / 0) // trueNumber.isNaN(&apos;true&apos; / &apos;true&apos;) // true 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 12345678910isFinite(25) // trueisFinite(&quot;25&quot;) // trueNumber.isFinite(25) // trueNumber.isFinite(&quot;25&quot;) // falseisNaN(NaN) // trueisNaN(&quot;NaN&quot;) // trueNumber.isNaN(NaN) // trueNumber.isNaN(&quot;NaN&quot;) // falseNumber.isNaN(1) // false Number.parseInt(), Number.parseFloat()ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5的写法parseInt(&apos;12.34&apos;) // 12parseFloat(&apos;123.45#&apos;) // 123.45// ES6的写法Number.parseInt(&apos;12.34&apos;) // 12Number.parseFloat(&apos;123.45#&apos;) // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true Number.isInteger()Number.isInteger()用来判断一个数值是否为整数。 12Number.isInteger(25) // trueNumber.isInteger(25.1) // false 如果参数不是数值，Number.isInteger返回false。 1234Number.isInteger() // falseNumber.isInteger(null) // falseNumber.isInteger(&apos;15&apos;) // falseNumber.isInteger(true) // false Number.EPSILONES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。 123456Number.EPSILON === Math.pow(2, -52)// trueNumber.EPSILON// 2.220446049250313e-16Number.EPSILON.toFixed(20)// &quot;0.00000000000000022204&quot; 安全整数和 Number.isSafeInteger()JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。 1234567Math.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1// true ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 123456789101112131415Number.isSafeInteger(&apos;a&apos;) // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false Math 对象的扩展ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。 Math.trunc()Math.trunc方法用于去除一个数的小数部分，返回整数部分。 12345Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0 Math.sign()Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 12345Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaN Math.cbrt()Math.cbrt方法用于计算一个数的立方根。 1234Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734 Math.clz32()JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1000) // 22Math.clz32(0b01000000000000000000000000000000) // 1Math.clz32(0b00100000000000000000000000000000) // 2 Math.imul()Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。 123Math.imul(2, 4) // 8Math.imul(-1, 8) // -8Math.imul(-2, -2) // 4 Math.fround()Math.fround方法返回一个数的32位单精度浮点数形式。 123Math.fround(0) // 0Math.fround(1) // 1Math.fround(2 ** 24 - 1) // 16777215 Math.hypot()Math.hypot方法返回所有参数的平方和的平方根。 1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, &apos;foo&apos;); // NaNMath.hypot(3, 4, &apos;5&apos;); // 7.0710678118654755Math.hypot(-3); // 3 对数方法ES6 新增了 4 个对数相关方法。 Math.expm1()Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。 123Math.expm1(-1) // -0.6321205588285577Math.expm1(0) // 0Math.expm1(1) // 1.718281828459045 Math.log1p()Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 1234Math.log1p(1) // 0.6931471805599453Math.log1p(0) // 0Math.log1p(-1) // -InfinityMath.log1p(-2) // NaN Math.log10()Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。 12345Math.log10(2) // 0.3010299956639812Math.log10(1) // 0Math.log10(0) // -InfinityMath.log10(-2) // NaNMath.log10(100000) // 5 Math.log2()Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。 1234567Math.log2(3) // 1.584962500721156Math.log2(2) // 1Math.log2(1) // 0Math.log2(0) // -InfinityMath.log2(-2) // NaNMath.log2(1024) // 10Math.log2(1 &lt;&lt; 29) // 29 双曲函数方法ES6 新增了 6 个双曲函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 指数运算符ES2016 新增了一个指数运算符（**）。 122 ** 2 // 42 ** 3 // 8 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。 123// 相当于 2 ** (3 ** 2)2 ** 3 ** 2// 512 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 1234567let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-正则的扩展]]></title>
    <url>%2F2018%2F12%2F17%2Fes6-%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的正则表达式的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 RegExp 构造函数在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 123var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;);// 等价于var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 123var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 12var regex = new RegExp(/xyz/, &apos;i&apos;);// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/ig, &apos;i&apos;).flags// &quot;i&quot; 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 12/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;) // false/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;) // true RegExp.prototype.unicode 属性正则实例对象新增unicode属性，表示是否设置了u修饰符。 12345const r1 = /hello/;const r2 = /hello/u;r1.unicode // falser2.unicode // true y 修饰符除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。 y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = &apos;aaa_aa_a&apos;;var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // [&quot;aaa&quot;]r2.exec(s) // [&quot;aaa&quot;]r1.exec(s) // [&quot;aa&quot;]r2.exec(s) // null RegExp.prototype.sticky 属性与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。 12var r = /hello\d/y;r.sticky // true RegExp.prototype.flags 属性ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 123456789// ES5 的 source 属性// 返回正则表达式的正文/abc/ig.source// &quot;abc&quot;// ES6 的 flags 属性// 返回正则表达式的修饰符/abc/ig.flags// &apos;gi&apos; s 修饰符：dotAll 模式ES2018 引入s修饰符，使得.可以匹配任意单个字符。 1/foo.bar/s.test(&apos;foo\nbar&apos;) // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 1234567const re = /foo.bar/s;// 另一种写法// const re = new RegExp(&apos;foo.bar&apos;, &apos;s&apos;);re.test(&apos;foo\nbar&apos;) // truere.dotAll // truere.flags // &apos;s&apos; /s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 后行断言JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。 先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。 12/\d+(?=%)/.exec(&apos;100% of US presidents have been male&apos;) // [&quot;100&quot;]/\d+(?!%)/.exec(&apos;that’s all 44 of them&apos;) // [&quot;44&quot;] “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。”后行否定断言“则与”先行否定断言“相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。 12/(?&lt;=\$)\d+/.exec(&apos;Benjamin Franklin is on the $100 bill&apos;) // [&quot;100&quot;]/(?&lt;!\$)\d+/.exec(&apos;it’s is worth about €90&apos;) // [&quot;90&quot;] Unicode 属性类ES2018 引入了一种新的类的写法\p{...}和\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 12const regexGreekSymbol = /\p&#123;Script=Greek&#125;/u;regexGreekSymbol.test(&apos;π&apos;) // true 具名组匹配正则表达式使用圆括号进行组匹配。 1const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。 123456const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456const RE_DATE = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?&lt;year&gt;），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。 String.prototype.matchAll如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。 123456789101112131415var regex = /t(e)(st(\d?))/g;var string = &apos;test1test2test3&apos;;var matches = [];var match;while (match = regex.exec(string)) &#123; matches.push(match);&#125;matches// [// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]// ] 上面代码中，while循环取出每一轮的正则匹配，一共三轮。 目前有一个提案，增加了String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1234567891011const string = &apos;test1test2test3&apos;;// g 修饰符加不加都可以const regex = /t(e)(st(\d?))/g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;] 遍历器转为数组是非常简单的，使用...运算符和Array.from方法就可以了。 12345// 转为数组方法一[...string.matchAll(regex)]// 转为数组方法二Array.from(string.matchAll(regex));]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-字符串扩展]]></title>
    <url>%2F2018%2F12%2F16%2Fes6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的变量的解构赋值。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 字符的 Unicode 表示法JavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 12&quot;\u0061&quot;// &quot;a&quot; 但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示 12345&quot;\uD842\uDFB7&quot;// &quot;𠮷&quot;&quot;\u20BB7&quot;// &quot; 7&quot; ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符 1234567891011&quot;\u&#123;20BB7&#125;&quot;// &quot;𠮷&quot;&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;// &quot;ABC&quot;let hello = 123;hell\u&#123;6F&#125; // 123&apos;\u&#123;1F680&#125;&apos; === &apos;\uD83D\uDE80&apos;// true codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 1234567var s = &quot;𠮷&quot;;s.length // 2s.charAt(0) // &apos;&apos;s.charAt(1) // &apos;&apos;s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 123456let s = &apos;𠮷a&apos;;s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97 总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。 codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。 1234let s = &apos;𠮷a&apos;;s.codePointAt(0).toString(16) // &quot;20bb7&quot;s.codePointAt(2).toString(16) // &quot;61&quot; codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit(&quot;𠮷&quot;) // trueis32Bit(&quot;a&quot;) // false String.fromCodePoint()ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。 12String.fromCharCode(0x20BB7)// &quot;ஷ&quot; ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。 1234String.fromCodePoint(0x20BB7)// &quot;𠮷&quot;String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\uD83D\uDE80y&apos;// true 字符串的遍历器接口ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。 123456for (let codePoint of &apos;foo&apos;) &#123; console.log(codePoint)&#125;// &quot;f&quot;// &quot;o&quot;// &quot;o&quot; 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 123456789101112let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// &quot; &quot;// &quot; &quot;for (let i of text) &#123; console.log(i);&#125;// &quot;𠮷&quot; normalize()ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 12&apos;\u01D1&apos;.normalize() === &apos;\u004F\u030C&apos;.normalize()// true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = &apos;Hello world!&apos;;s.startsWith(&apos;Hello&apos;) // trues.endsWith(&apos;!&apos;) // trues.includes(&apos;o&apos;) // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345let s = &apos;Hello world!&apos;;s.startsWith(&apos;world&apos;, 6) // trues.endsWith(&apos;Hello&apos;, 5) // trues.includes(&apos;Hello&apos;, 6) // false repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123456789101112&apos;x&apos;.repeat(3) // &quot;xxx&quot;&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;&apos;na&apos;.repeat(0) // &quot;&quot;&apos;na&apos;.repeat(2.9) // &quot;nana&quot;&apos;na&apos;.repeat(Infinity)// RangeError&apos;na&apos;.repeat(-1)// RangeError&apos;na&apos;.repeat(-0.9) // &quot;&quot;&apos;na&apos;.repeat(NaN) // &quot;&quot;&apos;na&apos;.repeat(&apos;na&apos;) // &quot;&quot;&apos;na&apos;.repeat(&apos;3&apos;) // &quot;nanana&quot; padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos; matchAll()matchAll方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910111213// 普通字符串`In JavaScript &apos;\n&apos; is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义. 1let greeting = `\`Yo\` World!`; 模板字符串中嵌入变量，需要将变量名写在${}之中。 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 123456789101112let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// &quot;1 + 2 = 3&quot;`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// &quot;1 + 4 = 5&quot;let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// &quot;3&quot; 实例：模板编译下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置 JavaScript 代码，使用&lt;%= ... %&gt;输出 JavaScript 表达式。 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数 123456let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50); 123456789function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // ...&#125; 1234567891011121314151617181920let a = 5;let b = 10;function tag(s, v1, v2) &#123; console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return &quot;OK&quot;;&#125;tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`;// &quot;Hello &quot;// &quot; world &quot;// &quot;&quot;// 15// 50// &quot;OK&quot; String.raw()ES6 还为原生的 String 对象，提供了一个raw方法。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 12345String.raw`Hi\n$&#123;2+3&#125;!`;// 返回 &quot;Hi\\n5!&quot;String.raw`Hi\u000A!`;// 返回 &quot;Hi\\u000A!&quot; 模板字符串的限制前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-变量的解构赋值]]></title>
    <url>%2F2018%2F12%2F15%2Fes6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的变量的解构赋值。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 数组的解构赋值基本用法ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。 1let [a, b, c] = [1, 2, 3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象的解构赋值解构不仅可以用于数组，还可以用于对象。 123let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // undefined 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 对象的解构也可以指定默认值。 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = &apos;Something went wrong&apos; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot; 默认值生效的条件是，对象的属性值严格等于undefined。 12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 1let &#123; log, sin, cos &#125; = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = &apos;hello&apos;;len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值。 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 函数参数的解构也可以使用默认值。 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 不能使用圆括号的情况（1）变量声明语句 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数 函数参数也属于变量声明，因此不能带有圆括号 1234// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; （3）赋值语句的模式 123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将一部分模式放在圆括号之中，导致报错。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多 交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取 JSON 数据解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678910let jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125; = &#123;&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句 遍历 Map 结构任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-let和const命令]]></title>
    <url>%2F2018%2F12%2F14%2Fes6-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的let和const命令章节。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 let命令基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 块级作用域为什么需要块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变,必须立即初始化. 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 下面是另一个例子。 1234const a = [];a.push(&apos;Hello&apos;); // 可执行a.length = 0; // 可执行a = [&apos;Dave&apos;]; // 报错 如果真的想将对象冻结，应该使用Object.freeze方法。 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html语义化]]></title>
    <url>%2F2018%2F12%2F14%2Fhtml%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 为什么要语义化 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 写HTML代码时应注意什么 尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置。 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 HTML5新增了哪些语义标签在HTML5出来之前，我们用div来表示页面章节，但是这些div都没有实际意义。（即使我们用css样式的id和class形容这块内容的意义）。这些标签只是我们提供给浏览器的指令，只是定义一个网页的某些部分。但现在，那些之前没“意义”的标签因为html5的出现消失了，这就是我们平时说的“语义”。 看下图没有用div标签来布局 html5的布局嗯，如上图那个页面结构没有一个div，都是采用html5语义标签（用哪些标签，关键取决于你的设计目标）。 但是也不要因为html5新标签的出现，而随意用之，错误的使用肯定会事与愿违。所以有些地方还是要用div的，就是因为div没有任何意义的元素，他只是一个标签，仅仅是用来构建外观和结构。因此是最适合做容器的标签。 W3C定义了这些语义标签，不可能完全符合我们有时的设计目标，就像制定出来的法律不可能流传100年都不改变，更何况它才制定没多久，不可能这些语义标签对所以设计目标的适应。只是一定程度上的“通用”，我们的目标是让爬虫读懂重要的东西就够了。 结论：不能因为有了HTML5标签就弃用了div，每个事物都有它的独有作用的。 节点元素标签因使用的地方不同，我将他们分为：节元素标签、文本元素标签、分组元素标签分开来讲解HTML5中新增加的语义化标签和使用总结。 header元素header 元素代表“网页”或“section”的页眉。通常包含h1-h6元素或hgroup，作为整个页面或者一个内容块的标题。也可以包裹一节的目录部分，一个搜索框，一个nav，或者任何相关logo。 整个页面没有限制header元素的个数，可以拥有多个，可以为每个内容块增加一个header元素 123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;h1&gt;网站副标题&lt;/h1&gt; &lt;/hgroup&gt;&lt;/header&gt; header使用注意： 可以是“网页”或任意“section”的头部部分； 没有个数限制。 如果hgroup或h1-h6自己就能工作的很好，那就不要用header。 footer元素footer元素代表“网页”或“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。如果footer元素包含了整个节，那么它们就代表附录，索引，提拔，许可协议，标签，类别等一些其他类似信息。 123&lt;footer&gt; COPYRIGHT@zhengshikun&lt;/footer&gt; footer使用注意： 可以是“网页”或任意“section”的底部部分； 没有个数限制，除了包裹的内容不一样，其他跟header类似。 hgroup元素hgroup元素代表“网页”或“section”的标题，当元素有多个层级时，该元素可以将h1到h6元素放在其内，譬如文章的主标题和副标题的组合 1234&lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5语义化标签和更简洁的结构&lt;/h1&gt; &lt;h2&gt;HTML 5&lt;/h2&gt;&lt;/hgroup&gt; hgroup使用注意： 如果只需要一个h1-h6标签就不用hgroup 如果有连续多个h1-h6标签就用hgroup 如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签 nav元素nav元素代表页面的导航链接区域。用于定义页面的主要导航部分。 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;HTML 5&lt;/li&gt; &lt;li&gt;CSS3&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; nav使用注意： 用在整个页面主要导航部分上，不合适就不要用nav元素； aside元素aside元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。（特殊的section） 在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。 1234567&lt;article&gt; &lt;p&gt;内容&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;作者简介&lt;/h1&gt; &lt;p&gt;hello,world&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt; aside使用总结： aside在article内表示主要内容的附属信息， 在article之外则可做侧边栏，没有article与之对应，最好不用。 如果是广告，其他日志链接或者其他分类导航也可以用 section元素section元素代表文档中的“节”或“段”，“段”可以是指一篇文章里按照主题的分段；“节”可以是指一个页面里的分组。 section通常还带标题，虽然html5中section会自动给标题h1-h6降级，但是最好手动给他们降级。如下： 1234567891011&lt;section&gt; &lt;h1&gt;section是啥？&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;关于section&lt;/h1&gt; &lt;p&gt;section的介绍&lt;/p&gt; &lt;section&gt; &lt;h3&gt;关于其他&lt;/h3&gt; &lt;p&gt;关于其他section的介绍&lt;/p&gt; &lt;/section&gt; &lt;/article&gt;&lt;/section&gt; section使用注意： 一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。 表示文档中的节或者段； article、nav、aside可以理解为特殊的section，所以如果可以用article、nav、aside就不要用section，没实际意义的就用div article元素article元素最容易跟section和div容易混淆，其实article代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。（特殊的section） 除了它的内容，article会有一个标题（通常会在header里），会有一个footer页脚。我们举几个例子介绍一下article，好更好区分article、section、div 1234567&lt;article&gt; &lt;h1&gt;一篇文章&lt;/h1&gt; &lt;p&gt;文章内容..&lt;/p&gt; &lt;footer&gt; &lt;p&gt;&lt;small&gt;版权：html5jscss网所属，作者：小北&lt;/small&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt; 上例是最好简单的article标签使用情况，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论，如下： 12345678910111213141516171819202122232425262728293031&lt;article&gt; &lt;header&gt; &lt;h1&gt;一篇文章&lt;/h1&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2012-10-03&quot;&gt;2012/10/03&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;文章内容..&lt;/p&gt; &lt;article&gt; &lt;h2&gt;评论&lt;/h2&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论者: XXX&lt;/h3&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2012-10-03T19:10-08:00&quot;&gt;~1 hour ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;哈哈哈&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论者: XXX&lt;/h3&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2012-10-03T19:10-08:00&quot;&gt;~1 hour ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;哈？哈？哈？&lt;/p&gt; &lt;/article&gt; &lt;/article&gt;&lt;/article&gt; article内部嵌套article，有可能是评论或其他跟文章有关联的内容。那article内部嵌套section一般是什么情况呢。如下： 12345678910111213141516&lt;article&gt; &lt;h1&gt;前端技术&lt;/h1&gt; &lt;p&gt;前端技术有那些&lt;/p&gt; &lt;section&gt; &lt;h2&gt;CSS&lt;/h2&gt; &lt;p&gt;样式..&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;JS&lt;/h2&gt; &lt;p&gt;脚本&lt;/p&gt; &lt;/section&gt;&lt;/article&gt; 因为文章内section部分虽然也是独立的部分，但是它门只能算是组成整体的一部分，从属关系，article是大主体，section是构成这个大主体的一部分。本网站的全部文章都是article嵌套一个个section章节，这样能让浏览器更容易区分各个章节所包括的内容。 那section内部嵌套article又有哪些情况呢，如下 1234567891011121314151617181920&lt;section&gt; &lt;h1&gt;介绍: 网站制作成员配备&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;设计师&lt;/h2&gt; &lt;p&gt;设计网页的...&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;程序员&lt;/h2&gt; &lt;p&gt;后台写程序的..&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;前端工程师&lt;/h2&gt; &lt;p&gt;给楼上两位打杂的..&lt;/p&gt; &lt;/article&gt;&lt;/section&gt; 设计师、程序员、前端工程师都是一个独立的整体，他们组成了网站制作基本配备，当然还有其他成员~。设计师、程序员、前端工程师就像article，是一个个独立的整体，而section将这些自成一体的article包裹，就组成了一个团体。 article和section和例子就例举这么多了，具体情况具体分析，不易深究。漏了div，其实div就是只是想用来把元素组合或者给它们加样式时使用。 article使用注意： 自身独立的情况下：用article 是相关内容：用section 没有语义的：用div HTML5其他结构元素标签HTML5节元素标签包括body article nav aside section header footer hgroup ，还有h1-h6 address。 address代表区块容器，必须是作为联系信息出现，邮编地址、邮件地址等等,一般出现在footer。 h1-h6因为hgroup，section和article的出现，h1-h6定义也发生了变化，允许一张页面出现多个h1。 原文：https://www.cnblogs.com/fliu/articles/5244866.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass基本用法]]></title>
    <url>%2F2018%2F12%2F13%2Fsass%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 使用变量sass使用$符号来标识变量,比如$highlight-color和$sidebar-width。 变量声明sass变量的声明和css属性的声明很像： 12$highlight-color: #F90;$basic-border: 1px solid black; 这时变量还没有生效，除非你引用这个变量 变量引用12345678910111213$nav-color: #F90;nav &#123; $width: 100px; width: $width; color: $nav-color;&#125;//编译后nav &#123; width: 100px; color: #F90;&#125; $width这个变量定义在了nav的{ }规则块内，所以它只能在nav规则块内使用。 变量名用中划线还是下划线分隔sass并不想强迫任何人一定使用中划线或下划线，所以这两种用法相互兼容。用中划线声明的变量可以使用下划线的方式引用，反之亦然。这意味着即使compass选择用中划线的命名方式，这并不影响你在使用compass的样式中用下划线的命名方式进行引用： 12345678910$link-color: blue;a &#123; color: $link_color;&#125;//编译后a &#123; color: blue;&#125; 嵌套CSS 规则1234#content &#123; background-color: #f5f5f5; aside &#123; background-color: #eee &#125;&#125; 123 /* 编译后 */#content &#123; background-color: #f5f5f5 &#125;#content aside &#123; background-color: #eee &#125; 大多数情况下这种简单的嵌套都没问题，但是有些场景下不行，比如你想要在嵌套的选择器 里边立刻应用一个类似于:hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构&amp;。 父选择器的标识符&amp;一般情况下，sass在解开一个嵌套规则时就会把父选择器（#content）通过一个空格连接到子选择器的前边（article和aside）形成（#content article和#content aside）。这种在CSS里边被称为后代选择器，因为它选择ID为content的元素内所有命中选择器article和aside的元素。但在有些情况下你却不会希望sass使用这种后代选择器的方式生成这种连接。 1234article a &#123; color: blue; :hover &#123; color: red &#125;&#125; 上面的无法正常工作，解决之道为使用一个特殊的sass选择器，即父选择器。在使用嵌套规则时，父选择器能对于嵌套规则如何解开提供更好的控制。它就是一个简单的&amp;符号。 1234article a &#123; color: blue; &amp;:hover &#123; color: red &#125;&#125; 当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&amp;被父选择器直接替换： 123/* 编译后 */article a &#123; color: blue &#125;article a:hover &#123; color: red &#125; 群组选择器的嵌套123.container &#123; h1, h2, h3 &#123;margin-bottom: .8em&#125;&#125; 12/* 编译后 */.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125; 123nav, aside &#123; a &#123;color: blue&#125;&#125; 12/* 编译后 */nav a, aside a &#123;color: blue&#125; 有利必有弊，你需要特别注意群组选择器的规则嵌套生成的css。虽然sass让你的样式表看上去很小，但实际生成的css却可能非常大，这会降低网站的速度。 子组合选择器和同层组合选择器：&gt;、+和~可以把它们放在外层选择器后边，或里层选择器前边： 123456789article &#123; ~ article &#123; border-top: 1px dashed #ccc &#125; &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; nav + &amp; &#123; margin-top: 0 &#125;&#125; 123456/* 编译后 */article ~ article &#123; border-top: 1px dashed #ccc &#125;article &gt; footer &#123; background: #eee &#125;article dl &gt; dt &#123; color: #333 &#125;article dl &gt; dd &#123; color: #555 &#125;nav + article &#123; margin-top: 0 &#125; 嵌套属性123456nav &#123; border: 1px solid #ccc &#123; left: 0px; right: 0px; &#125;&#125; 123456/* 编译后 */nav &#123; border: 1px solid #ccc; border-left: 0px; border-right: 0px;&#125; 导入SASS文件使用sass的@import规则并不需要指明被导入文件的全名。你可以省略.sass或.scss文件后缀（见下图）。这样，在不修改样式表的前提下，你完全可以随意修改你或别人写的被导入的sass样式文件语法，在sass和scss语法之间随意切换。举例来说，@import“sidebar”;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。 使用SASS部分文件当通过@import把sass样式分散到多个文件时，你通常只想生成少数几个css文件。那些专门为@import命令而编写的sass文件，并不需要生成对应的独立css文件，这样的sass文件称为局部文件。对此，sass有一个特殊的约定来命名这些文件。 此约定即，sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。当你@import一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。举例来说，你想导入themes/_night-sky.scss这个局部文件里的变量，你只需在样式表中写@import &quot;themes/night-sky&quot;;。 局部文件可以被多个不同的文件引用。当一些样式需要在多个页面甚至多个项目中使用时，这非常有用。在这种情况下，有时需要在你的样式表中对导入的样式稍作修改，sass有一个功能刚好可以解决这个问题，即默认变量值。 默认变量值一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明： 12345$link-color: blue;$link-color: red;a &#123;color: $link-color;&#125; 在上边的例子中，超链接的color会被设置为red。这可能并不是你想要的结果，假如你写了一个可被他人通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值。使用sass的!default标签可以实现这个目的。它很像css属性中!important标签的对立面，不同的是!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。 1234$fancybox-width: 400px !default;.fancybox &#123;width: $fancybox-width;&#125; 嵌套导入跟原生的css不同，sass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方。举例说明，有一个名为_blue-theme.scss的局部文件，内容如下： 1234aside &#123; background: blue; color: white;&#125; 然后把它导入到一个CSS规则内，如下所示： 12345678910.blue-theme &#123;@import &quot;blue-theme&quot;&#125;//生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。.blue-theme &#123; aside &#123; background: blue; color: #fff; &#125;&#125; 被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效。这些变量和混合器不会全局有效，这样我们就可以通过嵌套导入只对站点中某一特定区域运用某种颜色主题或其他通过变量配置的样式。 原生的CSS导入由于sass兼容原生的css，所以它也支持原生的CSS@import。尽管通常在sass中使用@import时，sass会尝试找到对应的sass文件并导入进来，但在下列三种情况下会生成原生的CSS@import，尽管这会造成浏览器解析css时的额外下载： 被导入文件的名字以.css结尾； 被导入文件的名字是一个URL地址 被导入文件的名字是CSS的url()值。 静默注释sass另外提供了一种不同于css标准注释格式/* ... */的注释语法，即静默注释，其内容不会出现在生成的css文件中。静默注释的语法跟JavaScript`Java等类C的语言中单行注释的语法相同，它们以//`开头，注释内容直到行末。 1234body &#123; color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */&#125; 混合器混合器使用@mixin标识符定义。看上去很像其他的CSS @标识符，比如说@media或者@font-face。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段sass代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。 12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 然后就可以在你的样式表中通过@include来使用这个混合器，放在你希望的任何地方。@include调用会把混合器中的所有样式提取出来放在@include被调用的地方。如果像下边这样写： 12345notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125; 12345678//sass最终生成：.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 通过使用参数，你可以使用混合器把你样式中的通用样式抽离出来，然后轻松地在其他地方重用。 何时使用混合器.notice是一个有语义的类名。如果一个html元素有一个notice的类名，就表明了这个html元素的用途：向用户展示提醒信息。rounded-corners混合器是展示性的，它描述了包含它的css规则最终的视觉样式，尤其是边框角的视觉样式。混合器和类配合使用写出整洁的html和css，因为使用语义化的类名亦可以帮你避免重复使用混合器。为了保持你的html和css`的易读性和可维护性，在写样式的过程中一定要铭记二者的区别。 混合器中的CSS规则混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性 12345678@mixin no-bullets &#123; list-style: none; li &#123; list-style-image: none; list-style-type: none; margin-left: 0px; &#125;&#125; 1234ul.plain &#123; color: #444; @include no-bullets;&#125; sass的@include指令会将引入混合器的那行代码替换成混合器里边的内容 12345678910/* 编译后 */ul.plain &#123; color: #444; list-style: none;&#125;ul.plain li &#123; list-style-image: none; list-style-type: none; margin-left: 0px;&#125; 混合器中的规则甚至可以使用sass的父选择器标识符&amp;。使用起来跟不用混合器时一样，sass解开嵌套规则时，用父规则中的选择器替代&amp;。 给混合器传参如果你写过JavaScript，这种方式跟JavaScript的function很像： 12345@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 当混合器被@include时，你可以把它当作一个css函数来传参。 123456789a &#123; @include link-colors(blue, red, green);&#125;//Sass最终生成的是：a &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 当你@include混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，sass允许通过语法$name: value的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可： 1234567a &#123; @include link-colors( $normal: blue, $visited: green, $hover: red );&#125; 默认参数值为了在@include混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用$name: default-value的声明形式，默认值可以是任何有效的css属性值，甚至是其他参数的引用，如下代码： 12345678910@mixin link-colors( $normal, $hover: $normal, $visited: $normal )&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 如果像下边这样调用：@include link-colors(red) $hover和$visited也会被自动赋值为red。 使用选择器继承来精简CSS使用sass的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan面向对象的css的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现，如下代码: 123456789//通过选择器继承继承样式.error &#123; border: 1px solid red; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 何时使用继承 想象一下你正在编写一个页面，给html元素添加类名，你发现你的某个类（比如说.seriousError）另一个类（比如说.error）的细化。你会怎么做？ 你可以为这两个类分别写相同的样式，但是如果有大量的重复怎么办？使用sass时，我们提倡的就是不要做重复的工作。 你可以使用一个选择器组（比如说.error`.seriousError）给这两个选择器写相同的样式。如果.error`的所有样式都在同一个地方，这种做法很好，但是如果是分散在样式表的不同地方呢？再这样做就困难多了。 你可以使用一个混合器为这两个类提供相同的样式，但当.error的样式修饰遍布样式表中各处时，这种做法面临着跟使用选择器组一样的问题。这两个类也不是恰好有相同的 样式。你应该更清晰地表达这种关系。 综上所述你应该使用@extend。让.seriousError从.error继承样式，使两者之间的关系非常清晰。更重要的是无论你在样式表的哪里使用.error`.seriousError`都会继承其中的样式。 继承的高级用法任何css规则都可以继承其他规则，几乎任何css规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个html元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对html元素添加的所有样式都会被继承。 继承的工作细节关于@extend有两个要点你应该知道。 跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。 继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，css层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。 使用继承的最佳实践通常使用继承会让你的css美观、整洁。因为继承只会在生成css时复制选择器，而不会复制大段的css属性。但是如果你不小心，可能会让生成的css中包含大量的选择器复制。 小结本文介绍了sass最基本部分,你可以轻松地使用sass编写清晰、无冗余、语义化的css。对于sass提供的工具你已经有了一个比较深入的了解，同时也掌握了何时使用这些工具的指导原则。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>sass</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端代码规范]]></title>
    <url>%2F2018%2F12%2F12%2Fweb%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[此项目用于记录规范的、高可维护性的前端代码，这是通过分析 Github 众多前端代码库，总结出来的前端代码书写规范。 前端普适性规范黄金定律不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的。 永远遵循同一套编码规范，可以是这里列出的，也可以是你自己总结的。 项目命名项目名全部采用小写方式，以中划线分隔，禁止驼峰式命名。比如：my-project-name 文件命名文件命名参照项目命名规则。比如: error-report.html 有复数结构时，要采用复数命名法，比如： scripts, styles, images, data-models 文件名中只可由小写英文字母 az 、排序数字 09 或间隔符 - 组成，禁止包含特殊符号，比如空格、`$` 等 为了醒目，某些说明文件的文件名，可以使用大写字母，比如: README, LICENSE 为更好的表达语义，文件名使用英文名词命名，或英文简写。 不允许命名带有广告等英文的单词，例如ad,adv,adver,advertising，防止该模块被浏览器当成垃圾广告过滤掉。任何文件的命名均如此。 文件常用命名: index.shtml 引导页&amp;首页 main.shtml 首页 download.shtml 下载页面 act.html 活动列表页面 video.html 视频 cdkey.html CDKEY页面 base.css 基本样式 layout.css 框架布局 module.css 模块样式 global.css 全局样式 font.css 字体样式 index.css 首页样式 link.css 链接样式 print.css 打印样式 HTML 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 嵌套的节点应该缩进（四个空格）。 在属性上，使用双引号，不要使用单引号。 不要在自动闭合标签结尾处使用斜线 / - HTML5 规范 指出他们是可选的。 1&lt;img src=&quot;images/logo.png&quot; alt=&quot;Company&quot;&gt; 不要忽略可选的关闭标签（例如，&lt;/li&gt; 和 &lt;/body&gt;）。 HTML5 doctype在每个 HTML 页面开头使用这个简单地 doctype 来启用标准模式，使其每个浏览器中尽可能一致的展现。 虽然 doctype 不区分大小写，但是按照惯例，doctype 大写 1&lt;!DOCTYPE html&gt; 语言属性123&lt;html lang=&quot;en&quot;&gt;&lt;/html&gt; 字符编码通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。这样 做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与 文档编码一致（一般采用 UTF-8 编码）。 1&lt;meta charset=&quot;UTF-8&quot;&gt; IE 兼容模式IE 支持通过特定的 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈 的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的模 式。 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 响应式1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 引入 CSS 和 JavaScript根据 HTML5 规范, 通常在引入 CSS 和 JavaScript 时不需要指明 type，因为 text/css 和 text/javascript 分别是他们的默认值。 12345678910&lt;!-- External CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;code-guide.css&quot;&gt;&lt;!-- In-document CSS --&gt;&lt;style&gt; /* ... */&lt;/style&gt;&lt;!-- JavaScript --&gt;&lt;script src=&quot;code-guide.js&quot;&gt;&lt;/script&gt; 实用高于完美尽量遵循 HTML 标准和语义，但是不应该以浪费实用性作为代价。任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。 减少标签数量在编写 HTML 代码时，需要尽量避免多余的父节点。很多时候，需要通过迭代和重构来使 HTML 变得更少。 参考下面的示例: 1234567&lt;!-- Not so great --&gt;&lt;span class=&quot;avatar&quot;&gt; &lt;img src=&quot;...&quot;&gt;&lt;/span&gt;&lt;!-- Better --&gt;&lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt; 属性顺序HTML 属性应该按照特定的顺序出现以保证易读性。 class id name data-* src, for, type, href, value , max-length, max, min, pattern placeholder, title, alt aria-*, role required, readonly, disabled class 是为高可复用组件设计的，理论上他们应处在第一位。id 更加具体而且应该尽量少使用（例如, 页内书签），所以他们处在第二位。 Boolean 属性Boolean 属性指不需要声明取值的属性。XHTML 需要每个属性声明取值，但是 HTML5 并不需要。 一个元素中 Boolean 属性的存在表示取值 true，不存在则表示取值 false。 简而言之，不要为 Boolean 属性添加取值。 1&lt;input type=&quot;text&quot; disabled&gt; JavaScript 生成标签在 JavaScript 文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免这种情况的出现。 CSS 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 使用组合选择器时，保持每个独立的选择器占用一行。 为了代码的易读性，在每个声明的左括号前增加一个空格。 声明块的右括号应该另起一行。 每条声明 : 后应该插入一个空格。 每条声明应该只占用一行来保证错误报告更加准确。 所有声明应该以分号结尾。虽然最后一条声明后的分号是可选的，但是如果没有他，你的代码会更容易出错。 逗号分隔的取值，都应该在逗号之后增加一个空格。 不要在颜色值 rgb() rgba() hsl() hsla()和 rect() 中增加空格，并且不要带有取值前面不必要的 0 (比如，使用 .5 替代 0.5)。 所有的十六进制值都应该使用小写字母，例如 #fff。因为小写字母有更多样的外形，在浏览文档时，他们能够更轻松的被区分开来。 尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。 为选择器中的属性取值添加引号，例如 input[type=&quot;text&quot;]。 他们只在某些情况下可有可无，所以都使用引号可以增加一致性。 不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;。 123456789101112131415/* Bad CSS */.selector, .selector-secondary, .selector[type=text] &#123; margin: 0px 0px 15px; background-color: rgba(0, 0, 0, 0.5); box-shadow: 0 1px 2px #CCC, inset 0 1px 0 #FFFFFF&#125;/* Good CSS */.selector,.selector-secondary,.selector[type=&quot;text&quot;] &#123; margin-bottom: 15px; background-color: rgba(0,0,0,.5); box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;&#125; 声明顺序相关的属性声明应该以下面的顺序分组处理： Positioning Box model 盒模型 Typographic 排版 Visual 外观 Positioning 处在第一位，因为他可以使一个元素脱离正常文本流，并且覆盖盒模型相关的样式。盒模型紧跟其后，因为他决定了一个组件的大小和位置。 其他属性只在组件内部起作用或者不会对前面两种情况的结果产生影响，所以他们排在后面。 1234567891011121314151617181920212223242526272829.declaration-order &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box-model */ display: block; float: right; width: 100px; height: 100px; /* Typography */ font: normal 13px &quot;Helvetica Neue&quot;, sans-serif; line-height: 1.5; color: #333; text-align: center; /* Visual */ background-color: #f5f5f5; border: 1px solid #e5e5e5; border-radius: 3px; /* Misc */ opacity: 1;&#125; Don’t use @import与&lt;link&gt;相比，@import较慢，增加额外的页面请求，并可能导致其他不可预见的问题。 1234567&lt;!-- Use link elements --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;core.css&quot;&gt;&lt;!-- Avoid @imports --&gt;&lt;style&gt; @import url(&quot;more.css&quot;);&lt;/style&gt; 媒体查询位置尽量将媒体查询的位置靠近他们相关的规则。不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部。这样做只会让大家以后更容易忘记他们。这里是一个典型的案例。 123456789.element &#123; ... &#125;.element-avatar &#123; ... &#125;.element-selected &#123; ... &#125;@media (min-width: 480px) &#123; .element &#123; ...&#125; .element-avatar &#123; ... &#125; .element-selected &#123; ... &#125;&#125; 前缀属性当使用厂商前缀属性时，通过缩进使取值垂直对齐以便多行编辑。 12345/* Prefixed properties */.selector &#123; -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15); box-shadow: 0 1px 2px rgba(0,0,0,.15);&#125; 单条声明的声明块在一个声明块中只包含一条声明的情况下，为了易读性和快速编辑可以考虑移除其中的换行。所有包含多条声明的声明块应该分为多行。 这样做的关键因素是错误检测 - 例如，一个 CSS 验证程序显示你在 183 行有一个语法错误,如果是一个单条声明的行，那就是他了。在多个声明的情况下，你必须为哪里出错了费下脑子。 123.span1 &#123; width: 60px; &#125;.span2 &#123; width: 140px; &#125;.span3 &#123; width: 220px; &#125; 属性简写尽量不使用属性简写的方式，属性简写需要你必须显式设置所有取值。常见的属性简写滥用包括: padding margin font background -border -border-radius 大多数情况下，我们并不需要设置属性简写中包含的所有值。例如，HTML 头部只设置上下的 margin，所以如果需要，只设置这两个值。过度使用属性简写往往会导致更混乱的代码，其中包含不必要的重写和意想不到的副作用。 12345678910111213141516/* Bad example */.element &#123; margin: 0 0 10px; background: red; background: url(&quot;image.jpg&quot;); border-radius: 3px 3px 0 0;&#125;/* Good example */.element &#123; margin-bottom: 10px; background-color: red; background-image: url(&quot;image.jpg&quot;); border-top-left-radius: 3px; border-top-right-radius: 3px;&#125; Less 和 Sass 中的嵌套避免不必要的嵌套。可以进行嵌套，不意味着你应该这样做。只有在需要给父元素增加样式并且同时存在多个子元素时才需要考虑嵌套。 123456789// Without nesting.table &gt; thead &gt; tr &gt; th &#123; … &#125;.table &gt; thead &gt; tr &gt; td &#123; … &#125;// With nesting.table &gt; thead &gt; tr &#123; &gt; th &#123; … &#125; &gt; td &#123; … &#125;&#125; 代码注释代码是由人来编写和维护的。保证你的代码是描述性的，包含好的注释，并且容易被他人理解。好的代码注释传达上下文和目标。不要简单地重申组件或者 class 名称。 class 命名保持 class 命名为全小写，可以使用短划线（不要使用下划线和 camelCase 命名）。短划线应该作为相关类的自然间断。(例如，.btn 和 .btn-danger)。 避免过度使用简写。.btn 可以很好地描述 button，但是 .s 不能代表任何元素。 class 的命名应该尽量短，也要尽量明确。 使用有意义的名称；使用结构化或者作用目标相关，而不是抽象的名称。 命名时使用最近的父节点或者父 class 作为前缀。 使用 .js-* 来表示行为(相对于样式)，但是不要在 CSS 中包含这些 class。 选择器使用 class 而不是通用元素标签来优化渲染性能。 避免在经常出现的组件中使用一些属性选择器 (例如，[class^=&quot;...&quot;])。浏览器性能会受到这些情况的影响。 减少选择器的长度，每个组合选择器选择器的条目应该尽量控制在 3 个以内。 只在必要的情况下使用后代选择器 (例如，没有使用带前缀 classes 的情况). 代码组织以组件为单位组织代码。 制定一个一致的注释层级结构。 使用一致的空白来分割代码块，这样做在查看大的文档时更有优势。 当使用多个 CSS 文件时，通过组件而不是页面来区分他们。页面会被重新排列，而组件移动就可以了。 编辑器配置根据以下的设置来配置你的编辑器，将这些设置应用到项目的 .editorconfig 文件，来避免常见的代码不一致和丑陋的 diffs。 使用四个空格的缩进。 在保存时删除尾部的空白字符。 设置文件编码为 UTF-8。 在文件结尾添加一个空白行。 JS 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 声明之后一律以分号结束， 不可以省略 完全避免 == != 的使用， 用严格比较条件 === !== eval 非特殊情况， 禁用！！！ with 非特殊情况， 禁用！！！ 单行长度，理论上不要超过80列，不过如果编辑器开启”自动换行”的话可以不考虑单行长度 接上一条，如果需要换行，存在操作符的情况，一定在操作符后换行，然后换的行缩进4个空格 这里要注意，如果是多次换行的话就没有必要继续缩进了，比如说下面这种就是最佳格式。 1234567if (typeof qqfind === &quot;undefined&quot; || typeof qqfind.cdnrejected === &quot;undefined&quot; || qqfind.cdnrejected !== true) &#123; url = &quot;http://pub.idqqimg.com/qqfind/js/location4.js&quot;;&#125; else &#123; url = &quot;http://find.qq.com/js/location4.js&quot;;&#125; 空行方法之间加 单行或多行注释前加 逻辑块之间加空行增加可读性 变量命名标准变量采用驼峰标识 使用的ID的地方一定全大写 使用的URL的地方一定全大写, 比如说 reportURL 涉及Android的，一律大写第一个字母 涉及iOS的，一律小写第一个，大写后两个字母 常量采用大写字母，下划线连接的方式 构造函数，大写第一个字母 12345678910111213var thisIsMyName;var goodID;var AndroidVersion;var iOSVersion;var MAX_COUNT = 10;function Person(name) &#123; this.name = name&#125; 字符常量一般情况下统一使用单引号 null的使用场景初始化可能以后分配对象值的变量 与一个可能或可能没有对象值的初始化变量进行比较 传入一个预期对象的函数 从预期对象的函数返回 不适合null的使用场景不要使用null来测试是否提供参数 不要测试值为null的未初始化变量 undefined使用场景永远不要直接使用undefined进行变量判断 使用字符串 &quot;undefined&quot; 对变量进行判断 123456// Badvar person;console.log(person === undefined); //true// Goodconsole.log(typeof person); // &quot;undefined&quot; 对象字面量12345678910// Badvar team = new Team();team.title = &quot;AlloyTeam&quot;;team.count = 25;// Goodvar team = &#123; title: &quot;AlloyTeam&quot;, count: 25&#125;; 数组声明12345678// Badvar colors = new Array(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;);var numbers = new Array(1, 2, 3, 4);// Goodvar colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];var numbers = [ 1, 2, 3, 4 ]; 单行注释双斜线后，必须跟注释内容保留一个空格 与下一行代码缩进保持一致 可位于一个代码行的末尾，双斜线距离分号四个空格 1234567// Goodif (condition) &#123; // if you made it here, then all security checks passed allowed();&#125;var zhangsan = &quot;zhangsan&quot;; // 双斜线距离分号四个空格，双斜线后始终保留一个空格 多行注释格式最少三行 前边留空一行 123/** * 注释内容与星标前保留一个空格 */ 何时使用多行注释格式难于理解的代码段 可能存在错误的代码段 浏览器特殊的HACK代码 业务逻辑强相关的代码 想吐槽的产品逻辑, 合作同事 文档注释各类标签 @param @method 等 参考 http://usejsdoc.org/ 用于：方法、构造函数、对象 123456/** * here boy, look here , here is girl * @method lookGril * @param &#123;Object&#125; balabalabala * @return &#123;Object&#125; balabalabala */ 括号对齐标准示例 括号前后有空格，花括号起始不另换行，结尾新起一行 花括号必须要，即使内容只有一行 涉及 if for while do...while try...catch...finally 的地方都必须使用花括号，即使内容只有一行 if else 前后留有空格12345if (condition) &#123; doSomething();&#125; else &#123; doSomethingElse();&#125; switchswitch和括号之间有空格，case需要缩进，break之后跟下一个case中间留一个空白行 花括号必须要， 即使内容只有一行。 switch 的 falling through 一定要有注释特别说明，no default 的情况也需要注释特别说明况 123456789101112switch (condition) &#123; case &quot;first&quot;: // code break; case &quot;second&quot;: // code break; default: // code&#125; for普通for循环, 分号后留有一个空格， 判断条件等内的操作符两边不留空格 前置条件如果有多个，逗号后留一个空格 for-in 一定要有 hasOwnProperty 的判断， 否则 JSLint 或者 JSHint 都会有一个 warn 1234567891011121314for (i=0, len=values.length; i&lt;len; i++) &#123; process(values[i]);&#125;var prop;for (prop in object) &#123; // 注意这里一定要有 hasOwnProperty 的判断， 否则 JSLint 或者 JSHint 都会有一个 warn ！ if (object.hasOwnProperty(prop)) &#123; console.log(&quot;Property name is &quot; + prop); console.log(&quot;Property value is &quot; + object[prop]); &#125;&#125; 变量声明所有函数内变量声明放在函数内头部，只使用一个 var(多了JSLint报错)， 一个变量一行， 在行末跟注释， 注释啊，注释啊，亲 函数声明一定先声明再使用， 不要利用 JavaScript engine的变量提升特性, 违反了这个规则 JSLint 和 JSHint都会报 warn function declaration 和 function expression 的不同，function expression 的（）前后必须有空格，而function declaration 在有函数名的时候不需要空格，没有函数名的时候需要空格。 函数调用括号前后不需要空格 立即执行函数的写法, 最外层必须包一层括号 &quot;use strict&quot; 决不允许全局使用， 必须放在函数的第一行， 可以用自执行函数包含大的代码段, 如果 &quot;use strict&quot; 在函数外使用， JSLint 和 JSHint 均会报错 1234567891011121314151617181920212223function doSomething(item) &#123; // do something&#125;var doSomething = function (item) &#123; // do something&#125;// GooddoSomething(item);// Bad: Looks like a block statementdoSomething (item);// Good(function() &#123; &quot;use strict&quot;; function doSomething() &#123; // code &#125;&#125;)(); 结尾规范当然不是我写的啦，哈哈哈哈~ 原文是：https://github.com/bxm0927/web-code-standards]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>规范</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode快捷键]]></title>
    <url>%2F2018%2F12%2F12%2Fvscode%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[如标题所说的，vscode的快捷键。中英文对照。 常用 General 按 Press 功能 Function Ctrl + Shift + P，F1 显示命令面板 Show Command Palette Ctrl + P 快速打开 Quick Open Ctrl + Shift + N 新窗口/实例 New window/instance Ctrl + Shift + W 关闭窗口/实例 Close window/instance 基础编辑 Basic editing 按 Press 功能 Function Ctrl+X 剪切行（空选定） Cut line (empty selection) Ctrl+C 复制行（空选定）Copy line (empty selection) Alt+ ↑ / ↓ 向上/向下移动行 Move line up/down Shift+Alt + ↓ / ↑ 向上/向下复制行 Copy line up/down Ctrl+Shift+K 删除行 Delete line Ctrl+Enter 在下面插入行 Insert line below Ctrl+Shift+Enter 在上面插入行 Insert line above Ctrl+Shift+\ 跳到匹配的括号 Jump to matching bracket Ctrl+] / [ 缩进/缩进行 Indent/outdent line Home 转到行首 Go to beginning of line End 转到行尾 Go to end of line Ctrl+Home 转到文件开头 Go to beginning of file Ctrl+End 转到文件末尾 Go to end of file Ctrl+↑ / ↓ 向上/向下滚动行 Scroll line up/down Alt+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Shift+[ 折叠（折叠）区域 Fold (collapse) region Ctrl+Shift+] 展开（未折叠）区域 Unfold (uncollapse) region Ctrl+K Ctrl+[ 折叠（未折叠）所有子区域 Fold (collapse) all subregions Ctrl+K Ctrl+] 展开（未折叠）所有子区域 Unfold (uncollapse) all subregions Ctrl+K Ctrl+0 折叠（折叠）所有区域 Fold (collapse) all regions Ctrl+K Ctrl+J 展开（未折叠）所有区域 Unfold (uncollapse) all regions Ctrl+K Ctrl+C 添加行注释 Add line comment Ctrl+K Ctrl+U 删除行注释 Remove line comment Ctrl+/ 切换行注释 Toggle line comment Shift+Alt+A 切换块注释 Toggle block comment Alt+Z 切换换行 Toggle word wrap 导航 Navigation 按 Press 功能 Function Ctrl + T 显示所有符号 Show all Symbols Ctrl + G 转到行… Go to Line… Ctrl + P 转到文件… Go to File… Ctrl + Shift + O 转到符号… Go to Symbol… Ctrl + Shift + M 显示问题面板 Show Problems panel F8 转到下一个错误或警告 Go to next error or warning Shift + F8 转到上一个错误或警告 Go to previous error or warning Ctrl + Shift + Tab 导航编辑器组历史记录 Navigate editor group history Alt + ←/→ 返回/前进 Go back / forward Ctrl + M 切换选项卡移动焦点 Toggle Tab moves focus 搜索和替换 Search and replace 按 Press 功能 Function Ctrl + F 查找 Find Ctrl + H 替换 Replace F3 / Shift + F3 查找下一个/上一个 Find next/previous Alt + Enter 选择查找匹配的所有出现 Select all occurences of Find match Ctrl + D 将选择添加到下一个查找匹配 Add selection to next Find match Ctrl + K Ctrl + D 将最后一个选择移至下一个查找匹配项 Move last selection to next Find match Alt + C / R / W 切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word 多光标和选择 Multi-cursor and selection 按 Press 功能 Function Alt +单击 插入光标 Insert cursor Ctrl + Alt +↑/↓ 在上/下插入光标 Insert cursor above / below Ctrl + U 撤消上一个光标操作 Undo last cursor operation Shift + Alt + I 在选定的每一行的末尾插入光标 Insert cursor at end of each line selected Ctrl + I 选择当前行 Select current line Ctrl + Shift + L 选择当前选择的所有出现 Select all occurrences of current selection Ctrl + F2 选择当前字的所有出现 Select all occurrences of current word Shift + Alt + → 展开选择 Expand selection Shift + Alt + ← 缩小选择 Shrink selection Shift + Alt + （拖动鼠标） 列（框）选择 Column (box) selection Ctrl + Shift + Alt +（箭头键） 列（框）选择 Column (box) selection Ctrl + Shift + Alt + PgUp / PgDown 列（框）选择页上/下 Column (box) selection page up/down 丰富的语言编辑 Rich languages editing 按 Press 功能 Function Ctrl + 空格 触发建议 Trigger suggestion Ctrl + Shift + Space 触发器参数提示 Trigger parameter hints Tab Emmet展开缩写 Emmet expand abbreviation Shift + Alt + F 格式化文档 Format document Ctrl + K Ctrl + F 格式选定区域 Format selection F12 转到定义 Go to Definition Alt + F12 Peek定义 Peek Definition Ctrl + K F12 打开定义到边 Open Definition to the side Ctrl + . 快速解决 Quick Fix Shift + F12 显示引用 Show References F2 重命名符号 Rename Symbol Ctrl + K Ctrl + X 修剪尾随空格 Trim trailing whitespace Ctrl + K M 更改文件语言 Change file language 编辑器管理 Editor management 按 Press 功能 Function Ctrl+F4, Ctrl+W 关闭编辑器 Close editor Ctrl+K F 关闭文件夹 Close folder Ctrl+\ 拆分编辑器 Split editor Ctrl+ 1 / 2 / 3 聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group Ctrl+K Ctrl+ ←/→ 聚焦到上一个/下一个编辑器组 Focus into previous/next editor group Ctrl+Shift+PgUp / PgDown 向左/向右移动编辑器 Move editor left/right Ctrl+K ← / → 移动活动编辑器组 Move active editor group 文件管理 File management 按 Press 功能 Function Ctrl+N 新文件 New File Ctrl+O 打开文件… Open File… Ctrl+S 保存 Save Ctrl+Shift+S 另存为… Save As… Ctrl+K S 全部保存 Save All Ctrl+F4 关闭 Close Ctrl+K Ctrl+W 关闭所有 Close All Ctrl+Shift+T 重新打开关闭的编辑器 Reopen closed editor Ctrl+K 输入保持打开 Enter Keep Open Ctrl+Tab 打开下一个 Open next Ctrl+Shift+Tab 打开上一个 Open previous Ctrl+K P 复制活动文件的路径 Copy path of active file Ctrl+K R 显示资源管理器中的活动文件 Reveal active file in Explorer Ctrl+K O 显示新窗口/实例中的活动文件 Show active file in new window/instance 显示 Display 按 Press 功能 Function F11 切换全屏 Toggle full screen Shift+Alt+1 切换编辑器布局 Toggle editor layout Ctrl+ = / - 放大/缩小 Zoom in/out Ctrl+B 切换侧栏可见性 Toggle Sidebar visibility Ctrl+Shift+E 显示浏览器/切换焦点 Show Explorer / Toggle focus Ctrl+Shift+F 显示搜索 Show Search Ctrl+Shift+G 显示Git Show Git Ctrl+Shift+D 显示调试 Show Debug Ctrl+Shift+X 显示扩展 Show Extensions Ctrl+Shift+H 替换文件 Replace in files Ctrl+Shift+J 切换搜索详细信息 Toggle Search details Ctrl+Shift+C 打开新命令提示符/终端 Open new command prompt/terminal Ctrl+Shift+U 显示输出面板 Show Output panel Ctrl+Shift+V 切换Markdown预览 Toggle Markdown preview Ctrl+K V 从旁边打开Markdown预览 Open Markdown preview to the side 调试 Debug 按 Press 功能 Function F9 切换断点 Toggle breakpoint F5 开始/继续 Start/Continue Shift+F5 停止 Stop F11 / Shift+F11 下一步/上一步 Step into/out F10 跳过 Step over Ctrl+K Ctrl+I 显示悬停 Show hover 集成终端 Integrated terminal 按 Press 功能 Function Ctrl+` 显示集成终端 Show integrated terminal Ctrl+Shift+` 创建新终端 Create new terminal Ctrl+Shift+C 复制选定 Copy selection Ctrl+Shift+V 粘贴到活动端子 Paste into active terminal Ctrl+↑ / ↓ 向上/向下滚动 Scroll up/down Shift+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Home / End 滚动到顶部/底部 Scroll to top/bottom 结尾原文是：https://segmentfault.com/a/1190000007688656]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode插件]]></title>
    <url>%2F2018%2F12%2F11%2Fvscode%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Visual Studio Code（以下简称vscode）是一个轻量且强大的代码编辑器，支持Windows，OS X和Linux。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。 插件推荐 插件 说明 ComputerAuto Close Tag 自动添加HTML / XML关闭标签 Auto Rename Tag 自动重命名配对的HTML / XML标签 Beautify 格式化代码 Bracket Pair Colorizer 颜色识别匹配括号 Code Runner 能够运行多种语言的代码片段或代码文件 Chinese (Simplified) Language Pack for Visual Studio Code 中文简体包 Color Info 为你提供你在 CSS 中使用颜色的相关信息。 CSS Peek 可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码 Debugger for Chrome 前端调试, 查看使用方法 ESLint EsLint可以帮助我们检查Javascript编程时的语法错误。 filesize 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间 Git History 以图表的形式查看 git 日志 GitLens — Git supercharged 显示文件最近的 commit 和作者，显示当前行 commit 信息 HTML Boilerplate 通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构 HTMLHint HTML 代码格式检测 HTML Snippets 代码自动填充 htmltagwrap 在选中HTML标签中外面套一层标签”Alt + W” (“Option + W” for Mac) Image Preview 鼠标移到路径里显示图像预览 Indenticator 突出目前的缩进深度 intelliSense for CSS class names in HTML 把项目中 css 文件里的名称智能提示在 html 中 JavaScript (ES6) code snippets es6代码片段 Live Server 浏览器实时刷新 Node.js Modules Intellisense 可以在导入语句中自动完成JavaScript / TypeScript模块 npm Intellisense require 时的包提示 Path Intellisense 路径自动补全 Quokka.js Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈使用方法: ctrl+shift+p 输入quokka选择 new javascript 就可以了 Regex Previewer 这是一个用于实时测试正则表达式的实用工具。它可以将正则表达式模式应用在任何打开的文件上，并高亮所有的匹配项 SVG Viewer 此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项 Vetur Vue 语法高亮显示, 语法错误检查, 代码自动补全(配合 ESLint 插件效果更佳) vscode-fileheader 顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间快捷键: Ctrl+Alt+i(默认信息可在 文件→首选项→设置 中修改) 结尾写这篇文章主要是想偷个懒，以后安装插件不用去查，之后会继续更新新的插件当作仓库。 原文是：https://blog.csdn.net/shenxianhui1995/article/details/81604818]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生的Ajax]]></title>
    <url>%2F2018%2F12%2F11%2F%E5%8E%9F%E7%94%9F%E7%9A%84ajax%2F</url>
    <content type="text"><![CDATA[Ajax = 异步JavaScript和xml。Ajax是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必需重载整个网页面。 创建XMLHttpRequest对象XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 1let xhr = new XMLHttpRequest(); 向服务器发送请求请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： 12xhr.open(method,url,async) xhr.send(string) method: string，请求的类型；GET 或 POSTurl: string,文件在服务器上的位置async: Boolean，true（异步）或 false（同步)string: string,仅用于 POST 请求,将请求发送到服务器。 服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 12responseText // 获得字符串形式的响应数据responseXML // 获得 XML 形式的响应数据 onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件readyState 属性存有 XMLHttpRequest 的状态信息。 onreadystatechange: 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState: 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status: 200: “OK”,404: 未找到页面 实例 123456xhr.onreadystatechange=function()&#123; if (xhr.readyState==4 &amp;&amp; xhr.status==200) &#123; document.getElementById(&quot;div&quot;).innerHTML=xhr.responseText; &#125;&#125; 完整版使用回调函数回调函数是一种以参数形式传递给另一个函数的函数。 如果您的网站上存在多个 Ajax 任务，那么您应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 Ajax 任务调用该函数。 该函数调用应该包含 URL 以及发生 onreadystatechange 事件时执行的任务（每次调用可能不尽相同): 12345678910111213function loadXMLDoc (url, cfunc) &#123; let xhr = new XMLHttpRequest(); xhr.onreadystatechange = cfunc; xhr.open(&quot;GET&quot;,url,true); xhr.send();&#125;function myFunction () &#123; loadXMLDoc(&quot;ajax.txt&quot;, function () &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; document.getElementById(&quot;div&quot;).innerHTML = xhr.responseText; &#125; )&#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的常用命令]]></title>
    <url>%2F2018%2F12%2F11%2Fgit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 工作流程 克隆 Git 资源作为工作目录。在克隆的资源上添加或修改文件。如果其他人修改了，你可以更新资源。在提交前查看修改。提交修改。在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 创建仓库git initgit init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 git clonegit clone 从现有 Git 仓库中拷贝项目 1git clone &lt;repo&gt; &lt;directory&gt; repo: Git仓库directory: 本地目录。 基本操作git add将想要快照的内容写入缓存区 使用 git add . 命令来添加当前项目的所有文件。 git status以查看在你上次提交之后是否有修改。 加 -s 参数，以获得简短的结果输出。 git diff查看执行 git status 的结果的详细信息。 尚未缓存的改动：git diff查看已缓存的改动： git diff --cached查看已缓存的与未缓存的所有改动：git diff HEAD显示摘要而非整个 diff：git diff --stat git commit将缓存区内容添加到仓库中。 如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。 1git commit -a git reset HEAD用于取消已缓存的内容。 git rm从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。 1git rm &lt;file&gt; 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f 1git rm -f &lt;file&gt; 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除， 1git rm --cached &lt;file&gt; git mvgit mv 命令用于移动或重命名一个文件、目录、软连接。 git分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 创建分支命令： 1git branch (branchname) 切换分支命令: 1git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 合并分支命令: 1git merge 列出分支基本命令： 1git branch 删除分支命令： 1git branch -d (branchname) Git 查看提交历史使用 git log 命令查看 用 --oneline 选项来查看历史记录的简洁的版本。 1git log --oneline 用 --graph 选项，查看历史中什么时候出现了分支、合并。 1git log --oneline --graph 用 --reverse参数来逆向显示所有日志。 1git log --reverse --oneline 如果只想查找指定用户的提交日志可以使用命令：git log --author 1git log --author=Linus --oneline -5 Git 标签如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 1git tag -a v1.0 Git 远程仓库(Github)添加远程库12git remote add [shortname] [url]git remote add origin https:// 查看当前的远程库12git remotegit remote -v 提取远程仓库从远程仓库下载新分支与数据： 1git fetch 从远端仓库提取数据并尝试合并到当前分支： 1git merge 推送到远程仓库12git push [alias] [branch]git push -u origin master -u: 第一次提交时用，之后不需要origin: 远程仓库 删除远程仓库1git remote rm [别名]]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next主题优化]]></title>
    <url>%2F2018%2F12%2F10%2Fhexo-next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[hexo官方提供的主题实在是不怎么美观，所以开发人员就制作了第三方主题，当然主题有很多，而今天我说的next主题。关于hexo的搭建可以去官方文档，很全面，按步骤走一遍基本就会用了。 next主题的配置设置主题风格打开 themes/next/_config.yml 文件，搜索 Schemes 关键字，将你需用启用的 scheme 前面注释 # 去除即可。 12345# Schemes# scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 设置菜单项的显示文本和图标设置菜单项的显示中文文本打开 themes/next/languages/zh-Hans.yml 文件,搜索 menu 关键字，修改对应中文或者新增。 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于我 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 设定菜单项的文件目录和对应图标打开 themes/next/_config.yml 文件，搜索 menu_icons 关键字，修改对应图标名称或者新增对应 menu 的图标。 12345678910111213menu: 首页: / || home 标签: /tags/ || tags 分类: /categories/ || th 归档: /archives/ || archive 关于我: /about/ || user # schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap # commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 除了 home， archives , /后面都需要手动创建这个页面 创建菜单项对应文件目录,以分类为例使用 hexo new page 新建一个页面(不知道hexo命令可以去官方文档看)，命名为 categories ： 1$ hexo new page categories 编辑刚新建的页面,设置分类 12345---title: 分类date: 2018-12-10 14:05:23type: &quot;categories&quot;--- 头像设置添加头像打开 themes/next/_config.yml 文件，搜索 Sidebar Avatar 关键字，去掉 avatar 前面的#,把图片放入 themes/next/source/images 下,修改 avatar： 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /uploads/avatar.png 设置头像边框为圆形框打开位于 themes/next/source/css/_common/components/sidebar/sidebar-author.syl 文件,修改如下: 123456789101112.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; // 修改头像边框 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%;&#125; 特效：鼠标放置头像上旋转123456789101112131415161718192021.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; // 修改头像边框 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; // 设置旋转 transition: 1.4s all;&#125;// 可旋转的圆形头像,`hover`动作.site-author-image:hover &#123; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125; 浏览页面的时候显示当前浏览进度打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true。 12# Scroll percent label in b2t button.scrollpercent: true 侧边栏设置设置侧边栏社交链接打开 themes/next/_config.yml 文件,搜索关键字 social ,然后添加社交站点名称与地址即可。 123456789101112social: GitHub: https://github.com/zhengshikun || github E-Mail: mailto:646537311@qq.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 微博: https://weibo.com/u/3922341463?topnav=1&amp;wvr=6&amp;topsug=1 || weibo RSS在你 Hexo 站点目录下： 1$ npm install hexo-generator-feed --save 打开 Hexo 站点下的 _config.yml ,添加如下配置： 12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml limit: 20 hub: content: 友情链接打开 themes/next/_config.yml 文件,搜索关键字 Blog rolls： 12345678# Blog rollslinks_icon: linklinks_title: 友情连接#links_layout: blocklinks_layout: inlinelinks: #Title: http://example.com/ 百度: https://baidu.com/ 底部建站时间和图标修改打开 themes/next/_config.yml 文件,搜索关键字footer: 12345678910111213141516171819footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2018 # Icon between year and copyright info. icon: snowflake-o # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). # version: true 把用户的图标从小人user改成了雪花snowflake-o copyright留空，显示成页面author即我的名字 powered: false把hexo的授权图片取消了 theme: enable:false 把主题的内容也取消了 主页文章添加边框阴影效果打开 themes/next/source/css/_custom/custom.styl ,向里面加代码: 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 开启版权声明主题配置文件下,搜索关键字 post_copyright , enable 改为 true： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 本地搜索在你站点的根目录下 1$ npm install hexo-generator-searchdb --save 打开 Hexo 站点的 _config.yml,添加配置 12345search: path: search.xml field: post format: html limit: 10000 打开 themes/next/_config.yml ,搜索关键字 local_search ,设置为 true： 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 统计功能,显示文章字数统计,阅读时长,总字数1$ npm i --save hexo-wordcount 打开 themes/next/_config.yml ，搜索关键字 post_wordcount： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 修改文章内文本连接样式打开 themes/next/source/css/_custom/custom.styl,添加代码： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #999; border-bottom: none; border-bottom: 1px solid #999; &amp;:hover &#123; color: #666; border-bottom: none; border-bottom: 1px solid #666; &#125;&#125; 本地站点推送到GitHub上在站点更目录下： 1$ npm install hexo-deployer-git --save 在 Hexo 站点的 _config.yml 中配置 deploy： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; #your github.io.git branch: master 1$ hexo clean 1$ hexo d --g 详情参考官方文档 添加网易云音乐在网易云音乐（网页版）中搜索我们想要插入的音乐，然后点击生成外链播放器,然后根据你得设置生成相应的html代码，将获得的html代码插入到你想要插入的位置。 我放在了侧边栏，在 themes/next/layout/_custom/sidebar.swig 文件中增加生成的HTML代码： 123&lt;div id=&quot;music163player&quot;&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=27583241&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 结尾放我npm安装的一些插件 1234567891011121314151617&quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.7.0&quot;, &quot;hexo-asset-image&quot;: &quot;0.0.3&quot;, &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-cname&quot;: &quot;^0.3.0&quot;, &quot;hexo-generator-feed&quot;: &quot;^1.2.2&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-server&quot;: &quot;^0.3.1&quot;, &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的第一篇文章 - markdown语法]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[你好哇！这是我的第一篇文章，当你看到这里的时候就代表我成功运行啦！庆祝~关于第一篇也没啥说的，我下面就测试markdown常用的语法吧 Markdown简介Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯和亚伦·斯沃茨。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档”。 ——维基百科 Markdown语法标题123456# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt;## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt;#### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt;##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt;###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt; 这是四级标题 内容强调加粗、斜体123字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示 字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示 删除线1这样来 ~~删除一段文本~~ 删除一段文本 高亮12使用&lt;code&gt;\`&lt;/code&gt;来强调字符 // 想打出 ` (反引号)需要转义的比如`突出背景色`来显示强调效果 使用`来强调字符比如突出背景色来显示强调效果 引用显示1234&gt; 每行开始都使用 &apos;&gt;&apos;；&gt; 引用**开始**；&gt; 引用**换行**；&gt; 引用**结束**。 每行开始都使用 ‘&gt;’；引用开始；引用换行；引用结束。 表格12345列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 可以使用冒号来定义对齐方式： 1234| 左对齐 | 右对齐 | 居中 || :-------- | -------:| :--: || Computer | 5000 元 | 1台 || Phone | 1999 元 | 1部 | 左对齐 右对齐 居中 Computer 5000 元 1台 Phone 1999 元 1部 代码块代码块语法遵循标准 markdown 代码，使用三个`开始,三个`结束 123``` 这里是内容``` 链接插入12[首页](https://zhengshikun.site)[关于我](/about/) 首页关于我 图片插入1![我的头像](/博客的第一篇文章/avatar.png) 列表无序列表123* 列表展示+ 列表展示- 列表展示 列表展示 列表展示 列表展示 有序列表121. **我是一级序列** 1. *我是二级序列* 我是一级序列 我是二级序列 链接自动检测12首页:https://zhengshikun.site我的信息:https://zhengshikun.site/about/ 首页:https://zhengshikun.site我的信息:https://zhengshikun.site/about/]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
