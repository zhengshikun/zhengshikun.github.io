<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[es6-对象的新增方法]]></title>
    <url>%2F2018%2F12%2F19%2Fes6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的对象的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 Object.is()ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 1234Object.is(&apos;foo&apos;, &apos;foo&apos;)// trueObject.is(&#123;&#125;, &#123;&#125;)// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign()基本用法Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意点浅拷贝Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 12345const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 同名属性的替换对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 1234const target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;const source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125; 数组的处理Object.assign可以用来处理数组，但是会把数组视为对象。 12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 取值函数的处理Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。 1234567onst source = &#123; get foo() &#123; return 1 &#125;&#125;;const target = &#123;&#125;;Object.assign(target, source)// &#123; foo: 1 &#125; 常见用途为对象添加属性12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 为对象添加方法12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; ···&#125;; 克隆对象123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。 1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 合并多个对象12const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。 12const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 为属性指定默认值12345678910const DEFAULTS = &#123; logLevel: 0, outputFormat: &apos;html&apos;&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // ...&#125; Object.getOwnPropertyDescriptors()ES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。 12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return &apos;abc&apos; &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。 proto属性proto属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。 123456789// es5 的写法const obj = &#123; method: function() &#123; ... &#125;&#125;;obj.__proto__ = someOtherObj;// es6 的写法var obj = Object.create(someOtherObj);obj.method = function() &#123; ... &#125;; Object.setPrototypeOf()Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。 12345// 格式Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf(&#123;&#125;, null); 该方法等同于下面的函数。 1234function setPrototypeOf(obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 下面是一个例子。 12345678910let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 Object.getPrototypeOf()该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。 1Object.getPrototypeOf(obj); 下面是一个例子。 123456789101112function Rectangle() &#123; // ...&#125;const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false Object.keys()，Object.values()，Object.entries()Object.keys()ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。 1234567891011121314let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]&#125; Object.values()Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 123const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;Object.values(obj)// [&quot;bar&quot;, 42] 返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。 123const obj = &#123; 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; &#125;;Object.values(obj)// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] Object.entries()Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 123const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;Object.entries(obj)// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ] Object.entries的基本用途是遍历对象的属性。 12345678let obj = &#123; one: 1, two: 2 &#125;;for (let [k, v] of Object.entries(obj)) &#123; console.log( `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;` );&#125;// &quot;one&quot;: 1// &quot;two&quot;: 2 Object.entries方法的另一个用处是，将对象转为真正的Map结构。 123const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;const map = new Map(Object.entries(obj));map // Map &#123; foo: &quot;bar&quot;, baz: 42 &#125; Object.fromEntries()Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。 12345Object.fromEntries([ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42]])// &#123; foo: &quot;bar&quot;, baz: 42 &#125; 该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。 12345678910111213// 例一const entries = new Map([ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42]]);Object.fromEntries(entries)// &#123; foo: &quot;bar&quot;, baz: 42 &#125;// 例二const map = new Map().set(&apos;foo&apos;, true).set(&apos;bar&apos;, false);Object.fromEntries(map)// &#123; foo: true, bar: false &#125; 该方法的一个用处是配合URLSearchParams对象，将查询字符串转为对象。 12Object.fromEntries(new URLSearchParams(&apos;foo=bar&amp;baz=qux&apos;))// &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-对象的扩展]]></title>
    <url>%2F2018%2F12%2F19%2Fes6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的对象的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 下面是一个实际的例子。 12345678910111213let birth = &apos;2000/01/01&apos;;const Person = &#123; name: &apos;张三&apos;, //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log(&apos;我的名字是&apos;, this.name); &#125;&#125;; 这种写法用于函数的返回值，将会非常方便。 12345678function getPoint() &#123; const x = 1; const y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; CommonJS 模块输出一组变量，就非常合适使用简洁写法。 123456789101112131415161718192021let ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性名表达式JavaScript 定义对象的属性，有两种方法。 12345// 方法一obj.foo = true;// 方法二obj[&apos;a&apos; + &apos;bc&apos;] = 123; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 123456let propKey = &apos;foo&apos;;let obj = &#123; [propKey]: true, [&apos;a&apos; + &apos;bc&apos;]: 123&#125;; 方法的 name 属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 1234567const person = &#123; sayName() &#123; console.log(&apos;hello!&apos;); &#125;,&#125;;person.sayName.name // &quot;sayName&quot; 上面代码中，方法的name属性返回函数名（即方法名）。 属性的可枚举性和遍历可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; 描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。 目前，有四个操作会忽略enumerable为false的属性。 for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。 12345Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;).enumerable// falseObject.getOwnPropertyDescriptor([], &apos;length&apos;).enumerable// false 上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。 另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。 12Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, &apos;foo&apos;).enumerable// false 属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 for…infor...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj)Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols(obj)Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// [&apos;2&apos;, &apos;10&apos;, &apos;b&apos;, &apos;a&apos;, Symbol()] super 关键字我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。 12345678910111213const proto = &#123; foo: &apos;hello&apos;&#125;;const obj = &#123; foo: &apos;world&apos;, find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // &quot;hello&quot; 上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。 对象的扩展运算符《数组的扩展》一章中，已经介绍过扩展运算符（…）。 123const [a, ...b] = [1, 2, 3];a // 1b // [2, 3] 解构赋值对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 扩展运算符对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。 123let foo = &#123; ...[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &#125;;foo// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125; 对象的扩展运算符等同于使用Object.assign()方法。 123let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4-简单配置]]></title>
    <url>%2F2018%2F12%2F18%2Fwebpack4-%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 概念入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 每个依赖项随即被处理，最后输出到称之为 bundles 的文件中，我们将在下一章节详细讨论这个过程。 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。 接下来我们看一个 entry 配置的最简单例子： webpack.config.js 123module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;&#125;; 出口(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： webpack.config.js 123456789const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;&#125;; 在上面的示例中，我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 Node.js 核心模块，用于操作文件路径。 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在更高层面，在 webpack 的配置中 loader 有两个目标： test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，表示进行转换时，应该使用哪个 loader。 webpack.config.js 1234567891011121314const path = require(&apos;path&apos;);const config = &#123; output: &#123; filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;&#125;;module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 &#39;.txt&#39; 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。” 插件(plugins)oader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 webpack.config.js 123456789101112131415const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装const webpack = require(&apos;webpack&apos;); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;) ]&#125;;module.exports = config; 模式通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 123module.exports = &#123; mode: &apos;production&apos;&#125;; 配置基本安装首先我们创建一个目录，初始化 npm，然后 在本地安装 webpack，接着安装 webpack-cli（此工具用于在命令行中运行 webpack）： 123mkdir webpack-demo &amp;&amp; cd webpack-demonpm init -ynpm install webpack webpack-cli --save-dev 现在我们将创建以下目录结构、文件和内容： 目录project 1234567webpack-demo |- package.json |- /src |- index.js |- webpack.common.js |- webpack.dev.js |- webpack.prod.js npm配置文件package.json 12345678910111213141516171819202122232425262728293031&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;sideEffects&quot;: false, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;clean-webpack-plugin&quot;: &quot;^1.0.0&quot;, &quot;css-loader&quot;: &quot;^2.0.1&quot;, &quot;csv-loader&quot;: &quot;^3.0.2&quot;, &quot;express&quot;: &quot;^4.16.4&quot;, &quot;file-loader&quot;: &quot;^2.0.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;style-loader&quot;: &quot;^0.23.1&quot;, &quot;uglifyjs-webpack-plugin&quot;: &quot;^2.0.1&quot;, &quot;webpack&quot;: &quot;^4.27.1&quot;, &quot;webpack-cli&quot;: &quot;^3.1.2&quot;, &quot;webpack-dev-middleware&quot;: &quot;^3.4.0&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.10&quot;, &quot;webpack-merge&quot;: &quot;^4.1.5&quot;, &quot;xml-loader&quot;: &quot;^1.2.1&quot; &#125;&#125; 请npm安装所有依赖 入口js文件src/index.js 1234567891011function component() &#123; var element = document.createElement(&apos;pre&apos;); element.innerHTML=[ &apos;Hello webpack!&apos; ] return element;&#125;document.body.appendChild(component()); webpack公用配置文件webpack.common.js 123456789101112131415161718192021222324252627282930313233343536373839404142const path = require(&apos;path&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: &#123; app: &apos;./src/index.js&apos; &#125;, module:&#123; rules: [&#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;, &#123; test: /\.(png|svg|jpg|gif)$/, use: [ &apos;file-loader&apos; ] &#125;, &#123; test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ &apos;file-loader&apos; ] &#125;, ] &#125;, plugins: [ new CleanWebpackPlugin([&apos;dist&apos;]), new HtmlWebpackPlugin(&#123; title: &apos;Production&apos; &#125;), ], output: &#123; filename: &apos;[name].bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;&#125; webpack开发环境配置文件webpack.dev.js 1234567891011121314const merge = require(&apos;webpack-merge&apos;);const common = require(&apos;./webpack.common.js&apos;);const webpack = require(&apos;webpack&apos;);module.exports = merge(common,&#123; devtool: &apos;inline-source-map&apos;, devServer: &#123; contentBase: &apos;./dist&apos; &#125;, plugins: [ new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin() ]&#125;); webpack生产环境配置文件webpack.prod.js 1234567891011121314const webpack = require(&apos;webpack&apos;);const merge = require(&apos;webpack-merge&apos;);const UglifyJSPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);const common = require(&apos;./webpack.common.js&apos;);module.exports = merge(common, &#123; devtool: &apos;source-map&apos;, plugins: [ new UglifyJSPlugin(&#123; sourceMap: true &#125;), new webpack.DefinePlugin() ]&#125;); 结尾没有安装vue react等前端框架，这里就大致的配置了下webpack。]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>webpack</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-数组的扩展]]></title>
    <url>%2F2018%2F12%2F18%2Fes6-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的数组的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 扩展运算符含义扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll(&apos;div&apos;)]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 该运算符主要用于函数调用。 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 扩展运算符与正常的函数参数可以结合使用，非常灵活。 123function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); 扩展运算符后面还可以放置表达式。 1234const arr = [ ...(x &gt; 0 ? [&apos;a&apos;] : []), &apos;b&apos;,]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 12[...[], 1]// [1] 替代函数的 apply 方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 12345678910111213// ES5 的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;let args = [0, 1, 2];f(...args); 下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。 12345678// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。 123456789// ES5的 写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6 的写法let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];arr1.push(...arr2); 下面是另外一个例子。 1234// ES5new (Date.bind.apply(Date, [null, 2015, 1, 1]))// ES6new Date(...[2015, 1, 1]); 扩展运算符的应用复制数组数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 合并数组扩展运算符提供了数组合并的新写法。 1234567891011const arr1 = [&apos;a&apos;, &apos;b&apos;];const arr2 = [&apos;c&apos;];const arr3 = [&apos;d&apos;, &apos;e&apos;];// ES5 的合并数组arr1.concat(arr2, arr3);// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ] 与解构赋值结合扩展运算符可以与解构赋值结合起来，用于生成数组。且只能放在参数的最后一位。 1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 字符串扩展运算符还可以将字符串转为真正的数组。 12[...&apos;hello&apos;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 实现了 Iterator 接口的对象任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 12let nodeList = document.querySelectorAll(&apos;div&apos;);let array = [...nodeList]; Map 和 Set 结构，Generator 函数扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 1234567let map = new Map([ [1, &apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;],]);let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567const go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]// ES6的写法let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll(&apos;p&apos;);Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。 12345Array.from(&apos;hello&apos;)// [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]let namesSet = new Set([&apos;a&apos;, &apos;b&apos;])Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;] 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。 1234567// arguments对象function foo() &#123; const args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll(&apos;div&apos;)] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.of()Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 数组实例的 copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 这三个参数都应该是数值，如果不是，会自动转为数值。 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的 find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 12345function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: &apos;John&apos;, age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 数组实例的 fill()fill方法使用给定值，填充一个数组。 12345[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)// [&apos;a&apos;, 7, &apos;c&apos;] 数组实例的 entries()，keys() 和 values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 数组实例的 flat()，flatMap()数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 12[1, 2, [3, 4]].flat()// [1, 2, 3, 4] flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。 12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 12[1, [2, [3]]].flat(Infinity)// [1, 2, 3] flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。 123// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8] 数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [, , ,] 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false ES6 则是明确将空位转为undefined。 12345678910111213141516Array.from([&apos;a&apos;,,&apos;b&apos;])// [ &quot;a&quot;, undefined, &quot;b&quot; ][...[&apos;a&apos;,,&apos;b&apos;]]// [ &quot;a&quot;, undefined, &quot;b&quot; ][,&apos;a&apos;,&apos;b&apos;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]new Array(3).fill(&apos;a&apos;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 1234567891011121314// entries()[...[,&apos;a&apos;].entries()] // [[0,undefined], [1,&quot;a&quot;]]// keys()[...[,&apos;a&apos;].keys()] // [0,1]// values()[...[,&apos;a&apos;].values()] // [undefined,&quot;a&quot;]// find()[,&apos;a&apos;].find(x =&gt; true) // undefined// findIndex()[,&apos;a&apos;].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-函数的扩展]]></title>
    <url>%2F2018%2F12%2F18%2Fes6-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的函数的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 函数参数的默认值基本用法ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || &apos;World&apos;; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello World ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y = &apos;World&apos;) &#123; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;const p = new Point();p // &#123; x: 0, y: 0 &#125; 与解构赋值默认值结合使用12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property &apos;x&apos; of undefined 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。 12345function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 123456function foo(x = 5, y = 6) &#123; console.log(x, y);&#125;foo(undefined, null)// 5 null 函数的 length 属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。 1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 2 再看下面的例子。 12345678let x = 1;function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // 1 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。 12345678let foo = &apos;outer&apos;;function bar(func = () =&gt; foo) &#123; let foo = &apos;inner&apos;; console.log(func());&#125;bar(); // outer 应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 12345678910function throwIfMissing() &#123; throw new Error(&apos;Missing parameter&apos;);&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。 1function foo(optional = undefined) &#123; ··· &#125; rest 参数ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 下面是一个 rest 参数代替arguments变量的例子。 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。 123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 函数的length属性，不包括 rest 参数。 严格模式从 ES5 开始，函数内部可以设定为严格模式。 1234function doSomething(a, b) &#123; &apos;use strict&apos;; // code&#125; ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) &#123; &apos;use strict&apos;; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; &apos;use strict&apos;; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; &apos;use strict&apos;; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; &apos;use strict&apos;; // code &#125;&#125;; 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 12345&apos;use strict&apos;;function doSomething(a, b = a) &#123; // code&#125; 第二种是把函数包在一个无参数的立即执行函数里面。 123456const doSomething = (function () &#123; &apos;use strict&apos;; return function(value = 42) &#123; return value; &#125;;&#125;()); name 属性函数的name属性，返回该函数的函数名。 12function foo() &#123;&#125;foo.name // &quot;foo&quot; 箭头函数基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 1let fn = () =&gt; void doesNotReturn(); 箭头函数可以与变量解构结合使用。 123456const full = (&#123; first, last &#125;) =&gt; first + &apos; &apos; + last;// 等同于function full(person) &#123; return person.first + &apos; &apos; + person.last;&#125; 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 另一个例子是 1234567// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 下面是 rest 参数与箭头函数结合的例子 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);// s1: 3// s2: 0 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。 123456789101112var handler = &#123; id: &apos;123456&apos;, init: function() &#123; document.addEventListener(&apos;click&apos;, event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log(&apos;Handling &apos; + type + &apos; for &apos; + this.id); &#125;&#125;; 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;args:&apos;, arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)() ];&#125;).call(&#123; x: &apos;outer&apos; &#125;);// [&apos;outer&apos;] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 不适用场合由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。 第一个场合是定义函数的方法，且该方法内部包括this。 123456const cat = &#123; lives: 9, jumps: () =&gt; &#123; this.lives--; &#125;&#125; 第二个场合是需要动态this的时候，也不应使用箭头函数。 1234var button = document.getElementById(&apos;press&apos;);button.addEventListener(&apos;click&apos;, () =&gt; &#123; this.classList.toggle(&apos;on&apos;);&#125;); 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。 嵌套的箭头函数下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。 123456789const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;const addThenMult = pipeline(plus1, mult2);addThenMult(5)// 12 如果觉得上面的写法可读性比较差，也可以采用下面的写法。 12345const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;mult2(plus1(5))// 12 双冒号运算符箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。 123456import &#123; map, takeWhile, forEach &#125; from &quot;iterlib&quot;;getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x)); 尾调用优化什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x)&#123; return g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 尾调用优化函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。 非尾递归的 Fibonacci 数列实现如下。 123456789function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 堆栈溢出Fibonacci(500) // 堆栈溢出 尾递归优化过的 Fibonacci 数列实现如下。 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。 此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 123456789function clownsEverywhere( param1, param2,) &#123; /* ... */ &#125;clownsEverywhere( &apos;foo&apos;, &apos;bar&apos;,); 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-数值的扩展]]></title>
    <url>%2F2018%2F12%2F17%2Fes6-%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的数值的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 二进制和八进制表示法ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 120b111110111 === 503 // true0o767 === 503 // true 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 12Number(&apos;0b111&apos;) // 7Number(&apos;0o10&apos;) // 8 Number.isFinite(), Number.isNaN()ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 12345678Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite(&apos;foo&apos;); // falseNumber.isFinite(&apos;15&apos;); // falseNumber.isFinite(true); // false Number.isNaN()用来检查一个值是否为NaN。 1234567Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN(&apos;15&apos;) // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN(&apos;true&apos; / 0) // trueNumber.isNaN(&apos;true&apos; / &apos;true&apos;) // true 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 12345678910isFinite(25) // trueisFinite(&quot;25&quot;) // trueNumber.isFinite(25) // trueNumber.isFinite(&quot;25&quot;) // falseisNaN(NaN) // trueisNaN(&quot;NaN&quot;) // trueNumber.isNaN(NaN) // trueNumber.isNaN(&quot;NaN&quot;) // falseNumber.isNaN(1) // false Number.parseInt(), Number.parseFloat()ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5的写法parseInt(&apos;12.34&apos;) // 12parseFloat(&apos;123.45#&apos;) // 123.45// ES6的写法Number.parseInt(&apos;12.34&apos;) // 12Number.parseFloat(&apos;123.45#&apos;) // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true Number.isInteger()Number.isInteger()用来判断一个数值是否为整数。 12Number.isInteger(25) // trueNumber.isInteger(25.1) // false 如果参数不是数值，Number.isInteger返回false。 1234Number.isInteger() // falseNumber.isInteger(null) // falseNumber.isInteger(&apos;15&apos;) // falseNumber.isInteger(true) // false Number.EPSILONES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。 123456Number.EPSILON === Math.pow(2, -52)// trueNumber.EPSILON// 2.220446049250313e-16Number.EPSILON.toFixed(20)// &quot;0.00000000000000022204&quot; 安全整数和 Number.isSafeInteger()JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。 1234567Math.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1// true ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 123456789101112131415Number.isSafeInteger(&apos;a&apos;) // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false Math 对象的扩展ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。 Math.trunc()Math.trunc方法用于去除一个数的小数部分，返回整数部分。 12345Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0 Math.sign()Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 12345Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaN Math.cbrt()Math.cbrt方法用于计算一个数的立方根。 1234Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734 Math.clz32()JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1000) // 22Math.clz32(0b01000000000000000000000000000000) // 1Math.clz32(0b00100000000000000000000000000000) // 2 Math.imul()Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。 123Math.imul(2, 4) // 8Math.imul(-1, 8) // -8Math.imul(-2, -2) // 4 Math.fround()Math.fround方法返回一个数的32位单精度浮点数形式。 123Math.fround(0) // 0Math.fround(1) // 1Math.fround(2 ** 24 - 1) // 16777215 Math.hypot()Math.hypot方法返回所有参数的平方和的平方根。 1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, &apos;foo&apos;); // NaNMath.hypot(3, 4, &apos;5&apos;); // 7.0710678118654755Math.hypot(-3); // 3 对数方法ES6 新增了 4 个对数相关方法。 Math.expm1()Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。 123Math.expm1(-1) // -0.6321205588285577Math.expm1(0) // 0Math.expm1(1) // 1.718281828459045 Math.log1p()Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 1234Math.log1p(1) // 0.6931471805599453Math.log1p(0) // 0Math.log1p(-1) // -InfinityMath.log1p(-2) // NaN Math.log10()Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。 12345Math.log10(2) // 0.3010299956639812Math.log10(1) // 0Math.log10(0) // -InfinityMath.log10(-2) // NaNMath.log10(100000) // 5 Math.log2()Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。 1234567Math.log2(3) // 1.584962500721156Math.log2(2) // 1Math.log2(1) // 0Math.log2(0) // -InfinityMath.log2(-2) // NaNMath.log2(1024) // 10Math.log2(1 &lt;&lt; 29) // 29 双曲函数方法ES6 新增了 6 个双曲函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 指数运算符ES2016 新增了一个指数运算符（**）。 122 ** 2 // 42 ** 3 // 8 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。 123// 相当于 2 ** (3 ** 2)2 ** 3 ** 2// 512 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 1234567let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-正则的扩展]]></title>
    <url>%2F2018%2F12%2F17%2Fes6-%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的正则表达式的扩展。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 RegExp 构造函数在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 123var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;);// 等价于var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 123var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 12var regex = new RegExp(/xyz/, &apos;i&apos;);// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/ig, &apos;i&apos;).flags// &quot;i&quot; 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 12/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;) // false/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;) // true RegExp.prototype.unicode 属性正则实例对象新增unicode属性，表示是否设置了u修饰符。 12345const r1 = /hello/;const r2 = /hello/u;r1.unicode // falser2.unicode // true y 修饰符除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。 y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = &apos;aaa_aa_a&apos;;var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // [&quot;aaa&quot;]r2.exec(s) // [&quot;aaa&quot;]r1.exec(s) // [&quot;aa&quot;]r2.exec(s) // null RegExp.prototype.sticky 属性与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。 12var r = /hello\d/y;r.sticky // true RegExp.prototype.flags 属性ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 123456789// ES5 的 source 属性// 返回正则表达式的正文/abc/ig.source// &quot;abc&quot;// ES6 的 flags 属性// 返回正则表达式的修饰符/abc/ig.flags// &apos;gi&apos; s 修饰符：dotAll 模式ES2018 引入s修饰符，使得.可以匹配任意单个字符。 1/foo.bar/s.test(&apos;foo\nbar&apos;) // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 1234567const re = /foo.bar/s;// 另一种写法// const re = new RegExp(&apos;foo.bar&apos;, &apos;s&apos;);re.test(&apos;foo\nbar&apos;) // truere.dotAll // truere.flags // &apos;s&apos; /s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 后行断言JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。 先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。 12/\d+(?=%)/.exec(&apos;100% of US presidents have been male&apos;) // [&quot;100&quot;]/\d+(?!%)/.exec(&apos;that’s all 44 of them&apos;) // [&quot;44&quot;] “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。”后行否定断言“则与”先行否定断言“相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。 12/(?&lt;=\$)\d+/.exec(&apos;Benjamin Franklin is on the $100 bill&apos;) // [&quot;100&quot;]/(?&lt;!\$)\d+/.exec(&apos;it’s is worth about €90&apos;) // [&quot;90&quot;] Unicode 属性类ES2018 引入了一种新的类的写法\p{...}和\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 12const regexGreekSymbol = /\p&#123;Script=Greek&#125;/u;regexGreekSymbol.test(&apos;π&apos;) // true 具名组匹配正则表达式使用圆括号进行组匹配。 1const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。 123456const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456const RE_DATE = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?&lt;year&gt;），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。 String.prototype.matchAll如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。 123456789101112131415var regex = /t(e)(st(\d?))/g;var string = &apos;test1test2test3&apos;;var matches = [];var match;while (match = regex.exec(string)) &#123; matches.push(match);&#125;matches// [// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]// ] 上面代码中，while循环取出每一轮的正则匹配，一共三轮。 目前有一个提案，增加了String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1234567891011const string = &apos;test1test2test3&apos;;// g 修饰符加不加都可以const regex = /t(e)(st(\d?))/g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;] 遍历器转为数组是非常简单的，使用...运算符和Array.from方法就可以了。 12345// 转为数组方法一[...string.matchAll(regex)]// 转为数组方法二Array.from(string.matchAll(regex));]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-字符串扩展]]></title>
    <url>%2F2018%2F12%2F16%2Fes6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的变量的解构赋值。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 字符的 Unicode 表示法JavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 12&quot;\u0061&quot;// &quot;a&quot; 但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示 12345&quot;\uD842\uDFB7&quot;// &quot;𠮷&quot;&quot;\u20BB7&quot;// &quot; 7&quot; ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符 1234567891011&quot;\u&#123;20BB7&#125;&quot;// &quot;𠮷&quot;&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;// &quot;ABC&quot;let hello = 123;hell\u&#123;6F&#125; // 123&apos;\u&#123;1F680&#125;&apos; === &apos;\uD83D\uDE80&apos;// true codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 1234567var s = &quot;𠮷&quot;;s.length // 2s.charAt(0) // &apos;&apos;s.charAt(1) // &apos;&apos;s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 123456let s = &apos;𠮷a&apos;;s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97 总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。 codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。 1234let s = &apos;𠮷a&apos;;s.codePointAt(0).toString(16) // &quot;20bb7&quot;s.codePointAt(2).toString(16) // &quot;61&quot; codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit(&quot;𠮷&quot;) // trueis32Bit(&quot;a&quot;) // false String.fromCodePoint()ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。 12String.fromCharCode(0x20BB7)// &quot;ஷ&quot; ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。 1234String.fromCodePoint(0x20BB7)// &quot;𠮷&quot;String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\uD83D\uDE80y&apos;// true 字符串的遍历器接口ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。 123456for (let codePoint of &apos;foo&apos;) &#123; console.log(codePoint)&#125;// &quot;f&quot;// &quot;o&quot;// &quot;o&quot; 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 123456789101112let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// &quot; &quot;// &quot; &quot;for (let i of text) &#123; console.log(i);&#125;// &quot;𠮷&quot; normalize()ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 12&apos;\u01D1&apos;.normalize() === &apos;\u004F\u030C&apos;.normalize()// true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = &apos;Hello world!&apos;;s.startsWith(&apos;Hello&apos;) // trues.endsWith(&apos;!&apos;) // trues.includes(&apos;o&apos;) // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345let s = &apos;Hello world!&apos;;s.startsWith(&apos;world&apos;, 6) // trues.endsWith(&apos;Hello&apos;, 5) // trues.includes(&apos;Hello&apos;, 6) // false repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123456789101112&apos;x&apos;.repeat(3) // &quot;xxx&quot;&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;&apos;na&apos;.repeat(0) // &quot;&quot;&apos;na&apos;.repeat(2.9) // &quot;nana&quot;&apos;na&apos;.repeat(Infinity)// RangeError&apos;na&apos;.repeat(-1)// RangeError&apos;na&apos;.repeat(-0.9) // &quot;&quot;&apos;na&apos;.repeat(NaN) // &quot;&quot;&apos;na&apos;.repeat(&apos;na&apos;) // &quot;&quot;&apos;na&apos;.repeat(&apos;3&apos;) // &quot;nanana&quot; padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos; matchAll()matchAll方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910111213// 普通字符串`In JavaScript &apos;\n&apos; is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义. 1let greeting = `\`Yo\` World!`; 模板字符串中嵌入变量，需要将变量名写在${}之中。 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 123456789101112let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// &quot;1 + 2 = 3&quot;`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// &quot;1 + 4 = 5&quot;let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// &quot;3&quot; 实例：模板编译下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置 JavaScript 代码，使用&lt;%= ... %&gt;输出 JavaScript 表达式。 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数 123456let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50); 123456789function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // ...&#125; 1234567891011121314151617181920let a = 5;let b = 10;function tag(s, v1, v2) &#123; console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return &quot;OK&quot;;&#125;tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`;// &quot;Hello &quot;// &quot; world &quot;// &quot;&quot;// 15// 50// &quot;OK&quot; String.raw()ES6 还为原生的 String 对象，提供了一个raw方法。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 12345String.raw`Hi\n$&#123;2+3&#125;!`;// 返回 &quot;Hi\\n5!&quot;String.raw`Hi\u000A!`;// 返回 &quot;Hi\\u000A!&quot; 模板字符串的限制前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-变量的解构赋值]]></title>
    <url>%2F2018%2F12%2F15%2Fes6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的变量的解构赋值。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 数组的解构赋值基本用法ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。 1let [a, b, c] = [1, 2, 3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象的解构赋值解构不仅可以用于数组，还可以用于对象。 123let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // undefined 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 对象的解构也可以指定默认值。 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = &apos;Something went wrong&apos; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot; 默认值生效的条件是，对象的属性值严格等于undefined。 12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 1let &#123; log, sin, cos &#125; = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = &apos;hello&apos;;len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值。 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 函数参数的解构也可以使用默认值。 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 不能使用圆括号的情况（1）变量声明语句 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数 函数参数也属于变量声明，因此不能带有圆括号 1234// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; （3）赋值语句的模式 123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将一部分模式放在圆括号之中，导致报错。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多 交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取 JSON 数据解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678910let jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125; = &#123;&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句 遍历 Map 结构任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-let和const命令]]></title>
    <url>%2F2018%2F12%2F14%2Fes6-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这篇主要总结“es6标准入门”这本书的let和const命令章节。把我个人认为重要的整理出来，不会详细介绍，哪里出问题之后再做修改。 let命令基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 块级作用域为什么需要块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变,必须立即初始化. 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 下面是另一个例子。 1234const a = [];a.push(&apos;Hello&apos;); // 可执行a.length = 0; // 可执行a = [&apos;Dave&apos;]; // 报错 如果真的想将对象冻结，应该使用Object.freeze方法。 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html语义化]]></title>
    <url>%2F2018%2F12%2F14%2Fhtml%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 为什么要语义化 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 写HTML代码时应注意什么 尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置。 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 HTML5新增了哪些语义标签在HTML5出来之前，我们用div来表示页面章节，但是这些div都没有实际意义。（即使我们用css样式的id和class形容这块内容的意义）。这些标签只是我们提供给浏览器的指令，只是定义一个网页的某些部分。但现在，那些之前没“意义”的标签因为html5的出现消失了，这就是我们平时说的“语义”。 看下图没有用div标签来布局 html5的布局嗯，如上图那个页面结构没有一个div，都是采用html5语义标签（用哪些标签，关键取决于你的设计目标）。 但是也不要因为html5新标签的出现，而随意用之，错误的使用肯定会事与愿违。所以有些地方还是要用div的，就是因为div没有任何意义的元素，他只是一个标签，仅仅是用来构建外观和结构。因此是最适合做容器的标签。 W3C定义了这些语义标签，不可能完全符合我们有时的设计目标，就像制定出来的法律不可能流传100年都不改变，更何况它才制定没多久，不可能这些语义标签对所以设计目标的适应。只是一定程度上的“通用”，我们的目标是让爬虫读懂重要的东西就够了。 结论：不能因为有了HTML5标签就弃用了div，每个事物都有它的独有作用的。 节点元素标签因使用的地方不同，我将他们分为：节元素标签、文本元素标签、分组元素标签分开来讲解HTML5中新增加的语义化标签和使用总结。 header元素header 元素代表“网页”或“section”的页眉。通常包含h1-h6元素或hgroup，作为整个页面或者一个内容块的标题。也可以包裹一节的目录部分，一个搜索框，一个nav，或者任何相关logo。 整个页面没有限制header元素的个数，可以拥有多个，可以为每个内容块增加一个header元素 123456&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;h1&gt;网站副标题&lt;/h1&gt; &lt;/hgroup&gt;&lt;/header&gt; header使用注意： 可以是“网页”或任意“section”的头部部分； 没有个数限制。 如果hgroup或h1-h6自己就能工作的很好，那就不要用header。 footer元素footer元素代表“网页”或“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。如果footer元素包含了整个节，那么它们就代表附录，索引，提拔，许可协议，标签，类别等一些其他类似信息。 123&lt;footer&gt; COPYRIGHT@zhengshikun&lt;/footer&gt; footer使用注意： 可以是“网页”或任意“section”的底部部分； 没有个数限制，除了包裹的内容不一样，其他跟header类似。 hgroup元素hgroup元素代表“网页”或“section”的标题，当元素有多个层级时，该元素可以将h1到h6元素放在其内，譬如文章的主标题和副标题的组合 1234&lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5语义化标签和更简洁的结构&lt;/h1&gt; &lt;h2&gt;HTML 5&lt;/h2&gt;&lt;/hgroup&gt; hgroup使用注意： 如果只需要一个h1-h6标签就不用hgroup 如果有连续多个h1-h6标签就用hgroup 如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签 nav元素nav元素代表页面的导航链接区域。用于定义页面的主要导航部分。 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;HTML 5&lt;/li&gt; &lt;li&gt;CSS3&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; nav使用注意： 用在整个页面主要导航部分上，不合适就不要用nav元素； aside元素aside元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。（特殊的section） 在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。 1234567&lt;article&gt; &lt;p&gt;内容&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;作者简介&lt;/h1&gt; &lt;p&gt;hello,world&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt; aside使用总结： aside在article内表示主要内容的附属信息， 在article之外则可做侧边栏，没有article与之对应，最好不用。 如果是广告，其他日志链接或者其他分类导航也可以用 section元素section元素代表文档中的“节”或“段”，“段”可以是指一篇文章里按照主题的分段；“节”可以是指一个页面里的分组。 section通常还带标题，虽然html5中section会自动给标题h1-h6降级，但是最好手动给他们降级。如下： 1234567891011&lt;section&gt; &lt;h1&gt;section是啥？&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;关于section&lt;/h1&gt; &lt;p&gt;section的介绍&lt;/p&gt; &lt;section&gt; &lt;h3&gt;关于其他&lt;/h3&gt; &lt;p&gt;关于其他section的介绍&lt;/p&gt; &lt;/section&gt; &lt;/article&gt;&lt;/section&gt; section使用注意： 一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。 表示文档中的节或者段； article、nav、aside可以理解为特殊的section，所以如果可以用article、nav、aside就不要用section，没实际意义的就用div article元素article元素最容易跟section和div容易混淆，其实article代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。（特殊的section） 除了它的内容，article会有一个标题（通常会在header里），会有一个footer页脚。我们举几个例子介绍一下article，好更好区分article、section、div 1234567&lt;article&gt; &lt;h1&gt;一篇文章&lt;/h1&gt; &lt;p&gt;文章内容..&lt;/p&gt; &lt;footer&gt; &lt;p&gt;&lt;small&gt;版权：html5jscss网所属，作者：小北&lt;/small&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt; 上例是最好简单的article标签使用情况，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论，如下： 12345678910111213141516171819202122232425262728293031&lt;article&gt; &lt;header&gt; &lt;h1&gt;一篇文章&lt;/h1&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2012-10-03&quot;&gt;2012/10/03&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;文章内容..&lt;/p&gt; &lt;article&gt; &lt;h2&gt;评论&lt;/h2&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论者: XXX&lt;/h3&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2012-10-03T19:10-08:00&quot;&gt;~1 hour ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;哈哈哈&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;评论者: XXX&lt;/h3&gt; &lt;p&gt;&lt;time pubdate datetime=&quot;2012-10-03T19:10-08:00&quot;&gt;~1 hour ago&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;哈？哈？哈？&lt;/p&gt; &lt;/article&gt; &lt;/article&gt;&lt;/article&gt; article内部嵌套article，有可能是评论或其他跟文章有关联的内容。那article内部嵌套section一般是什么情况呢。如下： 12345678910111213141516&lt;article&gt; &lt;h1&gt;前端技术&lt;/h1&gt; &lt;p&gt;前端技术有那些&lt;/p&gt; &lt;section&gt; &lt;h2&gt;CSS&lt;/h2&gt; &lt;p&gt;样式..&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;JS&lt;/h2&gt; &lt;p&gt;脚本&lt;/p&gt; &lt;/section&gt;&lt;/article&gt; 因为文章内section部分虽然也是独立的部分，但是它门只能算是组成整体的一部分，从属关系，article是大主体，section是构成这个大主体的一部分。本网站的全部文章都是article嵌套一个个section章节，这样能让浏览器更容易区分各个章节所包括的内容。 那section内部嵌套article又有哪些情况呢，如下 1234567891011121314151617181920&lt;section&gt; &lt;h1&gt;介绍: 网站制作成员配备&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;设计师&lt;/h2&gt; &lt;p&gt;设计网页的...&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;程序员&lt;/h2&gt; &lt;p&gt;后台写程序的..&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;前端工程师&lt;/h2&gt; &lt;p&gt;给楼上两位打杂的..&lt;/p&gt; &lt;/article&gt;&lt;/section&gt; 设计师、程序员、前端工程师都是一个独立的整体，他们组成了网站制作基本配备，当然还有其他成员~。设计师、程序员、前端工程师就像article，是一个个独立的整体，而section将这些自成一体的article包裹，就组成了一个团体。 article和section和例子就例举这么多了，具体情况具体分析，不易深究。漏了div，其实div就是只是想用来把元素组合或者给它们加样式时使用。 article使用注意： 自身独立的情况下：用article 是相关内容：用section 没有语义的：用div HTML5其他结构元素标签HTML5节元素标签包括body article nav aside section header footer hgroup ，还有h1-h6 address。 address代表区块容器，必须是作为联系信息出现，邮编地址、邮件地址等等,一般出现在footer。 h1-h6因为hgroup，section和article的出现，h1-h6定义也发生了变化，允许一张页面出现多个h1。 原文：https://www.cnblogs.com/fliu/articles/5244866.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass基本用法]]></title>
    <url>%2F2018%2F12%2F13%2Fsass%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。 使用变量sass使用$符号来标识变量,比如$highlight-color和$sidebar-width。 变量声明sass变量的声明和css属性的声明很像： 12$highlight-color: #F90;$basic-border: 1px solid black; 这时变量还没有生效，除非你引用这个变量 变量引用12345678910111213$nav-color: #F90;nav &#123; $width: 100px; width: $width; color: $nav-color;&#125;//编译后nav &#123; width: 100px; color: #F90;&#125; $width这个变量定义在了nav的{ }规则块内，所以它只能在nav规则块内使用。 变量名用中划线还是下划线分隔sass并不想强迫任何人一定使用中划线或下划线，所以这两种用法相互兼容。用中划线声明的变量可以使用下划线的方式引用，反之亦然。这意味着即使compass选择用中划线的命名方式，这并不影响你在使用compass的样式中用下划线的命名方式进行引用： 12345678910$link-color: blue;a &#123; color: $link_color;&#125;//编译后a &#123; color: blue;&#125; 嵌套CSS 规则1234#content &#123; background-color: #f5f5f5; aside &#123; background-color: #eee &#125;&#125; 123 /* 编译后 */#content &#123; background-color: #f5f5f5 &#125;#content aside &#123; background-color: #eee &#125; 大多数情况下这种简单的嵌套都没问题，但是有些场景下不行，比如你想要在嵌套的选择器 里边立刻应用一个类似于:hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构&amp;。 父选择器的标识符&amp;一般情况下，sass在解开一个嵌套规则时就会把父选择器（#content）通过一个空格连接到子选择器的前边（article和aside）形成（#content article和#content aside）。这种在CSS里边被称为后代选择器，因为它选择ID为content的元素内所有命中选择器article和aside的元素。但在有些情况下你却不会希望sass使用这种后代选择器的方式生成这种连接。 1234article a &#123; color: blue; :hover &#123; color: red &#125;&#125; 上面的无法正常工作，解决之道为使用一个特殊的sass选择器，即父选择器。在使用嵌套规则时，父选择器能对于嵌套规则如何解开提供更好的控制。它就是一个简单的&amp;符号。 1234article a &#123; color: blue; &amp;:hover &#123; color: red &#125;&#125; 当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&amp;被父选择器直接替换： 123/* 编译后 */article a &#123; color: blue &#125;article a:hover &#123; color: red &#125; 群组选择器的嵌套123.container &#123; h1, h2, h3 &#123;margin-bottom: .8em&#125;&#125; 12/* 编译后 */.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125; 123nav, aside &#123; a &#123;color: blue&#125;&#125; 12/* 编译后 */nav a, aside a &#123;color: blue&#125; 有利必有弊，你需要特别注意群组选择器的规则嵌套生成的css。虽然sass让你的样式表看上去很小，但实际生成的css却可能非常大，这会降低网站的速度。 子组合选择器和同层组合选择器：&gt;、+和~可以把它们放在外层选择器后边，或里层选择器前边： 123456789article &#123; ~ article &#123; border-top: 1px dashed #ccc &#125; &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; nav + &amp; &#123; margin-top: 0 &#125;&#125; 123456/* 编译后 */article ~ article &#123; border-top: 1px dashed #ccc &#125;article &gt; footer &#123; background: #eee &#125;article dl &gt; dt &#123; color: #333 &#125;article dl &gt; dd &#123; color: #555 &#125;nav + article &#123; margin-top: 0 &#125; 嵌套属性123456nav &#123; border: 1px solid #ccc &#123; left: 0px; right: 0px; &#125;&#125; 123456/* 编译后 */nav &#123; border: 1px solid #ccc; border-left: 0px; border-right: 0px;&#125; 导入SASS文件使用sass的@import规则并不需要指明被导入文件的全名。你可以省略.sass或.scss文件后缀（见下图）。这样，在不修改样式表的前提下，你完全可以随意修改你或别人写的被导入的sass样式文件语法，在sass和scss语法之间随意切换。举例来说，@import“sidebar”;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。 使用SASS部分文件当通过@import把sass样式分散到多个文件时，你通常只想生成少数几个css文件。那些专门为@import命令而编写的sass文件，并不需要生成对应的独立css文件，这样的sass文件称为局部文件。对此，sass有一个特殊的约定来命名这些文件。 此约定即，sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。当你@import一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。举例来说，你想导入themes/_night-sky.scss这个局部文件里的变量，你只需在样式表中写@import &quot;themes/night-sky&quot;;。 局部文件可以被多个不同的文件引用。当一些样式需要在多个页面甚至多个项目中使用时，这非常有用。在这种情况下，有时需要在你的样式表中对导入的样式稍作修改，sass有一个功能刚好可以解决这个问题，即默认变量值。 默认变量值一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明： 12345$link-color: blue;$link-color: red;a &#123;color: $link-color;&#125; 在上边的例子中，超链接的color会被设置为red。这可能并不是你想要的结果，假如你写了一个可被他人通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值。使用sass的!default标签可以实现这个目的。它很像css属性中!important标签的对立面，不同的是!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。 1234$fancybox-width: 400px !default;.fancybox &#123;width: $fancybox-width;&#125; 嵌套导入跟原生的css不同，sass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方。举例说明，有一个名为_blue-theme.scss的局部文件，内容如下： 1234aside &#123; background: blue; color: white;&#125; 然后把它导入到一个CSS规则内，如下所示： 12345678910.blue-theme &#123;@import &quot;blue-theme&quot;&#125;//生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。.blue-theme &#123; aside &#123; background: blue; color: #fff; &#125;&#125; 被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效。这些变量和混合器不会全局有效，这样我们就可以通过嵌套导入只对站点中某一特定区域运用某种颜色主题或其他通过变量配置的样式。 原生的CSS导入由于sass兼容原生的css，所以它也支持原生的CSS@import。尽管通常在sass中使用@import时，sass会尝试找到对应的sass文件并导入进来，但在下列三种情况下会生成原生的CSS@import，尽管这会造成浏览器解析css时的额外下载： 被导入文件的名字以.css结尾； 被导入文件的名字是一个URL地址 被导入文件的名字是CSS的url()值。 静默注释sass另外提供了一种不同于css标准注释格式/* ... */的注释语法，即静默注释，其内容不会出现在生成的css文件中。静默注释的语法跟JavaScript`Java等类C的语言中单行注释的语法相同，它们以//`开头，注释内容直到行末。 1234body &#123; color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */&#125; 混合器混合器使用@mixin标识符定义。看上去很像其他的CSS @标识符，比如说@media或者@font-face。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段sass代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。 12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 然后就可以在你的样式表中通过@include来使用这个混合器，放在你希望的任何地方。@include调用会把混合器中的所有样式提取出来放在@include被调用的地方。如果像下边这样写： 12345notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125; 12345678//sass最终生成：.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 通过使用参数，你可以使用混合器把你样式中的通用样式抽离出来，然后轻松地在其他地方重用。 何时使用混合器.notice是一个有语义的类名。如果一个html元素有一个notice的类名，就表明了这个html元素的用途：向用户展示提醒信息。rounded-corners混合器是展示性的，它描述了包含它的css规则最终的视觉样式，尤其是边框角的视觉样式。混合器和类配合使用写出整洁的html和css，因为使用语义化的类名亦可以帮你避免重复使用混合器。为了保持你的html和css`的易读性和可维护性，在写样式的过程中一定要铭记二者的区别。 混合器中的CSS规则混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性 12345678@mixin no-bullets &#123; list-style: none; li &#123; list-style-image: none; list-style-type: none; margin-left: 0px; &#125;&#125; 1234ul.plain &#123; color: #444; @include no-bullets;&#125; sass的@include指令会将引入混合器的那行代码替换成混合器里边的内容 12345678910/* 编译后 */ul.plain &#123; color: #444; list-style: none;&#125;ul.plain li &#123; list-style-image: none; list-style-type: none; margin-left: 0px;&#125; 混合器中的规则甚至可以使用sass的父选择器标识符&amp;。使用起来跟不用混合器时一样，sass解开嵌套规则时，用父规则中的选择器替代&amp;。 给混合器传参如果你写过JavaScript，这种方式跟JavaScript的function很像： 12345@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 当混合器被@include时，你可以把它当作一个css函数来传参。 123456789a &#123; @include link-colors(blue, red, green);&#125;//Sass最终生成的是：a &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 当你@include混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，sass允许通过语法$name: value的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可： 1234567a &#123; @include link-colors( $normal: blue, $visited: green, $hover: red );&#125; 默认参数值为了在@include混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用$name: default-value的声明形式，默认值可以是任何有效的css属性值，甚至是其他参数的引用，如下代码： 12345678910@mixin link-colors( $normal, $hover: $normal, $visited: $normal )&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 如果像下边这样调用：@include link-colors(red) $hover和$visited也会被自动赋值为red。 使用选择器继承来精简CSS使用sass的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan面向对象的css的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现，如下代码: 123456789//通过选择器继承继承样式.error &#123; border: 1px solid red; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 何时使用继承 想象一下你正在编写一个页面，给html元素添加类名，你发现你的某个类（比如说.seriousError）另一个类（比如说.error）的细化。你会怎么做？ 你可以为这两个类分别写相同的样式，但是如果有大量的重复怎么办？使用sass时，我们提倡的就是不要做重复的工作。 你可以使用一个选择器组（比如说.error`.seriousError）给这两个选择器写相同的样式。如果.error`的所有样式都在同一个地方，这种做法很好，但是如果是分散在样式表的不同地方呢？再这样做就困难多了。 你可以使用一个混合器为这两个类提供相同的样式，但当.error的样式修饰遍布样式表中各处时，这种做法面临着跟使用选择器组一样的问题。这两个类也不是恰好有相同的 样式。你应该更清晰地表达这种关系。 综上所述你应该使用@extend。让.seriousError从.error继承样式，使两者之间的关系非常清晰。更重要的是无论你在样式表的哪里使用.error`.seriousError`都会继承其中的样式。 继承的高级用法任何css规则都可以继承其他规则，几乎任何css规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个html元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对html元素添加的所有样式都会被继承。 继承的工作细节关于@extend有两个要点你应该知道。 跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。 继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，css层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。 使用继承的最佳实践通常使用继承会让你的css美观、整洁。因为继承只会在生成css时复制选择器，而不会复制大段的css属性。但是如果你不小心，可能会让生成的css中包含大量的选择器复制。 小结本文介绍了sass最基本部分,你可以轻松地使用sass编写清晰、无冗余、语义化的css。对于sass提供的工具你已经有了一个比较深入的了解，同时也掌握了何时使用这些工具的指导原则。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>sass</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端代码规范]]></title>
    <url>%2F2018%2F12%2F12%2Fweb%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[此项目用于记录规范的、高可维护性的前端代码，这是通过分析 Github 众多前端代码库，总结出来的前端代码书写规范。 前端普适性规范黄金定律不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的。 永远遵循同一套编码规范，可以是这里列出的，也可以是你自己总结的。 项目命名项目名全部采用小写方式，以中划线分隔，禁止驼峰式命名。比如：my-project-name 文件命名文件命名参照项目命名规则。比如: error-report.html 有复数结构时，要采用复数命名法，比如： scripts, styles, images, data-models 文件名中只可由小写英文字母 az 、排序数字 09 或间隔符 - 组成，禁止包含特殊符号，比如空格、`$` 等 为了醒目，某些说明文件的文件名，可以使用大写字母，比如: README, LICENSE 为更好的表达语义，文件名使用英文名词命名，或英文简写。 不允许命名带有广告等英文的单词，例如ad,adv,adver,advertising，防止该模块被浏览器当成垃圾广告过滤掉。任何文件的命名均如此。 文件常用命名: index.shtml 引导页&amp;首页 main.shtml 首页 download.shtml 下载页面 act.html 活动列表页面 video.html 视频 cdkey.html CDKEY页面 base.css 基本样式 layout.css 框架布局 module.css 模块样式 global.css 全局样式 font.css 字体样式 index.css 首页样式 link.css 链接样式 print.css 打印样式 HTML 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 嵌套的节点应该缩进（四个空格）。 在属性上，使用双引号，不要使用单引号。 不要在自动闭合标签结尾处使用斜线 / - HTML5 规范 指出他们是可选的。 1&lt;img src=&quot;images/logo.png&quot; alt=&quot;Company&quot;&gt; 不要忽略可选的关闭标签（例如，&lt;/li&gt; 和 &lt;/body&gt;）。 HTML5 doctype在每个 HTML 页面开头使用这个简单地 doctype 来启用标准模式，使其每个浏览器中尽可能一致的展现。 虽然 doctype 不区分大小写，但是按照惯例，doctype 大写 1&lt;!DOCTYPE html&gt; 语言属性123&lt;html lang=&quot;en&quot;&gt;&lt;/html&gt; 字符编码通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。这样 做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与 文档编码一致（一般采用 UTF-8 编码）。 1&lt;meta charset=&quot;UTF-8&quot;&gt; IE 兼容模式IE 支持通过特定的 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈 的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的模 式。 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 响应式1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 引入 CSS 和 JavaScript根据 HTML5 规范, 通常在引入 CSS 和 JavaScript 时不需要指明 type，因为 text/css 和 text/javascript 分别是他们的默认值。 12345678910&lt;!-- External CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;code-guide.css&quot;&gt;&lt;!-- In-document CSS --&gt;&lt;style&gt; /* ... */&lt;/style&gt;&lt;!-- JavaScript --&gt;&lt;script src=&quot;code-guide.js&quot;&gt;&lt;/script&gt; 实用高于完美尽量遵循 HTML 标准和语义，但是不应该以浪费实用性作为代价。任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。 减少标签数量在编写 HTML 代码时，需要尽量避免多余的父节点。很多时候，需要通过迭代和重构来使 HTML 变得更少。 参考下面的示例: 1234567&lt;!-- Not so great --&gt;&lt;span class=&quot;avatar&quot;&gt; &lt;img src=&quot;...&quot;&gt;&lt;/span&gt;&lt;!-- Better --&gt;&lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt; 属性顺序HTML 属性应该按照特定的顺序出现以保证易读性。 class id name data-* src, for, type, href, value , max-length, max, min, pattern placeholder, title, alt aria-*, role required, readonly, disabled class 是为高可复用组件设计的，理论上他们应处在第一位。id 更加具体而且应该尽量少使用（例如, 页内书签），所以他们处在第二位。 Boolean 属性Boolean 属性指不需要声明取值的属性。XHTML 需要每个属性声明取值，但是 HTML5 并不需要。 一个元素中 Boolean 属性的存在表示取值 true，不存在则表示取值 false。 简而言之，不要为 Boolean 属性添加取值。 1&lt;input type=&quot;text&quot; disabled&gt; JavaScript 生成标签在 JavaScript 文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免这种情况的出现。 CSS 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 使用组合选择器时，保持每个独立的选择器占用一行。 为了代码的易读性，在每个声明的左括号前增加一个空格。 声明块的右括号应该另起一行。 每条声明 : 后应该插入一个空格。 每条声明应该只占用一行来保证错误报告更加准确。 所有声明应该以分号结尾。虽然最后一条声明后的分号是可选的，但是如果没有他，你的代码会更容易出错。 逗号分隔的取值，都应该在逗号之后增加一个空格。 不要在颜色值 rgb() rgba() hsl() hsla()和 rect() 中增加空格，并且不要带有取值前面不必要的 0 (比如，使用 .5 替代 0.5)。 所有的十六进制值都应该使用小写字母，例如 #fff。因为小写字母有更多样的外形，在浏览文档时，他们能够更轻松的被区分开来。 尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。 为选择器中的属性取值添加引号，例如 input[type=&quot;text&quot;]。 他们只在某些情况下可有可无，所以都使用引号可以增加一致性。 不要为 0 指明单位，比如使用 margin: 0; 而不是 margin: 0px;。 123456789101112131415/* Bad CSS */.selector, .selector-secondary, .selector[type=text] &#123; margin: 0px 0px 15px; background-color: rgba(0, 0, 0, 0.5); box-shadow: 0 1px 2px #CCC, inset 0 1px 0 #FFFFFF&#125;/* Good CSS */.selector,.selector-secondary,.selector[type=&quot;text&quot;] &#123; margin-bottom: 15px; background-color: rgba(0,0,0,.5); box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;&#125; 声明顺序相关的属性声明应该以下面的顺序分组处理： Positioning Box model 盒模型 Typographic 排版 Visual 外观 Positioning 处在第一位，因为他可以使一个元素脱离正常文本流，并且覆盖盒模型相关的样式。盒模型紧跟其后，因为他决定了一个组件的大小和位置。 其他属性只在组件内部起作用或者不会对前面两种情况的结果产生影响，所以他们排在后面。 1234567891011121314151617181920212223242526272829.declaration-order &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box-model */ display: block; float: right; width: 100px; height: 100px; /* Typography */ font: normal 13px &quot;Helvetica Neue&quot;, sans-serif; line-height: 1.5; color: #333; text-align: center; /* Visual */ background-color: #f5f5f5; border: 1px solid #e5e5e5; border-radius: 3px; /* Misc */ opacity: 1;&#125; Don’t use @import与&lt;link&gt;相比，@import较慢，增加额外的页面请求，并可能导致其他不可预见的问题。 1234567&lt;!-- Use link elements --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;core.css&quot;&gt;&lt;!-- Avoid @imports --&gt;&lt;style&gt; @import url(&quot;more.css&quot;);&lt;/style&gt; 媒体查询位置尽量将媒体查询的位置靠近他们相关的规则。不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部。这样做只会让大家以后更容易忘记他们。这里是一个典型的案例。 123456789.element &#123; ... &#125;.element-avatar &#123; ... &#125;.element-selected &#123; ... &#125;@media (min-width: 480px) &#123; .element &#123; ...&#125; .element-avatar &#123; ... &#125; .element-selected &#123; ... &#125;&#125; 前缀属性当使用厂商前缀属性时，通过缩进使取值垂直对齐以便多行编辑。 12345/* Prefixed properties */.selector &#123; -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15); box-shadow: 0 1px 2px rgba(0,0,0,.15);&#125; 单条声明的声明块在一个声明块中只包含一条声明的情况下，为了易读性和快速编辑可以考虑移除其中的换行。所有包含多条声明的声明块应该分为多行。 这样做的关键因素是错误检测 - 例如，一个 CSS 验证程序显示你在 183 行有一个语法错误,如果是一个单条声明的行，那就是他了。在多个声明的情况下，你必须为哪里出错了费下脑子。 123.span1 &#123; width: 60px; &#125;.span2 &#123; width: 140px; &#125;.span3 &#123; width: 220px; &#125; 属性简写尽量不使用属性简写的方式，属性简写需要你必须显式设置所有取值。常见的属性简写滥用包括: padding margin font background -border -border-radius 大多数情况下，我们并不需要设置属性简写中包含的所有值。例如，HTML 头部只设置上下的 margin，所以如果需要，只设置这两个值。过度使用属性简写往往会导致更混乱的代码，其中包含不必要的重写和意想不到的副作用。 12345678910111213141516/* Bad example */.element &#123; margin: 0 0 10px; background: red; background: url(&quot;image.jpg&quot;); border-radius: 3px 3px 0 0;&#125;/* Good example */.element &#123; margin-bottom: 10px; background-color: red; background-image: url(&quot;image.jpg&quot;); border-top-left-radius: 3px; border-top-right-radius: 3px;&#125; Less 和 Sass 中的嵌套避免不必要的嵌套。可以进行嵌套，不意味着你应该这样做。只有在需要给父元素增加样式并且同时存在多个子元素时才需要考虑嵌套。 123456789// Without nesting.table &gt; thead &gt; tr &gt; th &#123; … &#125;.table &gt; thead &gt; tr &gt; td &#123; … &#125;// With nesting.table &gt; thead &gt; tr &#123; &gt; th &#123; … &#125; &gt; td &#123; … &#125;&#125; 代码注释代码是由人来编写和维护的。保证你的代码是描述性的，包含好的注释，并且容易被他人理解。好的代码注释传达上下文和目标。不要简单地重申组件或者 class 名称。 class 命名保持 class 命名为全小写，可以使用短划线（不要使用下划线和 camelCase 命名）。短划线应该作为相关类的自然间断。(例如，.btn 和 .btn-danger)。 避免过度使用简写。.btn 可以很好地描述 button，但是 .s 不能代表任何元素。 class 的命名应该尽量短，也要尽量明确。 使用有意义的名称；使用结构化或者作用目标相关，而不是抽象的名称。 命名时使用最近的父节点或者父 class 作为前缀。 使用 .js-* 来表示行为(相对于样式)，但是不要在 CSS 中包含这些 class。 选择器使用 class 而不是通用元素标签来优化渲染性能。 避免在经常出现的组件中使用一些属性选择器 (例如，[class^=&quot;...&quot;])。浏览器性能会受到这些情况的影响。 减少选择器的长度，每个组合选择器选择器的条目应该尽量控制在 3 个以内。 只在必要的情况下使用后代选择器 (例如，没有使用带前缀 classes 的情况). 代码组织以组件为单位组织代码。 制定一个一致的注释层级结构。 使用一致的空白来分割代码块，这样做在查看大的文档时更有优势。 当使用多个 CSS 文件时，通过组件而不是页面来区分他们。页面会被重新排列，而组件移动就可以了。 编辑器配置根据以下的设置来配置你的编辑器，将这些设置应用到项目的 .editorconfig 文件，来避免常见的代码不一致和丑陋的 diffs。 使用四个空格的缩进。 在保存时删除尾部的空白字符。 设置文件编码为 UTF-8。 在文件结尾添加一个空白行。 JS 规范语法使用四个空格的缩进，这是保证代码在各种环境下显示一致的唯一方式。 声明之后一律以分号结束， 不可以省略 完全避免 == != 的使用， 用严格比较条件 === !== eval 非特殊情况， 禁用！！！ with 非特殊情况， 禁用！！！ 单行长度，理论上不要超过80列，不过如果编辑器开启”自动换行”的话可以不考虑单行长度 接上一条，如果需要换行，存在操作符的情况，一定在操作符后换行，然后换的行缩进4个空格 这里要注意，如果是多次换行的话就没有必要继续缩进了，比如说下面这种就是最佳格式。 1234567if (typeof qqfind === &quot;undefined&quot; || typeof qqfind.cdnrejected === &quot;undefined&quot; || qqfind.cdnrejected !== true) &#123; url = &quot;http://pub.idqqimg.com/qqfind/js/location4.js&quot;;&#125; else &#123; url = &quot;http://find.qq.com/js/location4.js&quot;;&#125; 空行方法之间加 单行或多行注释前加 逻辑块之间加空行增加可读性 变量命名标准变量采用驼峰标识 使用的ID的地方一定全大写 使用的URL的地方一定全大写, 比如说 reportURL 涉及Android的，一律大写第一个字母 涉及iOS的，一律小写第一个，大写后两个字母 常量采用大写字母，下划线连接的方式 构造函数，大写第一个字母 12345678910111213var thisIsMyName;var goodID;var AndroidVersion;var iOSVersion;var MAX_COUNT = 10;function Person(name) &#123; this.name = name&#125; 字符常量一般情况下统一使用单引号 null的使用场景初始化可能以后分配对象值的变量 与一个可能或可能没有对象值的初始化变量进行比较 传入一个预期对象的函数 从预期对象的函数返回 不适合null的使用场景不要使用null来测试是否提供参数 不要测试值为null的未初始化变量 undefined使用场景永远不要直接使用undefined进行变量判断 使用字符串 &quot;undefined&quot; 对变量进行判断 123456// Badvar person;console.log(person === undefined); //true// Goodconsole.log(typeof person); // &quot;undefined&quot; 对象字面量12345678910// Badvar team = new Team();team.title = &quot;AlloyTeam&quot;;team.count = 25;// Goodvar team = &#123; title: &quot;AlloyTeam&quot;, count: 25&#125;; 数组声明12345678// Badvar colors = new Array(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;);var numbers = new Array(1, 2, 3, 4);// Goodvar colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];var numbers = [ 1, 2, 3, 4 ]; 单行注释双斜线后，必须跟注释内容保留一个空格 与下一行代码缩进保持一致 可位于一个代码行的末尾，双斜线距离分号四个空格 1234567// Goodif (condition) &#123; // if you made it here, then all security checks passed allowed();&#125;var zhangsan = &quot;zhangsan&quot;; // 双斜线距离分号四个空格，双斜线后始终保留一个空格 多行注释格式最少三行 前边留空一行 123/** * 注释内容与星标前保留一个空格 */ 何时使用多行注释格式难于理解的代码段 可能存在错误的代码段 浏览器特殊的HACK代码 业务逻辑强相关的代码 想吐槽的产品逻辑, 合作同事 文档注释各类标签 @param @method 等 参考 http://usejsdoc.org/ 用于：方法、构造函数、对象 123456/** * here boy, look here , here is girl * @method lookGril * @param &#123;Object&#125; balabalabala * @return &#123;Object&#125; balabalabala */ 括号对齐标准示例 括号前后有空格，花括号起始不另换行，结尾新起一行 花括号必须要，即使内容只有一行 涉及 if for while do...while try...catch...finally 的地方都必须使用花括号，即使内容只有一行 if else 前后留有空格12345if (condition) &#123; doSomething();&#125; else &#123; doSomethingElse();&#125; switchswitch和括号之间有空格，case需要缩进，break之后跟下一个case中间留一个空白行 花括号必须要， 即使内容只有一行。 switch 的 falling through 一定要有注释特别说明，no default 的情况也需要注释特别说明况 123456789101112switch (condition) &#123; case &quot;first&quot;: // code break; case &quot;second&quot;: // code break; default: // code&#125; for普通for循环, 分号后留有一个空格， 判断条件等内的操作符两边不留空格 前置条件如果有多个，逗号后留一个空格 for-in 一定要有 hasOwnProperty 的判断， 否则 JSLint 或者 JSHint 都会有一个 warn 1234567891011121314for (i=0, len=values.length; i&lt;len; i++) &#123; process(values[i]);&#125;var prop;for (prop in object) &#123; // 注意这里一定要有 hasOwnProperty 的判断， 否则 JSLint 或者 JSHint 都会有一个 warn ！ if (object.hasOwnProperty(prop)) &#123; console.log(&quot;Property name is &quot; + prop); console.log(&quot;Property value is &quot; + object[prop]); &#125;&#125; 变量声明所有函数内变量声明放在函数内头部，只使用一个 var(多了JSLint报错)， 一个变量一行， 在行末跟注释， 注释啊，注释啊，亲 函数声明一定先声明再使用， 不要利用 JavaScript engine的变量提升特性, 违反了这个规则 JSLint 和 JSHint都会报 warn function declaration 和 function expression 的不同，function expression 的（）前后必须有空格，而function declaration 在有函数名的时候不需要空格，没有函数名的时候需要空格。 函数调用括号前后不需要空格 立即执行函数的写法, 最外层必须包一层括号 &quot;use strict&quot; 决不允许全局使用， 必须放在函数的第一行， 可以用自执行函数包含大的代码段, 如果 &quot;use strict&quot; 在函数外使用， JSLint 和 JSHint 均会报错 1234567891011121314151617181920212223function doSomething(item) &#123; // do something&#125;var doSomething = function (item) &#123; // do something&#125;// GooddoSomething(item);// Bad: Looks like a block statementdoSomething (item);// Good(function() &#123; &quot;use strict&quot;; function doSomething() &#123; // code &#125;&#125;)(); 结尾规范当然不是我写的啦，哈哈哈哈~ 原文是：https://github.com/bxm0927/web-code-standards]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>代码</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode快捷键]]></title>
    <url>%2F2018%2F12%2F12%2Fvscode%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[如标题所说的，vscode的快捷键。中英文对照。 常用 General 按 Press 功能 Function Ctrl + Shift + P，F1 显示命令面板 Show Command Palette Ctrl + P 快速打开 Quick Open Ctrl + Shift + N 新窗口/实例 New window/instance Ctrl + Shift + W 关闭窗口/实例 Close window/instance 基础编辑 Basic editing 按 Press 功能 Function Ctrl+X 剪切行（空选定） Cut line (empty selection) Ctrl+C 复制行（空选定）Copy line (empty selection) Alt+ ↑ / ↓ 向上/向下移动行 Move line up/down Shift+Alt + ↓ / ↑ 向上/向下复制行 Copy line up/down Ctrl+Shift+K 删除行 Delete line Ctrl+Enter 在下面插入行 Insert line below Ctrl+Shift+Enter 在上面插入行 Insert line above Ctrl+Shift+\ 跳到匹配的括号 Jump to matching bracket Ctrl+] / [ 缩进/缩进行 Indent/outdent line Home 转到行首 Go to beginning of line End 转到行尾 Go to end of line Ctrl+Home 转到文件开头 Go to beginning of file Ctrl+End 转到文件末尾 Go to end of file Ctrl+↑ / ↓ 向上/向下滚动行 Scroll line up/down Alt+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Shift+[ 折叠（折叠）区域 Fold (collapse) region Ctrl+Shift+] 展开（未折叠）区域 Unfold (uncollapse) region Ctrl+K Ctrl+[ 折叠（未折叠）所有子区域 Fold (collapse) all subregions Ctrl+K Ctrl+] 展开（未折叠）所有子区域 Unfold (uncollapse) all subregions Ctrl+K Ctrl+0 折叠（折叠）所有区域 Fold (collapse) all regions Ctrl+K Ctrl+J 展开（未折叠）所有区域 Unfold (uncollapse) all regions Ctrl+K Ctrl+C 添加行注释 Add line comment Ctrl+K Ctrl+U 删除行注释 Remove line comment Ctrl+/ 切换行注释 Toggle line comment Shift+Alt+A 切换块注释 Toggle block comment Alt+Z 切换换行 Toggle word wrap 导航 Navigation 按 Press 功能 Function Ctrl + T 显示所有符号 Show all Symbols Ctrl + G 转到行… Go to Line… Ctrl + P 转到文件… Go to File… Ctrl + Shift + O 转到符号… Go to Symbol… Ctrl + Shift + M 显示问题面板 Show Problems panel F8 转到下一个错误或警告 Go to next error or warning Shift + F8 转到上一个错误或警告 Go to previous error or warning Ctrl + Shift + Tab 导航编辑器组历史记录 Navigate editor group history Alt + ←/→ 返回/前进 Go back / forward Ctrl + M 切换选项卡移动焦点 Toggle Tab moves focus 搜索和替换 Search and replace 按 Press 功能 Function Ctrl + F 查找 Find Ctrl + H 替换 Replace F3 / Shift + F3 查找下一个/上一个 Find next/previous Alt + Enter 选择查找匹配的所有出现 Select all occurences of Find match Ctrl + D 将选择添加到下一个查找匹配 Add selection to next Find match Ctrl + K Ctrl + D 将最后一个选择移至下一个查找匹配项 Move last selection to next Find match Alt + C / R / W 切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word 多光标和选择 Multi-cursor and selection 按 Press 功能 Function Alt +单击 插入光标 Insert cursor Ctrl + Alt +↑/↓ 在上/下插入光标 Insert cursor above / below Ctrl + U 撤消上一个光标操作 Undo last cursor operation Shift + Alt + I 在选定的每一行的末尾插入光标 Insert cursor at end of each line selected Ctrl + I 选择当前行 Select current line Ctrl + Shift + L 选择当前选择的所有出现 Select all occurrences of current selection Ctrl + F2 选择当前字的所有出现 Select all occurrences of current word Shift + Alt + → 展开选择 Expand selection Shift + Alt + ← 缩小选择 Shrink selection Shift + Alt + （拖动鼠标） 列（框）选择 Column (box) selection Ctrl + Shift + Alt +（箭头键） 列（框）选择 Column (box) selection Ctrl + Shift + Alt + PgUp / PgDown 列（框）选择页上/下 Column (box) selection page up/down 丰富的语言编辑 Rich languages editing 按 Press 功能 Function Ctrl + 空格 触发建议 Trigger suggestion Ctrl + Shift + Space 触发器参数提示 Trigger parameter hints Tab Emmet展开缩写 Emmet expand abbreviation Shift + Alt + F 格式化文档 Format document Ctrl + K Ctrl + F 格式选定区域 Format selection F12 转到定义 Go to Definition Alt + F12 Peek定义 Peek Definition Ctrl + K F12 打开定义到边 Open Definition to the side Ctrl + . 快速解决 Quick Fix Shift + F12 显示引用 Show References F2 重命名符号 Rename Symbol Ctrl + K Ctrl + X 修剪尾随空格 Trim trailing whitespace Ctrl + K M 更改文件语言 Change file language 编辑器管理 Editor management 按 Press 功能 Function Ctrl+F4, Ctrl+W 关闭编辑器 Close editor Ctrl+K F 关闭文件夹 Close folder Ctrl+\ 拆分编辑器 Split editor Ctrl+ 1 / 2 / 3 聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group Ctrl+K Ctrl+ ←/→ 聚焦到上一个/下一个编辑器组 Focus into previous/next editor group Ctrl+Shift+PgUp / PgDown 向左/向右移动编辑器 Move editor left/right Ctrl+K ← / → 移动活动编辑器组 Move active editor group 文件管理 File management 按 Press 功能 Function Ctrl+N 新文件 New File Ctrl+O 打开文件… Open File… Ctrl+S 保存 Save Ctrl+Shift+S 另存为… Save As… Ctrl+K S 全部保存 Save All Ctrl+F4 关闭 Close Ctrl+K Ctrl+W 关闭所有 Close All Ctrl+Shift+T 重新打开关闭的编辑器 Reopen closed editor Ctrl+K 输入保持打开 Enter Keep Open Ctrl+Tab 打开下一个 Open next Ctrl+Shift+Tab 打开上一个 Open previous Ctrl+K P 复制活动文件的路径 Copy path of active file Ctrl+K R 显示资源管理器中的活动文件 Reveal active file in Explorer Ctrl+K O 显示新窗口/实例中的活动文件 Show active file in new window/instance 显示 Display 按 Press 功能 Function F11 切换全屏 Toggle full screen Shift+Alt+1 切换编辑器布局 Toggle editor layout Ctrl+ = / - 放大/缩小 Zoom in/out Ctrl+B 切换侧栏可见性 Toggle Sidebar visibility Ctrl+Shift+E 显示浏览器/切换焦点 Show Explorer / Toggle focus Ctrl+Shift+F 显示搜索 Show Search Ctrl+Shift+G 显示Git Show Git Ctrl+Shift+D 显示调试 Show Debug Ctrl+Shift+X 显示扩展 Show Extensions Ctrl+Shift+H 替换文件 Replace in files Ctrl+Shift+J 切换搜索详细信息 Toggle Search details Ctrl+Shift+C 打开新命令提示符/终端 Open new command prompt/terminal Ctrl+Shift+U 显示输出面板 Show Output panel Ctrl+Shift+V 切换Markdown预览 Toggle Markdown preview Ctrl+K V 从旁边打开Markdown预览 Open Markdown preview to the side 调试 Debug 按 Press 功能 Function F9 切换断点 Toggle breakpoint F5 开始/继续 Start/Continue Shift+F5 停止 Stop F11 / Shift+F11 下一步/上一步 Step into/out F10 跳过 Step over Ctrl+K Ctrl+I 显示悬停 Show hover 集成终端 Integrated terminal 按 Press 功能 Function Ctrl+` 显示集成终端 Show integrated terminal Ctrl+Shift+` 创建新终端 Create new terminal Ctrl+Shift+C 复制选定 Copy selection Ctrl+Shift+V 粘贴到活动端子 Paste into active terminal Ctrl+↑ / ↓ 向上/向下滚动 Scroll up/down Shift+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Home / End 滚动到顶部/底部 Scroll to top/bottom 结尾原文是：https://segmentfault.com/a/1190000007688656]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode插件]]></title>
    <url>%2F2018%2F12%2F11%2Fvscode%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Visual Studio Code（以下简称vscode）是一个轻量且强大的代码编辑器，支持Windows，OS X和Linux。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。 插件推荐 插件 说明 ComputerAuto Close Tag 自动添加HTML / XML关闭标签 Auto Rename Tag 自动重命名配对的HTML / XML标签 Beautify 格式化代码 Bracket Pair Colorizer 颜色识别匹配括号 Code Runner 能够运行多种语言的代码片段或代码文件 Chinese (Simplified) Language Pack for Visual Studio Code 中文简体包 Color Info 为你提供你在 CSS 中使用颜色的相关信息。 CSS Peek 可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码 Debugger for Chrome 前端调试, 查看使用方法 ESLint EsLint可以帮助我们检查Javascript编程时的语法错误。 filesize 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间 Git History 以图表的形式查看 git 日志 GitLens — Git supercharged 显示文件最近的 commit 和作者，显示当前行 commit 信息 HTML Boilerplate 通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构 HTMLHint HTML 代码格式检测 HTML Snippets 代码自动填充 htmltagwrap 在选中HTML标签中外面套一层标签”Alt + W” (“Option + W” for Mac) Image Preview 鼠标移到路径里显示图像预览 Indenticator 突出目前的缩进深度 intelliSense for CSS class names in HTML 把项目中 css 文件里的名称智能提示在 html 中 JavaScript (ES6) code snippets es6代码片段 Live Server 浏览器实时刷新 Node.js Modules Intellisense 可以在导入语句中自动完成JavaScript / TypeScript模块 npm Intellisense require 时的包提示 Path Intellisense 路径自动补全 Quokka.js Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈使用方法: ctrl+shift+p 输入quokka选择 new javascript 就可以了 Regex Previewer 这是一个用于实时测试正则表达式的实用工具。它可以将正则表达式模式应用在任何打开的文件上，并高亮所有的匹配项 SVG Viewer 此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项 Vetur Vue 语法高亮显示, 语法错误检查, 代码自动补全(配合 ESLint 插件效果更佳) vscode-fileheader 顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间快捷键: Ctrl+Alt+i(默认信息可在 文件→首选项→设置 中修改) 结尾写这篇文章主要是想偷个懒，以后安装插件不用去查，之后会继续更新新的插件当作仓库。 原文是：https://blog.csdn.net/shenxianhui1995/article/details/81604818]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生的Ajax]]></title>
    <url>%2F2018%2F12%2F11%2F%E5%8E%9F%E7%94%9F%E7%9A%84ajax%2F</url>
    <content type="text"><![CDATA[Ajax = 异步JavaScript和xml。Ajax是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必需重载整个网页面。 创建XMLHttpRequest对象XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 1let xhr = new XMLHttpRequest(); 向服务器发送请求请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： 12xhr.open(method,url,async) xhr.send(string) method: string，请求的类型；GET 或 POSTurl: string,文件在服务器上的位置async: Boolean，true（异步）或 false（同步)string: string,仅用于 POST 请求,将请求发送到服务器。 服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 12responseText // 获得字符串形式的响应数据responseXML // 获得 XML 形式的响应数据 onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件readyState 属性存有 XMLHttpRequest 的状态信息。 onreadystatechange: 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState: 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status: 200: “OK”,404: 未找到页面 实例 123456xhr.onreadystatechange=function()&#123; if (xhr.readyState==4 &amp;&amp; xhr.status==200) &#123; document.getElementById(&quot;div&quot;).innerHTML=xhr.responseText; &#125;&#125; 完整版使用回调函数回调函数是一种以参数形式传递给另一个函数的函数。 如果您的网站上存在多个 Ajax 任务，那么您应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 Ajax 任务调用该函数。 该函数调用应该包含 URL 以及发生 onreadystatechange 事件时执行的任务（每次调用可能不尽相同): 12345678910111213function loadXMLDoc (url, cfunc) &#123; let xhr = new XMLHttpRequest(); xhr.onreadystatechange = cfunc; xhr.open(&quot;GET&quot;,url,true); xhr.send();&#125;function myFunction () &#123; loadXMLDoc(&quot;ajax.txt&quot;, function () &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; document.getElementById(&quot;div&quot;).innerHTML = xhr.responseText; &#125; )&#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的常用命令]]></title>
    <url>%2F2018%2F12%2F11%2Fgit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 工作流程 克隆 Git 资源作为工作目录。在克隆的资源上添加或修改文件。如果其他人修改了，你可以更新资源。在提交前查看修改。提交修改。在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 创建仓库git initgit init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 git clonegit clone 从现有 Git 仓库中拷贝项目 1git clone &lt;repo&gt; &lt;directory&gt; repo: Git仓库directory: 本地目录。 基本操作git add将想要快照的内容写入缓存区 使用 git add . 命令来添加当前项目的所有文件。 git status以查看在你上次提交之后是否有修改。 加 -s 参数，以获得简短的结果输出。 git diff查看执行 git status 的结果的详细信息。 尚未缓存的改动：git diff查看已缓存的改动： git diff --cached查看已缓存的与未缓存的所有改动：git diff HEAD显示摘要而非整个 diff：git diff --stat git commit将缓存区内容添加到仓库中。 如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。 1git commit -a git reset HEAD用于取消已缓存的内容。 git rm从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。 1git rm &lt;file&gt; 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f 1git rm -f &lt;file&gt; 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除， 1git rm --cached &lt;file&gt; git mvgit mv 命令用于移动或重命名一个文件、目录、软连接。 git分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 创建分支命令： 1git branch (branchname) 切换分支命令: 1git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 合并分支命令: 1git merge 列出分支基本命令： 1git branch 删除分支命令： 1git branch -d (branchname) Git 查看提交历史使用 git log 命令查看 用 --oneline 选项来查看历史记录的简洁的版本。 1git log --oneline 用 --graph 选项，查看历史中什么时候出现了分支、合并。 1git log --oneline --graph 用 --reverse参数来逆向显示所有日志。 1git log --reverse --oneline 如果只想查找指定用户的提交日志可以使用命令：git log --author 1git log --author=Linus --oneline -5 Git 标签如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 1git tag -a v1.0 Git 远程仓库(Github)添加远程库12git remote add [shortname] [url]git remote add origin https:// 查看当前的远程库12git remotegit remote -v 提取远程仓库从远程仓库下载新分支与数据： 1git fetch 从远端仓库提取数据并尝试合并到当前分支： 1git merge 推送到远程仓库12git push [alias] [branch]git push -u origin master -u: 第一次提交时用，之后不需要origin: 远程仓库 删除远程仓库1git remote rm [别名]]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next主题优化]]></title>
    <url>%2F2018%2F12%2F10%2Fhexo-next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[hexo官方提供的主题实在是不怎么美观，所以开发人员就制作了第三方主题，当然主题有很多，而今天我说的next主题。关于hexo的搭建可以去官方文档，很全面，按步骤走一遍基本就会用了。 next主题的配置设置主题风格打开 themes/next/_config.yml 文件，搜索 Schemes 关键字，将你需用启用的 scheme 前面注释 # 去除即可。 12345# Schemes# scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 设置菜单项的显示文本和图标设置菜单项的显示中文文本打开 themes/next/languages/zh-Hans.yml 文件,搜索 menu 关键字，修改对应中文或者新增。 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于我 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 设定菜单项的文件目录和对应图标打开 themes/next/_config.yml 文件，搜索 menu_icons 关键字，修改对应图标名称或者新增对应 menu 的图标。 12345678910111213menu: 首页: / || home 标签: /tags/ || tags 分类: /categories/ || th 归档: /archives/ || archive 关于我: /about/ || user # schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap # commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 除了 home， archives , /后面都需要手动创建这个页面 创建菜单项对应文件目录,以分类为例使用 hexo new page 新建一个页面(不知道hexo命令可以去官方文档看)，命名为 categories ： 1$ hexo new page categories 编辑刚新建的页面,设置分类 12345---title: 分类date: 2018-12-10 14:05:23type: &quot;categories&quot;--- 头像设置添加头像打开 themes/next/_config.yml 文件，搜索 Sidebar Avatar 关键字，去掉 avatar 前面的#,把图片放入 themes/next/source/images 下,修改 avatar： 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /uploads/avatar.png 设置头像边框为圆形框打开位于 themes/next/source/css/_common/components/sidebar/sidebar-author.syl 文件,修改如下: 123456789101112.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; // 修改头像边框 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%;&#125; 特效：鼠标放置头像上旋转123456789101112131415161718192021.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; // 修改头像边框 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; // 设置旋转 transition: 1.4s all;&#125;// 可旋转的圆形头像,`hover`动作.site-author-image:hover &#123; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125; 浏览页面的时候显示当前浏览进度打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true。 12# Scroll percent label in b2t button.scrollpercent: true 侧边栏设置设置侧边栏社交链接打开 themes/next/_config.yml 文件,搜索关键字 social ,然后添加社交站点名称与地址即可。 123456789101112social: GitHub: https://github.com/zhengshikun || github E-Mail: mailto:646537311@qq.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 微博: https://weibo.com/u/3922341463?topnav=1&amp;wvr=6&amp;topsug=1 || weibo RSS在你 Hexo 站点目录下： 1$ npm install hexo-generator-feed --save 打开 Hexo 站点下的 _config.yml ,添加如下配置： 12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml limit: 20 hub: content: 友情链接打开 themes/next/_config.yml 文件,搜索关键字 Blog rolls： 12345678# Blog rollslinks_icon: linklinks_title: 友情连接#links_layout: blocklinks_layout: inlinelinks: #Title: http://example.com/ 百度: https://baidu.com/ 底部建站时间和图标修改打开 themes/next/_config.yml 文件,搜索关键字footer: 12345678910111213141516171819footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2018 # Icon between year and copyright info. icon: snowflake-o # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). # version: true 把用户的图标从小人user改成了雪花snowflake-o copyright留空，显示成页面author即我的名字 powered: false把hexo的授权图片取消了 theme: enable:false 把主题的内容也取消了 主页文章添加边框阴影效果打开 themes/next/source/css/_custom/custom.styl ,向里面加代码: 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 开启版权声明主题配置文件下,搜索关键字 post_copyright , enable 改为 true： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 本地搜索在你站点的根目录下 1$ npm install hexo-generator-searchdb --save 打开 Hexo 站点的 _config.yml,添加配置 12345search: path: search.xml field: post format: html limit: 10000 打开 themes/next/_config.yml ,搜索关键字 local_search ,设置为 true： 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 统计功能,显示文章字数统计,阅读时长,总字数1$ npm i --save hexo-wordcount 打开 themes/next/_config.yml ，搜索关键字 post_wordcount： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 修改文章内文本连接样式打开 themes/next/source/css/_custom/custom.styl,添加代码： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #999; border-bottom: none; border-bottom: 1px solid #999; &amp;:hover &#123; color: #666; border-bottom: none; border-bottom: 1px solid #666; &#125;&#125; 本地站点推送到GitHub上在站点更目录下： 1$ npm install hexo-deployer-git --save 在 Hexo 站点的 _config.yml 中配置 deploy： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; #your github.io.git branch: master 1$ hexo clean 1$ hexo d --g 详情参考官方文档 添加网易云音乐在网易云音乐（网页版）中搜索我们想要插入的音乐，然后点击生成外链播放器,然后根据你得设置生成相应的html代码，将获得的html代码插入到你想要插入的位置。 我放在了侧边栏，在 themes/next/layout/_custom/sidebar.swig 文件中增加生成的HTML代码： 123&lt;div id=&quot;music163player&quot;&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=27583241&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 结尾放我npm安装的一些插件 1234567891011121314151617&quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.7.0&quot;, &quot;hexo-asset-image&quot;: &quot;0.0.3&quot;, &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-cname&quot;: &quot;^0.3.0&quot;, &quot;hexo-generator-feed&quot;: &quot;^1.2.2&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-server&quot;: &quot;^0.3.1&quot;, &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的第一篇文章 - markdown语法]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[你好哇！这是我的第一篇文章，当你看到这里的时候就代表我成功运行啦！庆祝~关于第一篇也没啥说的，我下面就测试markdown常用的语法吧 Markdown简介Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯和亚伦·斯沃茨。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档”。 ——维基百科 Markdown语法标题123456# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt;## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt;#### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt;##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt;###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt; 这是四级标题 内容强调加粗、斜体123字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示 字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示 删除线1这样来 ~~删除一段文本~~ 删除一段文本 高亮12使用&lt;code&gt;\`&lt;/code&gt;来强调字符 // 想打出 ` (反引号)需要转义的比如`突出背景色`来显示强调效果 使用`来强调字符比如突出背景色来显示强调效果 引用显示1234&gt; 每行开始都使用 &apos;&gt;&apos;；&gt; 引用**开始**；&gt; 引用**换行**；&gt; 引用**结束**。 每行开始都使用 ‘&gt;’；引用开始；引用换行；引用结束。 表格12345列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 可以使用冒号来定义对齐方式： 1234| 左对齐 | 右对齐 | 居中 || :-------- | -------:| :--: || Computer | 5000 元 | 1台 || Phone | 1999 元 | 1部 | 左对齐 右对齐 居中 Computer 5000 元 1台 Phone 1999 元 1部 代码块代码块语法遵循标准 markdown 代码，使用三个`开始,三个`结束 123``` 这里是内容``` 链接插入12[首页](https://zhengshikun.site)[关于我](/about/) 首页关于我 图片插入1![我的头像](/博客的第一篇文章/avatar.png) 列表无序列表123* 列表展示+ 列表展示- 列表展示 列表展示 列表展示 列表展示 有序列表121. **我是一级序列** 1. *我是二级序列* 我是一级序列 我是二级序列 链接自动检测12首页:https://zhengshikun.site我的信息:https://zhengshikun.site/about/ 首页:https://zhengshikun.site我的信息:https://zhengshikun.site/about/]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
